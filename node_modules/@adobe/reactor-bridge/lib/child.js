function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/***************************************************************************************
 * (c) 2017 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/
import connectToParent from 'penpal/lib/connectToParent';
import addStylesToPage from './utils/addStylesToPage';
const STYLES = "\n  html, body {\n    background-color: transparent !important;\n  }\n";
addStylesToPage(STYLES);
let extensionViewMethods = {};
let connectionPromise;

const getExtensionViewMethod = methodName => {
  const method = extensionViewMethods[methodName];

  if (method) {
    return method.bind(extensionViewMethods);
  } else {
    throw new Error("Unable to call ".concat(methodName, " on the extension. The extension must register a ").concat(methodName, " function using extensionBridge.register()."));
  }
};

const init = function init() {
  getExtensionViewMethod('init')(...arguments);
};

const validate = function validate() {
  return Promise.resolve(getExtensionViewMethod('validate')(...arguments)).then(result => {
    if (typeof result !== 'boolean') {
      throw new Error("The extension attempted to return a non-boolean value from validate: ".concat(result));
    }

    return result;
  });
};

const getSettings = function getSettings() {
  return Promise.resolve(getExtensionViewMethod('getSettings')(...arguments)).then(result => {
    if (typeof result !== 'object') {
      throw new Error('The extension attempted to return a non-object value from getSettings: ' + result);
    }

    return result;
  });
};

const wrapOpenSharedViewMethod = (methodName, sharedViewName) => function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  let callback;

  if (typeof args[0] === 'function') {
    callback = args.shift(); // Deprecated April 10, 2018. 30+ extensions were using a callback at the time.

    console.warn('Passing a callback to extensionBridge.' + methodName + '() has been deprecated. ' + 'The method now returns a promise that should be used instead.');
  }

  return connectionPromise.then(parent => {
    if (parent[methodName]) {
      return parent[methodName](...args);
    } else {
      throw new Error("An error occurred while opening ".concat(sharedViewName, ". The shared view is unavailable."));
    }
  }).then(result => {
    if (callback) {
      callback(result);
    }

    return result;
  });
};

connectionPromise = connectToParent({
  methods: {
    init,
    validate,
    getSettings
  }
}).promise;
const extensionBridge = {
  openCodeEditor: wrapOpenSharedViewMethod('openCodeEditor', 'code editor'),
  openDataElementSelector: wrapOpenSharedViewMethod('openDataElementSelector', 'data element selector'),
  openRegexTester: wrapOpenSharedViewMethod('openRegexTester', 'regex tester'),

  register(methods) {
    extensionViewMethods = _objectSpread({}, methods);
    connectionPromise.then(parent => parent.extensionRegistered());
  }

};
window.addEventListener('focus', () => {
  connectionPromise.then(parent => parent.markAsDirty());
});

const executeQueuedCall = call => {
  // Not all of the extension bridge methods return promises. Rather than do a switch where we
  // only handle promises coming from certain methods here, we'll just always convert the return
  // value to a promise and them consistently.
  Promise.resolve(extensionBridge[call.methodName](...call.args)).then(call.resolve, call.reject);
};

const callQueue = window.extensionBridge._callQueue;

while (callQueue.length) {
  executeQueuedCall(callQueue.shift());
}

callQueue.push = executeQueuedCall;