'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Range = require('./Range');

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The IndexSet class represents a set of indices into another data structure,
 * such as an array. For example, a selection of items in a list could be stored
 * by an IndexSet. Internally, it is stored as a sorted list of ranges.
 */
var IndexSet = function () {
  /**
   * Creates a new IndexSet
   */
  function IndexSet() {
    _classCallCheck(this, IndexSet);

    this.ranges = [];
  }

  /**
   * Adds the given Range to the index set
   * @param {Range} range the range to add
   */


  _createClass(IndexSet, [{
    key: 'addRange',
    value: function addRange(range) {
      if (range.length === 0) {
        return;
      }

      range = range.copy();
      if (this.ranges.length === 0) {
        this.ranges.push(range);
        return;
      }

      var startIndex = this.findRangeIndex(range.start, true);
      var endIndex = this.findRangeIndex(range.end, true);

      var startRange = this.ranges[startIndex];
      var endRange = this.ranges[endIndex];

      var removalStart = startIndex;
      var removalEnd = endIndex;

      var matchesStart = startRange.contains(range.start) || startRange.end === range.start - 1;
      var matchesEnd = endRange.contains(range.end) || endRange.start - 1 === range.end;

      if (matchesStart) {
        range.start = startRange.start;
      }

      if (matchesEnd) {
        range.end = endRange.end;
      }

      if (startIndex === endIndex) {
        if (matchesStart || matchesEnd) {
          removalEnd++;
        }
      } else {
        if (!matchesStart) {
          removalStart++;
        }

        if (matchesEnd) {
          removalEnd++;
        }
      }

      if (removalEnd > removalStart) {
        this.ranges.splice(removalStart, removalEnd - removalStart);
      }

      if (range.start > startRange.end) {
        startIndex++;
      }

      this.ranges.splice(startIndex, 0, range);
    }

    /**
     * Adds the given index to the index set
     * @param {number} index the index to add
     */

  }, {
    key: 'addIndex',
    value: function addIndex(index) {
      this.addRange(new _Range2.default(index, index));
    }

    /**
     * Adds all indexes in the given IndexSet to this index set
     * @param {IndexSet} indexSet the IndexSet to add
     */

  }, {
    key: 'addIndexSet',
    value: function addIndexSet(indexSet) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = indexSet.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var range = _step.value;

          this.addRange(range);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Removes the given Range from the index set
     * @param {Range} range the range to remove
     */

  }, {
    key: 'removeRange',
    value: function removeRange(range) {
      if (range.length === 0 || this.ranges.length === 0) {
        return;
      }

      var startIndex = this.findRangeIndex(range.start, true);
      var endIndex = this.findRangeIndex(range.end, true);

      var startRange = this.ranges[startIndex];
      var endRange = this.ranges[endIndex];

      var removalStart = startIndex;
      var removalEnd = endIndex;

      if (startRange.contains(range.start) && range.start > startRange.start) {
        if (startIndex === endIndex && range.end < endRange.end) {
          endRange = new _Range2.default(range.end + 1, endRange.end);
          this.ranges.splice(startIndex + 1, 0, endRange);
        }

        startRange.end = range.start - 1;
        removalStart++;
      } else if (range.start > startRange.end) {
        removalStart++;
      }

      if (endRange.contains(range.end) && range.end < endRange.end) {
        endRange.start = range.end + 1;
      } else if (range.end >= endRange.end) {
        removalEnd++;
      }

      if (removalEnd > removalStart) {
        this.ranges.splice(removalStart, removalEnd - removalStart);
      }
    }

    /**
     * Removes the given index from the index set
     * @param {number} index the index to remove
     */

  }, {
    key: 'removeIndex',
    value: function removeIndex(index) {
      this.removeRange(new _Range2.default(index, index));
    }

    /**
     * Removes all indexes in the given IndexSet from this index set
     * @param {IndexSet} indexSet the IndexSet to remove
     */

  }, {
    key: 'removeIndexSet',
    value: function removeIndexSet(indexSet) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = indexSet.ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var range = _step2.value;

          this.removeRange(range);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Toggles the given index. If the index set contains the given index,
     * it is removed, otherwise it is added to the index set.
     * @param {number} index the index to toggle
     */

  }, {
    key: 'toggleIndex',
    value: function toggleIndex(index) {
      if (this.containsIndex(index)) {
        this.removeIndex(index);
      } else {
        this.addIndex(index);
      }
    }

    /**
     * Removes all indices from the IndexSet
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.ranges.length = 0;
    }

    /**
     * Adjusts the index set for an insertion by shifting
     * indices above the insertion index by the number of
     * inserted items.
     * @param {Range} range the inserted range
     */

  }, {
    key: 'adjustForInsertedRange',
    value: function adjustForInsertedRange(range) {
      this._adjustRangesAbove(range.start, range.length);
      this.removeRange(range);
    }

    /**
     * Adjusts the index set for a deletion by shifting
     * indices above the insertion index by the number
     * of deleted items.
     * @param {Range} range the deleted range
     */

  }, {
    key: 'adjustForDeletedRange',
    value: function adjustForDeletedRange(range) {
      this.removeRange(range);
      this._adjustRangesAbove(range.end + 1, -range.length);
    }

    /**
     * Adjusts the index set for a move.
     * @param {number} fromIndex the source index
     * @param {number} toIndex the destination index
     */

  }, {
    key: 'adjustForMove',
    value: function adjustForMove(fromIndex, toIndex) {
      var contains = this.containsIndex(fromIndex);

      this.adjustForDeletedRange(new _Range2.default(fromIndex, fromIndex));
      this.adjustForInsertedRange(new _Range2.default(toIndex, toIndex));

      if (contains) {
        this.addIndex(toIndex);
      }
    }

    /**
     * Helper function to increment or decrement ranges
     * above the given range's start by the range's length.
     */

  }, {
    key: '_adjustRangesAbove',
    value: function _adjustRangesAbove(index, count) {
      if (this.ranges.length === 0) {
        return;
      }

      var i = this.findRangeIndex(index, true);
      for (; i < this.ranges.length; i++) {
        var r = this.ranges[i];

        if (r.start >= index) {
          r.start += count;
        }

        if (r.end >= index) {
          r.end += count;
        }

        // merge ranges that end up next to each other
        if (i > 0 && r.start === this.ranges[i - 1].end + 1) {
          r.start = this.ranges[--i].start;
          this.ranges.splice(i, 1);
        }
      }
    }

    /**
     * Returns whether the given index is in the index set
     * @param {number} index the index to check
     * @return {boolean}
     */

  }, {
    key: 'containsIndex',
    value: function containsIndex(index) {
      return this.findRangeIndex(index) >= 0;
    }

    /**
     * Returns whether all indexes in the given Range are in the index set
     * @param {Range} range the range to check
     * @return {boolean}
     */

  }, {
    key: 'containsRange',
    value: function containsRange(range) {
      var startingRange = this.findRange(range);
      if (startingRange) {
        return startingRange.contains(range.start) && startingRange.contains(range.end);
      }

      return false;
    }

    /**
     * The first index in the index set
     * @type {number}
     */

  }, {
    key: Symbol.iterator,


    /**
     * An ES6 iterator for looping through the indexes
     * in the index set one at a time.
     * @return {Generator}
     */
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, range, i;

      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context.prev = 3;
              _iterator3 = this.ranges[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context.next = 17;
                break;
              }

              range = _step3.value;
              i = range.start;

            case 8:
              if (!(i <= range.end)) {
                _context.next = 14;
                break;
              }

              _context.next = 11;
              return i;

            case 11:
              i++;
              _context.next = 8;
              break;

            case 14:
              _iteratorNormalCompletion3 = true;
              _context.next = 5;
              break;

            case 17:
              _context.next = 23;
              break;

            case 19:
              _context.prev = 19;
              _context.t0 = _context['catch'](3);
              _didIteratorError3 = true;
              _iteratorError3 = _context.t0;

            case 23:
              _context.prev = 23;
              _context.prev = 24;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 26:
              _context.prev = 26;

              if (!_didIteratorError3) {
                _context.next = 29;
                break;
              }

              throw _iteratorError3;

            case 29:
              return _context.finish(26);

            case 30:
              return _context.finish(23);

            case 31:
            case 'end':
              return _context.stop();
          }
        }
      }, value, this, [[3, 19, 23, 31], [24,, 26, 30]]);
    })

    /**
     * An ES6 iterator for looping the the indexes
     * in the index set on at a time, in reverse.
     * @type {Iterator}
     */

  }, {
    key: 'objectsFromArray',


    /**
     * Returns an array of items from the given array
     * whose indexes are in the index set.
     * @param {Array} arr the array to get items from
     * @return {Array}
     */
    value: function objectsFromArray(arr) {
      var res = [];

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var index = _step4.value;

          res.push(arr[index]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return res;
    }

    /**
     * Removes the indices specified by this index set
     * from the given array.
     * @param {Array} arr the array to remove items from
     */

  }, {
    key: 'removeFromArray',
    value: function removeFromArray(arr) {
      for (var rangeIndex = this.ranges.length - 1; rangeIndex >= 0; rangeIndex--) {
        var range = this.ranges[rangeIndex];
        arr.splice(range.start, range.length);
      }
    }

    /**
     * Returns whether this index set is equal to the given index set
     * @param {IndexSet} other the IndexSet to compare
     * @return {boolean}
     */

  }, {
    key: 'equals',
    value: function equals(other) {
      if (!other || !(other instanceof IndexSet)) {
        return false;
      }

      if (other === this) {
        return true;
      }

      if (other.ranges.length !== this.ranges.length) {
        return false;
      }

      for (var i = 0; i < this.ranges.length; i++) {
        if (!this.ranges[i].equals(other.ranges[i])) {
          return false;
        }
      }

      return true;
    }

    /**
     * Returns a copy of the index set
     * @return {IndexSet}
     */

  }, {
    key: 'copy',
    value: function copy() {
      var res = new IndexSet();

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.ranges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var range = _step5.value;

          res.ranges.push(range.copy());
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return res;
    }

    /**
     * Returns a new index set containing the indexes in this
     * index set minus the indexes in the other index set.
     * @param {IndexSet} other the index set to subtract from this one
     */

  }, {
    key: 'difference',
    value: function difference(other) {
      var res = this.copy();
      res.removeIndexSet(other);
      return res;
    }
  }, {
    key: 'findRangeIndex',
    value: function findRangeIndex(index) {
      var nearest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var ranges = this.ranges;
      var low = 0;
      var high = ranges.length;
      var mid = void 0;

      while (low < high) {
        mid = low + high >> 1;
        var range = ranges[mid];

        if (index < range.start) {
          high = mid;
        } else if (index > range.end) {
          low = mid + 1;
        } else {
          return mid;
        }
      }

      if (nearest) {
        return mid;
      }

      return -1;
    }
  }, {
    key: 'findRange',
    value: function findRange(index) {
      var rangeIndex = this.findRangeIndex(index);
      if (rangeIndex === -1) {
        return null;
      }

      return this.ranges[rangeIndex];
    }
  }, {
    key: 'firstIndex',
    get: function get() {
      if (this.ranges.length > 0) {
        return this.ranges[0].start;
      }

      return -1;
    }

    /**
     * The last index in the index set
     * @type {number}
     */

  }, {
    key: 'lastIndex',
    get: function get() {
      if (this.ranges.length > 0) {
        return this.ranges[this.ranges.length - 1].end;
      }

      return -1;
    }

    /**
     * The number of indexes in the index set
     * @type {number}
     */

  }, {
    key: 'length',
    get: function get() {
      var length = 0;

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.ranges[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var range = _step6.value;

          length += range.length;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return length;
    }

    /**
     * Whether the IndexSet is empty
     * @type {boolean}
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      return this.ranges.length === 0;
    }
  }, {
    key: 'reverseIterator',
    get: function get() {
      var ranges = this.ranges;

      return _defineProperty({}, Symbol.iterator, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var rangeIndex, range, i;
        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                rangeIndex = ranges.length - 1;

              case 1:
                if (!(rangeIndex >= 0)) {
                  _context2.next = 13;
                  break;
                }

                range = ranges[rangeIndex];
                i = range.end;

              case 4:
                if (!(i >= range.start)) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 7;
                return i;

              case 7:
                i--;
                _context2.next = 4;
                break;

              case 10:
                rangeIndex--;
                _context2.next = 1;
                break;

              case 13:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }]);

  return IndexSet;
}();

exports.default = IndexSet;