'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DragTarget = require('./DragTarget');

var _DragTarget2 = _interopRequireDefault(_DragTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * {@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how
 * to position and style them. However, layouts do not create the views themselves directly. Instead,
 * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,
 * such as its position and size. The {@link CollectionView} is then responsible for creating the actual
 * views as needed, based on this layout information.
 *
 * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the
 * two methods listed below. All other methods can be optionally overridden to implement custom behavior.
 *
 * - {@link getVisibleLayoutInfos}
 * - {@link getLayoutInfo}
 */
var Layout = function () {
  function Layout() {
    _classCallCheck(this, Layout);

    /**
     * The CollectionView the layout is currently attached to
     * @type {CollectionView}
     */
    this.collectionView = null;
  }

  /**
   * Returns whether the layout should invalidate in response to
   * visible rectangle changes. By default, it only invalidates
   * when the collection view's size changes. Return true always
   * to make the layout invalidate while scrolling (e.g. sticky headers).
   * @param {Rect} rect
   * @return {boolean}
   */


  _createClass(Layout, [{
    key: 'shouldInvalidate',
    value: function shouldInvalidate(rect) {
      // By default, invalidate when the size changes
      var size = this.collectionView.size;
      return rect.width !== size.width || rect.height !== size.height;
    }

    /**
     * This method allows the layout to perform any pre-computation
     * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
     * Called by the collection view before {@link getVisibleLayoutInfos}
     * or {@link getLayoutInfo} are called.\
     * @param {object} invalidationContext
     */

  }, {
    key: 'validate',
    value: function validate(invalidationContext) {}

    /**
     * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.
     * Should be implemented by subclasses.
     * @abstract
     * @param {Rect} rect - The rectangle that should contain the returned LayoutInfo objects
     * @return {LayoutInfo[]}
     */

  }, {
    key: 'getVisibleLayoutInfos',
    value: function getVisibleLayoutInfos(rect) {
      throw new Error('getVisibleLayoutInfos must be implemented by Layout subclasses');
    }

    /**
     * Returns a {@link LayoutInfo} for the given type, section, and index.
     * Should be implemented by subclasses.
     * @abstract
     * @param {string} type - The type of the LayoutInfo to retrieve
     * @param {number} section - The section of the LayoutInfo to retrieve
     * @param {index} index - The index of the LayoutInfo to retrieve
     * @return {LayoutInfo}
     */

  }, {
    key: 'getLayoutInfo',
    value: function getLayoutInfo(type, section, index) {
      throw new Error('getLayoutInfo must be implemented by Layout subclasses');
    }

    /**
     * Returns a {@link DragTarget} describing a view at the given point to be dragged.
     * Return `null` to cancel the drag. The default implementation returns the view at the given point.
     * @param {Point} point - The point at which the drag occurred
     * @return {?DragTarget}
     */

  }, {
    key: 'getDragTarget',
    value: function getDragTarget(point) {
      var target = this.collectionView.indexPathAtPoint(point);
      if (!target) {
        return null;
      }

      return new _DragTarget2.default('item', target);
    }

    /**
     * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
     * to reject the drop. The dropped items will be inserted before the resulting target.
     * @param {Point} point - The point at which the drop occurred
     * @return {?DragTarget}
     */

  }, {
    key: 'getDropTarget',
    value: function getDropTarget(point) {
      return null;
    }

    /**
     * Returns the starting attributes for an animated insertion.
     * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
     * The default implementation just returns a copy of the result of calling {@link getLayoutInfo}.
     *
     * @param {string} type - The type of the LayoutInfo to retrieve
     * @param {number} section - The section of the LayoutInfo to retrieve
     * @param {index} index - The index of the LayoutInfo to retrieve
     * @return {LayoutInfo}
     */

  }, {
    key: 'getInitialLayoutInfo',
    value: function getInitialLayoutInfo(type, section, index) {
      return this.getLayoutInfo(type, section, index).copy();
    }

    /**
     * Returns the ending attributes for an animated removal.
     * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
     * to the one returned by this method. The default implementation returns a copy of
     * the starting {@link LayoutInfo}.
     *
     * @param {string} type - The type of the LayoutInfo to retrieve
     * @param {number} section - The section of the LayoutInfo to retrieve
     * @param {index} index - The index of the LayoutInfo to retrieve
     * @return {LayoutInfo}
     */

  }, {
    key: 'getFinalLayoutInfo',
    value: function getFinalLayoutInfo(type, section, index) {
      var key = [type, section, index].join(':');
      return this.collectionView._transaction.finalLayoutInfo.get(key).copy();
    }

    /**
     * Called to notify the layout of an item insertion.
     * Does nothing by default.
     * @param {IndexPath} indexPath - The inserted IndexPath
     */

  }, {
    key: 'itemInserted',
    value: function itemInserted(indexPath) {}

    /**
     * Called to notify the layout of an item removal.
     * Does nothing by default.
     * @param {IndexPath} indexPath - The removed IndexPath
     */

  }, {
    key: 'itemRemoved',
    value: function itemRemoved(indexPath) {}

    /**
     * Called to notify the layout of an item move.
     * Does nothing by default.
     * @param {IndexPath} from - The source IndexPath
     * @param {IndexPath} to - The destination IndexPath
     */

  }, {
    key: 'itemMoved',
    value: function itemMoved(from, to) {}

    /**
     * Called to notify the layout of an item replacement.
     * Does nothing by default.
     * @param {IndexPath} indexPath - The replaced IndexPath
     */

  }, {
    key: 'itemReplaced',
    value: function itemReplaced(indexPath) {}

    /**
     * Called to notify the layout of a section insertion.
     * Does nothing by default.
     * @param {number} section - The inserted section
     */

  }, {
    key: 'sectionInserted',
    value: function sectionInserted(section) {}

    /**
     * Called to notify the layout of a section removal.
     * Does nothing by default.
     * @param {number} section - The remove section
     */

  }, {
    key: 'sectionRemoved',
    value: function sectionRemoved(section) {}

    /**
     * Called to notify the layout of a section insertion.
     * Does nothing by default.
     * @param {number} fromSection - The source section
     * @param {number} toSection - The destination section
     */

  }, {
    key: 'sectionMoved',
    value: function sectionMoved(fromSection, toSection) {}

    /**
     * Called to notify the layout of a section replacement.
     * Does nothing by default.
     * @param {number} section - The replaced section
     */

  }, {
    key: 'sectionReplaced',
    value: function sectionReplaced(section) {}

    /**
     * Returns the {@link IndexPath} visually above the given one, or `null` for none.
     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`
     * by default.
     * @param {IndexPath} indexPath
     * @return {IndexPath}
     */

  }, {
    key: 'indexPathAbove',
    value: function indexPathAbove(indexPath) {
      return null;
    }

    /**
     * Returns the {@link IndexPath} visually below the given one, or `null` for none.
     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`
     * by default.
     * @param {IndexPath} indexPath
     * @return {IndexPath}
     */

  }, {
    key: 'indexPathBelow',
    value: function indexPathBelow(indexPath) {
      return null;
    }

    /**
     * Returns the {@link IndexPath} visually to the left of the given one, or `null` for none.
     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`
     * by default.
     * @param {IndexPath} indexPath
     * @return {IndexPath}
     */

  }, {
    key: 'indexPathLeftOf',
    value: function indexPathLeftOf(indexPath) {
      return null;
    }

    /**
     * Returns the {@link IndexPath} visually to the right of the given one, or `null` for none.
     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`
     * by default.
     * @param {IndexPath} indexPath
     * @return {IndexPath}
     */

  }, {
    key: 'indexPathRightOf',
    value: function indexPathRightOf(indexPath) {
      return null;
    }

    /**
     * Returns size of the content. By default, it returns collectionView's size.
     * @return {Size}
     */

  }, {
    key: 'getContentSize',
    value: function getContentSize() {
      var contentSize = this.collectionView.size.copy();
      // backward compatibility - if there are contentWidth/contentHeight set, override content's size
      if (this.contentWidth) {
        contentSize.width = this.contentWidth;
      }
      if (this.contentHeight) {
        contentSize.height = this.contentHeight;
      }
      return contentSize;
    }
  }]);

  return Layout;
}();

exports.default = Layout;