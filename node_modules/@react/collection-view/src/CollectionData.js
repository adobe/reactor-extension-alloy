'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _IndexPath = require('./IndexPath');

var _IndexPath2 = _interopRequireDefault(_IndexPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * These wrapper objects allow us to store a unique id for each
 * section and item in a collection view. These are used to generate
 * ids for views.
 */
var UID = 0;

var Section = function Section() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  _classCallCheck(this, Section);

  this.id = UID++;
  this.items = items.map(function (item) {
    return new Item(item);
  });
};

var Item = function Item(item) {
  _classCallCheck(this, Item);

  this.id = UID++;
  this.item = item;
};

/**
 * This class is used as a cache of the currently displayed data in a CollectionView.
 * The DataSource may get ahead of what is currently displayed due to animations.
 * CollectionData also provides caching, in case it is slow to compute each item, for example.
 * @private
 */


var CollectionData = function () {
  function CollectionData(dataSource) {
    _classCallCheck(this, CollectionData);

    this.dataSource = dataSource;
    this.sections = [];

    var numSections = dataSource ? dataSource.getNumberOfSections() : 0;
    for (var section = 0; section < numSections; section++) {
      var count = dataSource.getSectionLength(section);

      var items = [];
      for (var index = 0; index < count; index++) {
        items.push(dataSource.getItem(section, index));
      }

      this.sections[section] = new Section(items);
    }
  }

  _createClass(CollectionData, [{
    key: 'getNumberOfSections',
    value: function getNumberOfSections() {
      return this.sections.length;
    }
  }, {
    key: 'getSectionLength',
    value: function getSectionLength(section) {
      if (section < 0 || section >= this.sections.length) {
        return 0;
      }

      return this.sections[section].items.length;
    }
  }, {
    key: 'getItemsInSection',
    value: function getItemsInSection(section) {
      return this.sections[section].items.map(function (c) {
        return c.item;
      });
    }
  }, {
    key: 'getItem',
    value: function getItem(section, index) {
      return this.sections[section].items[index].item;
    }
  }, {
    key: 'getSectionID',
    value: function getSectionID(section) {
      return this.sections[section].id;
    }
  }, {
    key: 'getItemID',
    value: function getItemID(section, index) {
      return this.sections[section].items[index].id;
    }
  }, {
    key: 'getKey',
    value: function getKey(type, section, index) {
      // If there is no section, this is a global view not tied to content.
      // Use the LayoutInfo's type as its id, assuming it will be unique.
      if (section == null) {
        return type;
      }

      // Get a unique id for this layout info tied to the content.
      // This id will not change, even if the content is moved around.
      // If layoutInfo.index is null, the layout info is tied to
      // a section instead of an individual item.
      var id = index == null ? this.getSectionID(section) : this.getItemID(section, index);

      return type + ':' + id;
    }
  }, {
    key: '_checkIndex',
    value: function _checkIndex(indexPath) {
      var insert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var section = indexPath.section,
          index = indexPath.index;

      if (section < 0 || section >= this.sections.length) {
        return false;
      }

      if (index < 0 || index > this.sections[section].items.length) {
        return;
      }

      if (!insert && index === this.sections[section].items.length) {
        return false;
      }

      return true;
    }
  }, {
    key: 'insertItem',
    value: function insertItem(item, indexPath) {
      if (!this._checkIndex(indexPath, true)) {
        return;
      }

      this.sections[indexPath.section].items.splice(indexPath.index, 0, new Item(item));
    }
  }, {
    key: 'insertSection',
    value: function insertSection(section, items) {
      if (section < 0 || section > this.sections.length) {
        return;
      }

      this.sections.splice(section, 0, new Section(items));
    }
  }, {
    key: 'removeItem',
    value: function removeItem(indexPath) {
      if (!this._checkIndex(indexPath)) {
        return;
      }

      this.sections[indexPath.section].items.splice(indexPath.index, 1);
    }
  }, {
    key: 'removeSection',
    value: function removeSection(section) {
      if (section < 0 || section >= this.sections.length) {
        return;
      }

      this.sections.splice(section, 1);
    }
  }, {
    key: 'moveItem',
    value: function moveItem(from, to) {
      if (!this._checkIndex(from)) {
        return;
      }

      if (!this._checkIndex(to, true)) {
        return;
      }

      var item = this.sections[from.section].items.splice(from.index, 1)[0];
      this.sections[to.section].items.splice(to.index, 0, item);
    }
  }, {
    key: 'moveSection',
    value: function moveSection(fromSection, toSection) {
      if (fromSection < 0 || fromSection >= this.sections.length) {
        return;
      }

      if (toSection < 0 || toSection >= this.sections.length) {
        return;
      }

      var section = this.sections.splice(fromSection, 1)[0];
      this.sections.splice(toSection, 0, section);
    }
  }, {
    key: 'replaceItem',
    value: function replaceItem(indexPath, item, retainID) {
      if (!this._checkIndex(indexPath)) {
        return;
      }

      var items = this.sections[indexPath.section].items;
      if (retainID) {
        items[indexPath.index].item = item;
      } else {
        items[indexPath.index] = new Item(item);
      }
    }
  }, {
    key: 'replaceSection',
    value: function replaceSection(section, items) {
      if (section < 0 || section >= this.sections.length) {
        return;
      }

      this.sections[section] = new Section(items);
    }
  }, {
    key: 'incrementIndexPath',
    value: function incrementIndexPath(indexPath, amount) {
      var section = indexPath.section,
          index = indexPath.index;


      if (amount < 0) {
        amount = -amount;

        while (section >= 0 && amount > 0) {
          var amt = Math.min(amount, index);
          amount -= amt;
          index -= amt;

          while (amount > 0 && --section >= 0 && (index = this.getSectionLength(section)) === 0) {
            continue;
          }
        }
      } else {
        while (section < this.sections.length && amount > 0) {
          var sectionLength = this.getSectionLength(section);
          var _amt = Math.min(amount, sectionLength - index);
          amount -= _amt;
          index += _amt;

          if (amount > 0 || index === sectionLength) {
            do {
              section++;
            } while (section < this.sections.length && this.getSectionLength(section) === 0);

            index = 0;
          }
        }
      }

      if (section >= this.sections.length || section < 0) {
        return null;
      }

      return new _IndexPath2.default(section, index);
    }
  }, {
    key: 'firstIndexPath',
    get: function get() {
      for (var section = 0; section < this.sections.length; section++) {
        if (this.getSectionLength(section) > 0) {
          return new _IndexPath2.default(section, 0);
        }
      }

      return null;
    }
  }, {
    key: 'lastIndexPath',
    get: function get() {
      for (var section = this.sections.length - 1; section >= 0; section--) {
        var len = this.getSectionLength(section);
        if (len > 0) {
          return new _IndexPath2.default(section, len - 1);
        }
      }

      return null;
    }
  }]);

  return CollectionData;
}();

exports.default = CollectionData;