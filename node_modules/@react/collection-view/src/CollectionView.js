'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CollectionData = require('./CollectionData');

var _CollectionData2 = _interopRequireDefault(_CollectionData);

var _utils = require('./utils');

var _DataSource = require('./DataSource');

var _DataSource2 = _interopRequireDefault(_DataSource);

var _IndexPath = require('./IndexPath');

var _IndexPath2 = _interopRequireDefault(_IndexPath);

var _IndexPathSet = require('./IndexPathSet');

var _IndexPathSet2 = _interopRequireDefault(_IndexPathSet);

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

var _Rect = require('./Rect');

var _Rect2 = _interopRequireDefault(_Rect);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _ScrollView2 = require('./ScrollView.js');

var _ScrollView3 = _interopRequireDefault(_ScrollView2);

var _Transaction = require('./Transaction');

var _Transaction2 = _interopRequireDefault(_Transaction);

var _tween = require('./tween');

var _tween2 = _interopRequireDefault(_tween);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The CollectionView class renders a scrollable collection of data using customizable layouts,
 * and manages animated updates to the data over time. It supports very large collections by
 * only rendering visible views to the DOM, reusing them as you scroll. Collection views can
 * present any type of view, including non-item views such as section headers and footers.
 * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction
 * with the collection, including drag and drop, multiple selection, and keyboard interacton.
 *
 * Collection views get their data from a {@link DataSource} object that you provide. Items are
 * grouped into sections by the data source, and the collection view calls its methods to retrieve
 * the data. When data changes, the data source emits change events, and the collection view
 * updates as appropriate, optionally with an animated transition. There is one built-in data source
 * implementation, {@link ArrayDataSource}, which renders content from a 2d array.
 *
 * Collection views use {@link Layout} objects to compute what views should be visible, and how
 * to position and style them. This means that collection views can have their items arranged in
 * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed
 * dynamically at runtime as well, optionally with an animated transition between the layouts.
 *
 * Layouts produce information on what views should appear in the collection view, but do not create
 * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object
 * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.
 * The delegate determines what type of view to display for each item, and creates instances of
 * views as needed by the collection view. Those views are then reused by the collection view as
 * the user scrolls through the content.
 */
var CollectionView = function (_ScrollView) {
  _inherits(CollectionView, _ScrollView);

  function CollectionView() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CollectionView);

    /**
     * The collection view delegate. The delegate is used by the collection view
     * to create and configure views.
     * @type {CollectionViewDelegate}
     */
    var _this = _possibleConstructorReturn(this, (CollectionView.__proto__ || Object.getPrototypeOf(CollectionView)).call(this, options));

    _this.delegate = null;

    _this._content = null;
    _this._layout = null;
    _this._dataSource = null;
    _this._reusableViews = {};
    _this._visibleViews = new Map();
    _this._invalidationContext = null;

    _this._scrollAnimation = null;
    _this._sizeUpdateQueue = new _IndexPathSet2.default();
    _this._animatedContentOffset = new _Point2.default(0, 0);

    _this._transaction = null;
    _this._nextTransaction = null;
    _this._transactionQueue = [];

    _this._startTransaction = _this._startTransaction.bind(_this);
    _this._endTransaction = _this._endTransaction.bind(_this);
    _this._insertItem = _this._insertItem.bind(_this);
    _this._insertSection = _this._insertSection.bind(_this);
    _this._removeItem = _this._removeItem.bind(_this);
    _this._removeSection = _this._removeSection.bind(_this);
    _this._moveItem = _this._moveItem.bind(_this);
    _this._moveSection = _this._moveSection.bind(_this);
    _this._reloadItem = _this._reloadItem.bind(_this);
    _this._reloadSection = _this._reloadSection.bind(_this);

    // Set options from passed object if given
    var _arr = ['delegate', 'size', 'layout', 'dataSource'];
    for (var _i = 0; _i < _arr.length; _i++) {
      var key = _arr[_i];
      if (options[key]) {
        _this[key] = options[key];
      }
    }

    /**
     * The duration of animated layout changes, in milliseconds. Default is 500ms.
     * @type {number}
     */
    _this.transitionDuration = options.transitionDuration || 500;

    /**
     * Whether to enable scroll anchoring. This will attempt to restore the scroll position
     * after layout changes outside the viewport. Default is off.
     * @type {boolean}
     */
    _this.anchorScrollPosition = options.anchorScrollPosition || false;

    /**
     * Whether to anchor the scroll position when at the top of the content. Default is off.
     * @type {boolean}
     */
    _this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
    return _this;
  }

  _createClass(CollectionView, [{
    key: 'setSize',
    value: function setSize(size) {
      // Ignore if the sizes are equal
      if (size.equals(this.size)) {
        return;
      }

      var visibleRect = this.getVisibleRect(this.contentOffset, size);
      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(visibleRect);
      _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'setSize', this).call(this, size);

      if (shouldInvalidate) {
        this.relayout({
          sizeChanged: true
        });
      }
    }

    /**
     * Get the collection view's data source
     * @type {DataSource}
     */

  }, {
    key: '_setDataSource',
    value: function _setDataSource(dataSource) {
      if (dataSource && !(dataSource instanceof _DataSource2.default)) {
        throw new Error('Data source must be a subclass of DataSource');
      }

      if (this._dataSource) {
        this._teardownDataSource();
      }

      this._dataSource = dataSource;
      if (dataSource) {
        this._setupDataSource();
      }

      this.reloadData();
    }

    /**
     * Reloads the data from the data source and relayouts the collection view.
     * Does not animate any changes. Equivalent to re-assigning the same data source
     * to the collection view.
     */

  }, {
    key: 'reloadData',
    value: function reloadData() {
      this._content = new _CollectionData2.default(this.dataSource);
      this.relayout({
        contentChanged: true
      });
    }
  }, {
    key: '_setupDataSource',
    value: function _setupDataSource() {
      this._dataSource.on('startTransaction', this._startTransaction);
      this._dataSource.on('endTransaction', this._endTransaction);
      this._dataSource.on('insertItem', this._insertItem);
      this._dataSource.on('insertSection', this._insertSection);
      this._dataSource.on('removeItem', this._removeItem);
      this._dataSource.on('removeSection', this._removeSection);
      this._dataSource.on('moveItem', this._moveItem);
      this._dataSource.on('moveSection', this._moveSection);
      this._dataSource.on('reloadSection', this._reloadSection);
      this._dataSource.on('reloadItem', this._reloadItem);
    }
  }, {
    key: '_teardownDataSource',
    value: function _teardownDataSource() {
      this._dataSource.removeListener('startTransaction', this._startTransaction);
      this._dataSource.removeListener('endTransaction', this._endTransaction);
      this._dataSource.removeListener('insertItem', this._insertItem);
      this._dataSource.removeListener('insertSection', this._insertSection);
      this._dataSource.removeListener('removeItem', this._removeItem);
      this._dataSource.removeListener('removeSection', this._removeSection);
      this._dataSource.removeListener('moveItem', this._moveItem);
      this._dataSource.removeListener('moveSection', this._moveSection);
      this._dataSource.removeListener('reloadSection', this._reloadSection);
      this._dataSource.removeListener('reloadItem', this._reloadItem);
    }

    /**
     * Returns the number of sections in the collection view
     * @return {number}
     */

  }, {
    key: 'getNumberOfSections',
    value: function getNumberOfSections() {
      return this._content ? this._content.getNumberOfSections() : 0;
    }

    /**
     * Returns the number of items in the given section
     * @param {number} section
     * @return {number}
     */

  }, {
    key: 'getSectionLength',
    value: function getSectionLength(section) {
      return this._content ? this._content.getSectionLength(section) : 0;
    }

    /**
     * Returns the item at the given section and index. You can also pass
     * an {@link IndexPath} as the only argument instead.
     * @param {number|IndexPath} section
     * @param {number} index
     */

  }, {
    key: 'getItem',
    value: function getItem(section, index) {
      if (section instanceof _IndexPath2.default) {
        index = section.index;
        section = section.section;
      }

      return this._content ? this._content.getItem(section, index) : null;
    }

    /**
     * Returns an IndexPath by adding the given number of items to the provided IndexPath.
     * Works across sections such that if you add one to the last item in a section, you
     * will get the first item in the next section.
     *
     * @param {IndexPath} indexPath - The IndexPath to add to
     * @param {number} amount - The amount to add
     * @return {IndexPath}
     */

  }, {
    key: 'incrementIndexPath',
    value: function incrementIndexPath(indexPath, amount) {
      return this._content ? this._content.incrementIndexPath(indexPath, amount) : null;
    }

    /**
     * Get the collection view's layout
     * @type {Layout}
     */

  }, {
    key: 'setLayout',


    /**
     * Sets the collection view's layout, optionally with an animated transition
     * from the current layout to the new layout.
     * @param {Layout} layout - The layout to switch to
     * @param {boolean} [animated=false] - Whether to animate the layout change
     */
    value: function setLayout(layout) {
      var _this2 = this;

      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var applyLayout = function applyLayout() {
        if (_this2._layout) {
          _this2._layout.collectionView = null;
        }

        layout.collectionView = _this2;
        _this2._layout = layout;
      };

      if (animated) {
        // Animated layout transitions are really simple, thanks to our transaction support.
        // We just set the layout inside a transaction action, which runs after the initial
        // layout infos for the animation are retrieved from the previous layout. Then, the
        // final layout infos are retrieved from the new layout, and animations occur.
        this._runTransaction(applyLayout);
      } else {
        applyLayout();
        this.relayout();
      }
    }
  }, {
    key: 'createView',
    value: function createView(type, section, index) {
      return this.delegate.createView(type, section, index);
    }
  }, {
    key: '_getReuseType',
    value: function _getReuseType(layoutInfo, content) {
      if (layoutInfo.type === 'item') {
        var type = this.delegate.getType ? this.delegate.getType(content) : 'item';
        var reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;
        return { type: type, reuseType: reuseType };
      }

      return {
        type: layoutInfo.type,
        reuseType: layoutInfo.type
      };
    }
  }, {
    key: 'getReusableView',
    value: function getReusableView(layoutInfo) {
      var content = this._getViewContent(layoutInfo.type, layoutInfo.section, layoutInfo.index);

      var _getReuseType2 = this._getReuseType(layoutInfo, content),
          type = _getReuseType2.type,
          reuseType = _getReuseType2.reuseType;

      if (!this._reusableViews[reuseType]) {
        this._reusableViews[reuseType] = [];
      }

      var reusable = this._reusableViews[reuseType];
      var view = reusable.length > 0 ? reusable.pop() : this.createView(type, layoutInfo.section, layoutInfo.index);

      view.collectionView = this;
      view.viewType = reuseType;

      this._applyLayoutInfo(view, layoutInfo);
      view.setContent(content);

      return view;
    }
  }, {
    key: '_getViewContent',
    value: function _getViewContent(type, section, index) {
      if (type === 'item') {
        return this.getItem(section, index);
      }

      if (this.delegate.getContentForExtraView) {
        return this.delegate.getContentForExtraView(type, section, index);
      }

      return null;
    }

    /**
     * Returns an array of all currently visible views, including both
     * item views and supplementary views.
     * @type {ReusableView[]}
     */

  }, {
    key: 'getItemView',


    /**
     * Gets the visible item view for the given section and index. You can also pass
     * an {@link IndexPath} as the only argument instead. Returns null if
     * the view is not currently visible.
     *
     * @param {number|IndexPath} section
     * @param {number} index
     * @return {ReusableView}
     */
    value: function getItemView(section, index) {
      return this.getView('item', section, index);
    }

    /**
     * Gets the visible view for the given parameters. You can also pass
     * an {@link IndexPath} as the second argument instead. Returns null if
     * the view is not currently visible.
     *
     * @param {string} type - The view type. `'item'` for an item view.
     * @param {number|IndexPath} section
     * @param {number} index
     * @return {ReusableView}
     */

  }, {
    key: 'getView',
    value: function getView(type, section, index) {
      if (section instanceof _IndexPath2.default) {
        index = section.index;
        section = section.section;
      }

      try {
        var key = this._content.getKey(type, section, index);
        return this._visibleViews.get(key);
      } catch (err) {
        return null;
      }
    }

    /**
     * Returns an array of visible views matching the given type.
     * @param {string} type - The view type to find. `'item'` for item views.
     * @return {ReusableView[]}
     */

  }, {
    key: 'getViewsOfType',
    value: function getViewsOfType(type) {
      return this.visibleViews.filter(function (v) {
        return v.layoutInfo.type === type;
      });
    }

    /**
     * Reloads the content of the supplementary view matching the given parameters.
     * You can also pass an {@link IndexPath} as the second argument instead.
     * This method does not work with item views. You should emit a "reloadItem" or
     * "reloadSection" event from your data source instead.
     *
     * @param {string} type - The view type. `'item'` for an item view.
     * @param {number|IndexPath} section
     * @param {number} index
     */

  }, {
    key: 'reloadSupplementaryView',
    value: function reloadSupplementaryView(type, section, index) {
      var _this3 = this;

      if (type === 'item') {
        throw new Error('Do not reload item views with this method. ' + 'Emit a "reloadItem" or "reloadSection" event from your data source instead.');
      }

      if (section instanceof _IndexPath2.default) {
        index = section.index;
        section = section.section;
      }

      var content = this._getViewContent(type, section, index);

      this._runTransaction(function () {
        var view = _this3.getView(type, section, index);
        if (!view) {
          return;
        }

        view.setContent(content);
      }, false);
    }

    /**
     * Reloads the content of all visible supplementary views of the given type.
     * @param {string} type - The view type to reload. `'item'` for an item view.
     */

  }, {
    key: 'reloadSupplementaryViewsOfType',
    value: function reloadSupplementaryViewsOfType(type) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.getViewsOfType(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var view = _step.value;

          if (view.layoutInfo) {
            this.reloadSupplementaryView(type, view.layoutInfo.section, view.layoutInfo.index);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Returns the IndexPath that the given view represents. Returns null
     * if the view is not currently visible.
     *
     * @param {ReusableView} view
     * @return {IndexPath}
     */

  }, {
    key: 'indexPathForView',
    value: function indexPathForView(view) {
      if (view && view.layoutInfo && view.layoutInfo.type === 'item') {
        return new _IndexPath2.default(view.layoutInfo.section, view.layoutInfo.index);
      }

      return null;
    }

    /**
     * Returns the IndexPath for the item view currently at the given point.
     * @param {Point} point
     * @return {indexPath}
     */

  }, {
    key: 'indexPathAtPoint',
    value: function indexPathAtPoint(point) {
      var rect = new _Rect2.default(point.x, point.y, 1, 1);
      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);

      var layoutInfo = layoutInfos.filter(function (l) {
        return l.type === 'item';
      })[0];
      if (!layoutInfo) {
        return null;
      }

      return new _IndexPath2.default(layoutInfo.section, layoutInfo.index);
    }

    /**
     * Returns the IndexPath for the item view containing a given DOM node
     * @param {HTMLElement} node a DOM node
     * @return {indexPath}
     */

  }, {
    key: 'indexPathAtDOMNode',
    value: function indexPathAtDOMNode(node) {
      var view = Array.from(this._visibleViews.values()).find(function (v) {
        var domNode = v.getDOMNode();
        return v.layoutInfo.type === 'item' && domNode && (domNode === node || domNode.contains(node));
      });

      if (!view) {
        return null;
      }

      return new _IndexPath2.default(view.layoutInfo.section, view.layoutInfo.index);
    }

    /**
     * Triggers a layout invalidation, and updates the visible subviews.
     * @param {Object} context - An invalidation context.
     */

  }, {
    key: 'relayout',
    value: function relayout() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Ignore relayouts while animating the scroll position
      if (this._scrollAnimation) {
        return;
      }

      // If we already scheduled a relayout, extend the invalidation
      // context so we coalesce multiple relayouts in the same frame.
      if (this._invalidationContext) {
        Object.assign(this._invalidationContext, context);
        return;
      }

      this._invalidationContext = context;
      this._relayoutRaf = (0, _raf2.default)(function () {
        _this4._relayoutRaf = null;
        _this4.relayoutNow();
      });
    }

    /**
     * Performs a relayout immediately. Prefer {@link relayout} over this method
     * where possible, since it coalesces multiple layout passes in the same tick.
     * @param {Object} [context] - An invalidation context
     */

  }, {
    key: 'relayoutNow',
    value: function relayoutNow() {
      var _this5 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {};

      // Cancel the scheduled relayout, since we're doing it now.
      if (this._relayoutRaf) {
        _raf2.default.cancel(this._relayoutRaf);
        this._relayoutRaf = null;
      }

      // Reset the invalidation context
      this._invalidationContext = null;

      // Do nothing if we don't have a layout or content, or we are
      // in the middle of an animated scroll transition.
      if (!this.layout || !this._content || this._scrollAnimation) {
        return;
      }

      var scrollAnchor = this._getScrollAnchor();

      // Enable transitions if this is an animated relayout
      if (context.animated) {
        this._enableTransitions();
      }

      // Trigger the beforeLayout hook, if provided
      if (typeof context.beforeLayout === 'function') {
        context.beforeLayout();
      }

      // Validate the layout
      this.layout.validate(context);
      this.setContentSize(this.layout.getContentSize());

      // Trigger the afterLayout hook, if provided
      if (typeof context.afterLayout === 'function') {
        context.afterLayout();
      }

      // Adjust scroll position based on scroll anchor, and constrain.
      // If the content changed, scroll to the top.
      var visibleRect = this.getVisibleRect();
      var restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);
      var contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
      var contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
      contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
      contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));

      if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
        // If this is an animated relayout, we do not immediately scroll because it would be jittery.
        // Save the difference between the current and new content offsets, and apply it to the
        // individual content items instead. At the end of the animation, we'll reset and set the
        // scroll offset for real. This ensures jitter-free animation since we don't need to sync
        // the scroll animation and the content animation.
        if (context.animated || !this._animatedContentOffset.isOrigin()) {
          this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
          this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
          this.updateSubviews(context.contentChanged);
        } else {
          this.setContentOffset(new _Point2.default(contentOffsetX, contentOffsetY), context.contentChanged);
        }
      } else {
        this.updateSubviews(context.contentChanged);
      }

      // Apply layout infos, unless this is coming from an animated transaction
      if (!(context.transaction && context.animated)) {
        this._applyLayoutInfos();
      }

      // Wait for animations, and apply the afterAnimation hook, if provided
      if (context.animated) {
        var done = function done() {
          _this5._disableTransitions();

          // Reset scroll position after animations (see above comment).
          if (!_this5._animatedContentOffset.isOrigin()) {
            // Get the content offset to scroll to, taking _animatedContentOffset into account.
            var _getVisibleRect = _this5.getVisibleRect(),
                x = _getVisibleRect.x,
                y = _getVisibleRect.y;

            _this5._resetAnimatedContentOffset();
            _this5.setContentOffset(new _Point2.default(x, y));
          } else {
            // Make sure items are rendered in correct DOM order for accessibility
            _this5.correctItemOrder();
          }

          if (typeof context.afterAnimation === 'function') {
            context.afterAnimation();
          }
        };

        setTimeout(done, this.transitionDuration);
        return;
      } else if (typeof context.afterAnimation === 'function') {
        context.afterAnimation();
      }

      // Make sure items are rendered in correct DOM order for accessibility
      this.correctItemOrder();
    }

    /**
     * Corrects DOM order of visible views to match item order of collection
     */

  }, {
    key: 'correctItemOrder',
    value: function correctItemOrder() {
      if (this._scrolling) {
        return;
      }

      var current = Array.from(this.inner.children);
      var sortedVisibleViews = current.slice().sort(_utils.compareView);

      // no need to reparent if visibleViews order matches sortedVisibleViews order
      if (sortedVisibleViews.every(function (view, index) {
        return view === current[index];
      })) {
        return;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sortedVisibleViews[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var view = _step2.value;

          this.inner.removeChild(view);
          this.inner.addChild(view);
        }

        // Flush updates if not in a transaction, otherwise that will happen at the end.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (!this._transaction) {
        this.inner.flushUpdates();
      }
    }
  }, {
    key: '_enableTransitions',
    value: function _enableTransitions() {
      var transition = 'none ' + this.transitionDuration + 'ms';
      this.inner.css({
        WebkitTransition: transition,
        transition: transition
      });
    }
  }, {
    key: '_disableTransitions',
    value: function _disableTransitions() {
      this.inner.css({
        WebkitTransition: '',
        transition: ''
      });
    }
  }, {
    key: '_getScrollAnchor',
    value: function _getScrollAnchor() {
      if (!this.anchorScrollPosition) {
        return null;
      }

      var visibleRect = this.getVisibleRect();

      // Ask the delegate to provide a scroll anchor, if possible
      if (this.delegate.getScrollAnchor) {
        var indexPath = this.delegate.getScrollAnchor(visibleRect);
        if (indexPath) {
          var layoutInfo = this.layout.getLayoutInfo('item', indexPath.section, indexPath.index);
          var corner = layoutInfo.rect.getCornerInRect(visibleRect);
          if (corner) {
            var key = this._content.getKey(layoutInfo.type, layoutInfo.section, layoutInfo.index);
            var offset = layoutInfo.rect[corner].y - visibleRect.y;
            return { key: key, layoutInfo: layoutInfo, corner: corner, offset: offset };
          }
        }
      }

      // No need to anchor the scroll position if it is at the top
      if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {
        return null;
      }

      // Find a view with a visible corner that has the smallest distance to the top of the collection view
      var cornerAnchor = null;

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._visibleViews[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              _key = _step3$value[0],
              view = _step3$value[1];

          var _layoutInfo = view.layoutInfo;
          if (_layoutInfo && _layoutInfo.rect.area > 0) {
            var _corner = _layoutInfo.rect.getCornerInRect(visibleRect);

            if (_corner) {
              var _offset = _layoutInfo.rect[_corner].y - visibleRect.y;
              if (!cornerAnchor || _offset < cornerAnchor.offset) {
                cornerAnchor = { key: _key, layoutInfo: _layoutInfo, corner: _corner, offset: _offset };
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return cornerAnchor;
    }
  }, {
    key: '_restoreScrollAnchor',
    value: function _restoreScrollAnchor(scrollAnchor, context) {
      var contentOffset = this.getVisibleRect();

      if (scrollAnchor) {
        var finalAnchor = context.transaction ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.type, scrollAnchor.layoutInfo.section, scrollAnchor.layoutInfo.index);

        if (finalAnchor) {
          var adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
          contentOffset.y += adjustment;
        }
      }

      return contentOffset;
    }
  }, {
    key: 'getVisibleRect',
    value: function getVisibleRect() {
      var contentOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contentOffset;
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;

      var x = contentOffset.x - this._animatedContentOffset.x;
      var y = contentOffset.y - this._animatedContentOffset.y;
      return new _Rect2.default(x, y, size.width, size.height);
    }
  }, {
    key: 'getVisibleLayoutInfos',
    value: function getVisibleLayoutInfos() {
      return this._getLayoutInfoMap(this.getVisibleRect());
    }
  }, {
    key: '_getLayoutInfoMap',
    value: function _getLayoutInfoMap(rect) {
      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);
      var map = new Map();

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = layoutInfos[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var layoutInfo = _step4.value;

          if (copy) {
            layoutInfo = layoutInfo.copy();
          }

          var key = this._content.getKey(layoutInfo.type, layoutInfo.section, layoutInfo.index);
          map.set(key, layoutInfo);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return map;
    }
  }, {
    key: 'updateSubviews',
    value: function updateSubviews() {
      var _this6 = this;

      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this._content) {
        return;
      }

      var visibleLayoutInfos = this.getVisibleLayoutInfos();
      var currentlyVisible = this._visibleViews;
      var toAdd = void 0,
          toRemove = void 0;

      // If this is a force update, remove and re-add all views.
      // Otherwise, find and update the diff.
      if (forceUpdate) {
        toAdd = visibleLayoutInfos;
        toRemove = currentlyVisible;
      } else {

        // We are done if the sets are equal
        var _difference = (0, _utils.difference)(currentlyVisible, visibleLayoutInfos);

        toAdd = _difference.toAdd;
        toRemove = _difference.toRemove;
        if (toAdd.size === 0 && toRemove.size === 0) {
          if (this._transaction) {
            this._applyLayoutInfos(visibleLayoutInfos);
          }

          return;
        }
      }

      // Track views that should be removed. They are not removed from
      // the DOM immediately, since we may reuse and need to re-insert
      // them back into the DOM anyway.
      var removed = new Set();

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = toRemove.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var key = _step5.value;

          var view = this._visibleViews.get(key);
          if (view) {
            removed.add(view);
            this._visibleViews.delete(key);

            // If we are in the middle of a transaction, wait until the end
            // of the animations to remove the views from the DOM. Also means
            // we can't reuse those views immediately.
            if (this._transaction) {
              this._transaction.toRemove.set(key, view);
            } else {
              this.reuseView(view);
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var needsSizeUpdate = false;

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = toAdd.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _key2 = _step6.value;

          var layoutInfo = visibleLayoutInfos.get(_key2);
          var _view = null;

          // We need to recompute view sizes if we only
          // have an estimated size for this row.
          if (layoutInfo.estimatedSize) {
            needsSizeUpdate = true;
          }

          // If we're in a transaction, and a layout change happens
          // during the animations such that a view that was going
          // to be removed is now not, we don't create a new view
          // since the old one is still in the DOM, marked as toRemove.
          if (this._transaction) {
            // if transaction, get initial layout attributes for the animation
            if (this._transaction.initialLayoutInfo.has(_key2)) {
              layoutInfo = this._transaction.initialLayoutInfo.get(_key2);
            }

            if (this._transaction.toRemove.has(_key2)) {
              _view = this._transaction.toRemove.get(_key2);
              this._transaction.toRemove.delete(_key2);
              this._applyLayoutInfo(_view, layoutInfo);
            }
          }

          if (!_view) {
            // Create or reuse a view for this row
            _view = this.getReusableView(layoutInfo);

            // Add the view to the DOM if needed
            if (!removed.has(_view)) {
              this.inner.addChild(_view);
            }
          }

          this._visibleViews.set(_key2, _view);
          removed.delete(_view);
        }

        // Remove the remaining rows to delete from the DOM
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      if (!this._transaction) {
        this.removeViews(removed);
      }

      this.inner.flushUpdates(function () {
        // If we're in a transaction, apply animations to visible views
        // and "to be removed" views, which animate off screen.
        if (_this6._transaction) {
          _this6._applyLayoutInfos();
        }

        // If we need a height update, wait until the next frame
        // so that the browser has time to do layout.
        if (needsSizeUpdate) {
          _this6.relayout();
        }
      });
    }
  }, {
    key: '_applyLayoutInfo',
    value: function _applyLayoutInfo(view, layoutInfo) {
      if (!this._animatedContentOffset.isOrigin()) {
        layoutInfo = layoutInfo.copy();
        layoutInfo.rect.x += this._animatedContentOffset.x;
        layoutInfo.rect.y += this._animatedContentOffset.y;
      }

      view.applyLayoutInfo(layoutInfo);
    }
  }, {
    key: '_applyLayoutInfos',
    value: function _applyLayoutInfos() {
      // Apply layout infos to visible views
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this._visibleViews[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _step7$value = _slicedToArray(_step7.value, 2),
              key = _step7$value[0],
              _view3 = _step7$value[1];

          if (this._transaction && this._transaction.initialLayoutInfo.has(key)) {
            _view3.forceStyleUpdate();
          }

          var _cur2 = _view3.layoutInfo;
          var _layoutInfo3 = this.layout.getLayoutInfo(_cur2.type, _cur2.section, _cur2.index);
          this._applyLayoutInfo(_view3, _layoutInfo3);
        }

        // Apply final layout infos for views that will be removed
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      if (this._transaction) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = this._transaction.toRemove.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var view = _step8.value;

            var cur = view.layoutInfo;
            var layoutInfo = this.layout.getLayoutInfo(cur.type, cur.section, cur.index);
            this._applyLayoutInfo(view, layoutInfo);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = this._transaction.removed.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var _view2 = _step9.value;

            var _cur = _view2.layoutInfo;
            var _layoutInfo2 = this.layout.getFinalLayoutInfo(_cur.type, _cur.section, _cur.index);
            this._applyLayoutInfo(_view2, _layoutInfo2);
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }
    }
  }, {
    key: 'reuseView',
    value: function reuseView(view) {
      view.prepareForReuse();
      this._reusableViews[view.viewType].push(view);
    }
  }, {
    key: 'removeViews',
    value: function removeViews(toRemove) {
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = toRemove[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var view = _step10.value;

          this.inner.removeChild(view);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  }, {
    key: 'updateItemSize',
    value: function updateItemSize(indexPath) {
      // TODO: we should be able to invalidate a single index path
      if (!this.layout.updateItemSize) {
        return;
      }

      // If the scroll position is currently animating, add the update
      // to a queue to be processed after the animation is complete.
      if (this._scrollAnimation) {
        this._sizeUpdateQueue.addIndexPath(indexPath);
        return;
      }

      var changed = this.layout.updateItemSize(indexPath);
      if (changed) {
        this.relayout();
      }
    }
  }, {
    key: 'setContentOffset',
    value: function setContentOffset(contentOffset) {
      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var visibleRect = this.getVisibleRect(contentOffset);
      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(visibleRect);

      this._resetAnimatedContentOffset();
      var ret = _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'setContentOffset', this).call(this, contentOffset);

      if (shouldInvalidate) {
        this.relayout({
          offsetChanged: true
        });
      } else {
        this.updateSubviews(forceUpdate);
        this.correctItemOrder();
      }
      return ret;
    }
  }, {
    key: 'scrollEnded',
    value: function scrollEnded() {
      _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'scrollEnded', this).call(this);
      this.correctItemOrder();
    }
  }, {
    key: '_resetAnimatedContentOffset',
    value: function _resetAnimatedContentOffset() {
      // Reset the animated content offset of subviews. See comment in relayoutNow for details.
      if (!this._animatedContentOffset.isOrigin()) {
        this._animatedContentOffset = new _Point2.default(0, 0);
        this._applyLayoutInfos();
      }
    }

    /**
     * Scrolls the item at the given IndexPath into view, optionally with an animation.
     * @param {IndexPath} indexPath - The IndexPath to scroll into view
     * @param {number} [duration=300ms] - The duration of the scroll animation
     */

  }, {
    key: 'scrollToItem',
    value: function scrollToItem(indexPath) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      if (!indexPath) {
        return;
      }

      var layoutInfo = this.layout.getLayoutInfo('item', indexPath.section, indexPath.index);
      if (!layoutInfo) {
        return;
      }

      var offsetX = layoutInfo.rect.x;
      var offsetY = layoutInfo.rect.y;
      var x = this._contentOffset.x;
      var y = this._contentOffset.y;
      var maxX = x + this.size.width;
      var maxY = y + this.size.height;

      if (offsetX <= x) {
        x = offsetX;
      } else if (offsetX + layoutInfo.rect.width > maxX) {
        x += offsetX + layoutInfo.rect.width - maxX;
      }
      if (offsetY <= y) {
        y = offsetY;
      } else if (offsetY + layoutInfo.rect.height > maxY) {
        y += offsetY + layoutInfo.rect.height - maxY;
      }

      return this.scrollTo(new _Point2.default(x, y), duration);
    }

    /**
     * Performs an animated scroll to the given offset.
     * @param {Point} offset - The offset to scroll to
     * @param {number} [duration=300ms] - The duration of the animation
     * @return {Promise} a promise that resolves when the animation is complete
     */

  }, {
    key: 'scrollTo',
    value: function scrollTo(offset) {
      var _this7 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      // Cancel the current scroll animation
      if (this._scrollAnimation) {
        this._scrollAnimation.cancel();
        this._scrollAnimation = null;
      }

      // Set the content offset synchronously if the duration is zero
      if (duration <= 0 || this.contentOffset.equals(offset)) {
        this.setContentOffset(offset);
        return Promise.resolve();
      }

      this._scrollAnimation = (0, _tween2.default)(this._contentOffset, offset, duration, _tween2.default.easeOut, function (offset) {
        _this7.setContentOffset(offset);
      });
      this._scrollAnimation.then(function () {
        _this7._scrollAnimation = null;

        // Process view size updates that occurred during the animation.
        // Only views that are still visible will be actually updated.
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = _this7._sizeUpdateQueue[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var indexPath = _step11.value;

            _this7.updateItemSize(indexPath);
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        _this7._sizeUpdateQueue.clear();
        _this7.relayout();
        _this7._processTransactionQueue();
      });

      return this._scrollAnimation;
    }
  }, {
    key: 'convertPoint',
    value: function convertPoint(point) {
      var rect = this.getRect();
      return new _Point2.default(this.contentOffset.x + point.x - rect.x, this.contentOffset.y + point.y - rect.y);
    }
  }, {
    key: '_insertItem',
    value: function _insertItem(indexPath, animated) {
      var item = this.dataSource.getItem(indexPath.section, indexPath.index);
      this._runTransaction(this._performInsertItem.bind(this, item, indexPath.copy()), animated);
    }
  }, {
    key: '_performInsertItem',
    value: function _performInsertItem(item, indexPath) {
      this._content.insertItem(item, indexPath);
      this.layout.itemInserted(indexPath);
    }
  }, {
    key: '_removeItem',
    value: function _removeItem(indexPath, animated) {
      this._runTransaction(this._performRemoveItem.bind(this, indexPath.copy()), animated);
    }
  }, {
    key: '_performRemoveItem',
    value: function _performRemoveItem(indexPath) {
      this._content.removeItem(indexPath);
      this.layout.itemRemoved(indexPath);
    }
  }, {
    key: '_moveItem',
    value: function _moveItem(from, to, animated) {
      this._runTransaction(this._performMoveItem.bind(this, from.copy(), to.copy()), animated);
    }
  }, {
    key: '_performMoveItem',
    value: function _performMoveItem(from, to) {
      this._content.moveItem(from, to);
      this.layout.itemMoved(from, to);
    }
  }, {
    key: '_reloadItem',
    value: function _reloadItem(indexPath) {
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var item = this.dataSource.getItem(indexPath.section, indexPath.index);
      this._runTransaction(this._performReloadItem.bind(this, indexPath.copy(), item, animated), animated);
    }
  }, {
    key: '_performReloadItem',
    value: function _performReloadItem(indexPath, item, animated) {
      // We can reuse the same view (and just reload it's content) if
      // the reload is not animated, and the view type remains the same.
      var retainID = !animated;
      if (retainID) {
        retainID = this._reloadItemViewContent(indexPath, item);
      }

      this._content.replaceItem(indexPath, item, retainID);
      this.layout.itemReplaced(indexPath);
    }
  }, {
    key: '_reloadItemViewContent',
    value: function _reloadItemViewContent(indexPath, item) {
      var view = this.getItemView(indexPath);
      if (!view) {
        return false;
      }

      // Check that the view type remains the same after the content update.

      var _getReuseType3 = this._getReuseType(view.layoutInfo, item),
          reuseType = _getReuseType3.reuseType;

      if (view.viewType !== reuseType) {
        return false;
      }

      view.setContent(item);
      return true;
    }
  }, {
    key: '_insertSection',
    value: function _insertSection(section, animated) {
      var items = [];
      var count = this.dataSource.getSectionLength(section);
      for (var i = 0; i < count; i++) {
        items.push(this.dataSource.getItem(section, i));
      }

      this._runTransaction(this._performInsertSection.bind(this, section, items), animated);
    }
  }, {
    key: '_performInsertSection',
    value: function _performInsertSection(section, items) {
      this._content.insertSection(section, items);
      this.layout.sectionInserted(section);
    }
  }, {
    key: '_removeSection',
    value: function _removeSection(section, animated) {
      this._runTransaction(this._performRemoveSection.bind(this, section), animated);
    }
  }, {
    key: '_performRemoveSection',
    value: function _performRemoveSection(section) {
      this._content.removeSection(section);
      this.layout.sectionRemoved(section);
    }
  }, {
    key: '_moveSection',
    value: function _moveSection(fromSection, toSection, animated) {
      if (fromSection !== toSection) {
        this._runTransaction(this._performMoveSection.bind(this, fromSection, toSection), animated);
      }
    }
  }, {
    key: '_performMoveSection',
    value: function _performMoveSection(fromSection, toSection) {
      this._content.moveSection(fromSection, toSection);
      this.layout.sectionMoved(fromSection, toSection);
    }
  }, {
    key: '_reloadSection',
    value: function _reloadSection(section, animated) {
      var items = [];
      var count = this.dataSource.getSectionLength(section);
      for (var i = 0; i < count; i++) {
        items.push(this.dataSource.getItem(section, i));
      }

      this._runTransaction(this._performReloadSection.bind(this, section, items), animated);
    }
  }, {
    key: '_performReloadSection',
    value: function _performReloadSection(section, items) {
      this._content.replaceSection(section, items);
      this.layout.sectionReplaced(section);
    }
  }, {
    key: '_runTransaction',
    value: function _runTransaction(action, animated) {
      this._startTransaction();
      this._nextTransaction.actions.push(action);
      this._endTransaction(animated);
    }
  }, {
    key: '_startTransaction',
    value: function _startTransaction() {
      if (!this._nextTransaction) {
        this._nextTransaction = new _Transaction2.default();
      }

      this._nextTransaction.level++;
    }
  }, {
    key: '_endTransaction',
    value: function _endTransaction(animated) {
      if (!this._nextTransaction) {
        return false;
      }

      // Save whether the transaction should be animated.
      if (animated != null) {
        this._nextTransaction.animated = animated;
      }

      // If we haven't reached level 0, we are still in a
      // nested transaction. Wait for the parent to end.
      if (--this._nextTransaction.level > 0) {
        return false;
      }

      // Do nothing for empty transactions
      if (this._nextTransaction.actions.length === 0) {
        this._nextTransaction = null;
        return false;
      }

      // Default animations to true
      if (this._nextTransaction.animated == null) {
        this._nextTransaction.animated = true;
      }

      // Enqueue the transaction
      this._transactionQueue.push(this._nextTransaction);
      this._nextTransaction = null;

      this._processTransactionQueue();
      return true;
    }
  }, {
    key: '_processTransactionQueue',
    value: function _processTransactionQueue() {
      // If the current transaction is animating, wait until the end
      // to process the next transaction.
      if (this._transaction || this._scrollAnimation) {
        return;
      }

      var next = this._transactionQueue.shift();
      if (next) {
        this._performTransaction(next);
      }
    }
  }, {
    key: '_getContentRect',
    value: function _getContentRect() {
      return new _Rect2.default(0, 0, this.contentSize.width, this.contentSize.height);
    }
  }, {
    key: '_performTransaction',
    value: function _performTransaction(transaction) {
      var _this8 = this;

      this._transaction = transaction;

      this.relayoutNow({
        transaction: transaction,
        animated: transaction.animated,

        beforeLayout: function beforeLayout() {
          // Get the initial layout infos for all views before the updates
          // so we can figure out which views to add and remove.
          transaction.initialMap = _this8._getLayoutInfoMap(_this8._getContentRect(), true);

          // Apply the actions that occurred during this transaction
          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = transaction.actions[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var action = _step12.value;

              action();
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        },

        afterLayout: function afterLayout() {
          // Get the final layout infos after the updates
          transaction.finalMap = _this8._getLayoutInfoMap(_this8._getContentRect());
          _this8._setupTransactionAnimations(transaction);

          if (!transaction.animated) {
            _this8._transaction = null;
          }
        },

        afterAnimation: function afterAnimation() {
          // Remove and reuse views when animations are done
          if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = (0, _utils.concatIterators)(transaction.toRemove.values(), transaction.removed.values())[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var view = _step13.value;

                _this8.inner.removeChild(view);
                _this8.reuseView(view);
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13.return) {
                  _iterator13.return();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }

            _this8.inner.flushUpdates();
          }

          _this8._transaction = null;
          _this8._processTransactionQueue();
        }
      });
    }
  }, {
    key: '_setupTransactionAnimations',
    value: function _setupTransactionAnimations(transaction) {
      var initialMap = transaction.initialMap,
          finalMap = transaction.finalMap;

      // Store initial and final layout infos for animations

      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = initialMap[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var _step14$value = _slicedToArray(_step14.value, 2),
              key = _step14$value[0],
              layoutInfo = _step14$value[1];

          if (finalMap.has(key)) {
            // Remap section and index to final position
            var finalLayoutInfo = finalMap.get(key);
            layoutInfo.section = finalLayoutInfo.section;
            layoutInfo.index = finalLayoutInfo.index;

            // Store the initial layout info for use during animations.
            transaction.initialLayoutInfo.set(key, layoutInfo);
          } else {
            // This view was removed. Store the layout info for use
            // in Layout#getFinalLayoutInfo during animations.
            var k = [layoutInfo.type, layoutInfo.section, layoutInfo.index].join(':');
            transaction.finalLayoutInfo.set(k, layoutInfo);
          }
        }

        // Get initial layout infos for views that were added
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = finalMap[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var _step15$value = _slicedToArray(_step15.value, 2),
              key = _step15$value[0],
              layoutInfo = _step15$value[1];

          if (!initialMap.has(key)) {
            var initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.type, layoutInfo.section, layoutInfo.index);
            transaction.initialLayoutInfo.set(key, initialLayoutInfo);
          }
        }

        // Figure out which views were removed.
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15.return) {
            _iterator15.return();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = this._visibleViews[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var _step16$value = _slicedToArray(_step16.value, 2),
              key = _step16$value[0],
              view = _step16$value[1];

          if (finalMap.has(key)) {
            // Remap section and index to final position
            var _finalLayoutInfo = finalMap.get(key);
            view.layoutInfo.section = _finalLayoutInfo.section;
            view.layoutInfo.index = _finalLayoutInfo.index;
          } else {
            transaction.removed.set(key, view);
            this._visibleViews.delete(key);

            // In case something weird happened, where we have a view but no
            // initial layout info, use the one attached to the view.
            var _k = [view.layoutInfo.type, view.layoutInfo.section, view.layoutInfo.index].join(':');
            if (!transaction.finalLayoutInfo.has(_k)) {
              transaction.finalLayoutInfo.set(_k, view.layoutInfo);
            }
          }
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16.return) {
            _iterator16.return();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }
    }
  }, {
    key: 'dataSource',
    get: function get() {
      return this._dataSource;
    }

    /**
     * Set the collection view's data source
     * @type {DataSource}
     */
    ,
    set: function set(dataSource) {
      this._setDataSource(dataSource);
    }
  }, {
    key: 'layout',
    get: function get() {
      return this._layout;
    }

    /**
     * Set the collection view's layout
     * @type {Layout}
     */
    ,
    set: function set(layout) {
      this.setLayout(layout);
    }
  }, {
    key: 'visibleViews',
    get: function get() {
      return Array.from(this._visibleViews.values());
    }
  }]);

  return CollectionView;
}(_ScrollView3.default);

exports.default = CollectionView;