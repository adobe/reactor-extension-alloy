'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _IndexPath = require('./IndexPath');

var _IndexPath2 = _interopRequireDefault(_IndexPath);

var _IndexPathSet = require('./IndexPathSet');

var _IndexPathSet2 = _interopRequireDefault(_IndexPathSet);

var _IndexSet = require('./IndexSet');

var _IndexSet2 = _interopRequireDefault(_IndexSet);

var _Range = require('./Range');

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * {@link CollectionView} supports arbitrary data sources, which provide data to be rendered,
 * and respond to user-initiated actions from {@link EditableCollectionView}.
 * Data provided by a data source is two dimensional: items are grouped into sections.
 * This can be useful, for example, if you want to display headers above a group of items.
 *
 * There is one built-in data source, {@link ArrayDataSource}, which simply renders a two-dimensional
 * array of data provided to its constructor. If you need custom behavior, you can either
 * extend {@link ArrayDataSource} or implement your own data source from scratch.
 *
 * All data sources must extend the {@link DataSource} abstract base class. Data sources must
 * implement a minimum of three methods to provide data to a collection view:
 *
 * - {@link getNumberOfSections}
 * - {@link getSectionLength}
 * - {@link getItem}
 *
 * When data in the data source changes, perhaps in response to some external event such as a
 * server update, the data source should emit events. The collection view listens for these
 * events and updates its views as necessary. All of the events have an optional `animated`
 * argument specifying whether the collection view should animate the change or apply it
 * immediately (`true` if omitted).
 *
 * - `'insertSection', section, animated` - emitted when a section is inserted, with a section index.
 * - `'insertItem', indexPath, animated` - emitted when an item is inserted, with an {@link IndexPath}.
 * - `'removeSection, section, animated` - emitted when a section is removed, with a section index.
 * - `'removeItem', indexPath, animated` - emitted when an item is removed, with an {@link IndexPath}.
 * - `'moveSection', from, to, animated` - emitted when a section is moved, with a source section
     index, and destination section index.
 * - `'moveItem', from, to, animated` - emitted when an item is moved, with a source {@link IndexPath},
     and destination {@link IndexPath}.
 * - `'reloadItem', indexPath, animated` - emitted when an item was updated, with an {@link IndexPath}.
 *
 * Additionally, changes can be grouped into transactions, such that all changes that occur within the
 * transaction are batched together and applied at once. If animated, the animations occur all at once
 * rather than in sequence. Transactions are started and ended by two events:
 *
 * - `'startTransaction'` - Starts a transaction. All changes until `endTransaction` is emitted
 *   are batched together and applied at once.
 * - `'endTransaction', animated` - Ends a transaction. All changes since the last `startTransaction` event
 *   are applied together.
 *
 * Optionally, data sources can support editing. {@link EditableCollectionView} will call
 * methods on its data source in response to user events. The data source should update its internal
 * state and perform any actions it needs to save the underlying data (such as sending events to a server).
 * It should also emit the above events as necessary to keep collection view in sync.
 *
 * @extends {EventEmitter}
 */
var DataSource = function (_EventEmitter) {
  _inherits(DataSource, _EventEmitter);

  function DataSource() {
    _classCallCheck(this, DataSource);

    return _possibleConstructorReturn(this, (DataSource.__proto__ || Object.getPrototypeOf(DataSource)).apply(this, arguments));
  }

  _createClass(DataSource, [{
    key: 'getNumberOfSections',

    /**
     * Returns the number of sections in the collection
     * @abstract
     * @return {number}
     */
    value: function getNumberOfSections() {
      return 0;
    }

    /**
     * Returns the number of items in a particular section
     * @abstract
     * @param {number} section
     * @return {number}
     */

  }, {
    key: 'getSectionLength',
    value: function getSectionLength(section) {
      return 0;
    }

    /**
     * Returns an item at a given section and index
     * @abstract
     * @param {number} section
     * @param {number} index
     */

  }, {
    key: 'getItem',
    value: function getItem(section, index) {
      return null;
    }

    /**
     * Starts a transaction. All changes until `endTransaction` is called
     * are batched together and applied at once.
     * @abstract
     */

  }, {
    key: 'startTransaction',
    value: function startTransaction() {}

    /**
     * Ends a transaction. All changes since the last `startTransaction` call
     * are applied together.
     * @abstract
     * @param {boolean} [animated=true] whether the changes should be animated
     */

  }, {
    key: 'endTransaction',
    value: function endTransaction(animated) {}

    /**
     * Inserts an item into the collection at a given IndexPath
     * @abstract
     * @param {IndexPath} indexPath the IndexPath at which to insert
     * @param {*} item the item to insert
     * @param {boolean} [animated=true] whether the insert should be animated
     */

  }, {
    key: 'insertItem',
    value: function insertItem(indexPath, item, animated) {}

    /**
     * Inserts multiple items into the collection at once.
     * The default implementation calls `insertItem` for
     * each item to insert within a transaction.
     * @param {IndexPath} indexPath the IndexPath at which to insert
     * @param {Array} items an array of items to insert
     * @param {boolean} [animated=true] whether the insert should be animated
     */

  }, {
    key: 'insertItems',
    value: function insertItems(indexPath, items, animated) {
      this.startTransaction();

      indexPath = indexPath.copy();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          this.insertItem(indexPath, item);
          indexPath.index++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.endTransaction(animated);
    }

    /**
     * Inserts a section with the given items
     * @abstract
     * @param {number} section the section index at which to insert
     * @param {Array} items an array of items to insert in the section
     * @param {boolean} [animated=true] whether the insert should be animated
     */

  }, {
    key: 'insertSection',
    value: function insertSection(section, items, animated) {}

    /**
     * Inserts multiple sections into the collection at once.
     * @param {number} sectionIndex the section index at which to insert
     * @param {Array<Array>} sections an array of sections to insert
     * @param {boolean} [animated=true] whether the insert should be animated
     */

  }, {
    key: 'insertSections',
    value: function insertSections(sectionIndex, sections, animated) {
      this.startTransaction();

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sections[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var section = _step2.value;

          this.insertSection(sectionIndex++, section);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.endTransaction(animated);
    }

    /**
     * Removes the item at the given IndexPath
     * @abstract
     * @param {IndexPath} indexPath the IndexPath to remove
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'removeItem',
    value: function removeItem(indexPath, animated) {}

    /**
     * Removes multiple items at once
     * @param {IndexPathSet} indexPathSet an IndexPathSet to remove
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'removeItems',
    value: function removeItems(indexPathSet, animated) {
      this.startTransaction();

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = indexPathSet.reverseIterator[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var indexPath = _step3.value;

          this.removeItem(indexPath);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.endTransaction(animated);
    }

    /**
     * Removes all items in the given section at once.
     * @param {number} section the section to clear
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'clearSection',
    value: function clearSection(section, animated) {
      var count = this.getSectionLength(section);
      if (count === 0) {
        return;
      }

      var indexPathSet = new _IndexPathSet2.default();
      indexPathSet.addRangeInSection(section, new _Range2.default(0, count - 1));
      this.removeItems(indexPathSet, animated);
    }

    /**
     * Removes a section from the collection
     * @abstract
     * @param {number} section the section to remove
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'removeSection',
    value: function removeSection(section, animated) {}

    /**
     * Removes multiple sections at once
     * @param {IndexSet} indexSet the IndexSet to remove
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'removeSections',
    value: function removeSections(indexSet, animated) {
      this.startTransaction();

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = indexSet.reverseIterator[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var index = _step4.value;

          this.removeSection(index);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.endTransaction(animated);
    }

    /**
     * Removes all sections from the collection at once.
     * @param {boolean} [animated=true] whether the remove should be animated
     */

  }, {
    key: 'clear',
    value: function clear(animated) {
      var count = this.getNumberOfSections();
      if (count === 0) {
        return;
      }

      var indexSet = new _IndexSet2.default();
      indexSet.addRange(new _Range2.default(0, count - 1));
      this.removeSections(indexSet, animated);
    }

    /**
     * Moves an item from one IndexPath to another
     * @abstract
     * @param {IndexPath} from the source IndexPath
     * @param {IndexPath} to the destination IndexPath
     * @param {boolean} [animated=true] whether the move should be animated
     */

  }, {
    key: 'moveItem',
    value: function moveItem(from, to, animated) {}

    /**
     * Moves a section
     * @abstract
     * @param {number} fromSection the source section index
     * @param {number} toSection the destination section index
     * @param {boolean} [animated=true] whether the move should be animated
     */

  }, {
    key: 'moveSection',
    value: function moveSection(fromSection, toSection, animated) {}

    /**
     * Moves all items in the given IndexPathSet to the given IndexPath
     * such that the first item in the IndexPathSet is at the IndexPath
     * and all others follow in the same order as in the IndexPathSet.
     * @param {IndexPathSet} indexPathSet the IndexPathSet to move
     * @param {IndexPath} toIndexPath the destination IndexPath
     * @param {boolean} [animated=true] whether the move should be animated
     */

  }, {
    key: 'moveItems',
    value: function moveItems(indexPathSet, toIndexPath, animated) {
      this.startTransaction();

      // Make copies so we don't modify the input objects
      toIndexPath = toIndexPath.copy();

      // Shift the target down by the number of items being moved from before the target
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = indexPathSet[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var indexPath = _step5.value;

          if (indexPath.section === toIndexPath.section && indexPath.index < toIndexPath.index) {
            toIndexPath.index--;
          }
        }

        // Compute the initial and final positions for all of the items to move
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var moves = [];
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = indexPathSet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _indexPath = _step6.value;

          moves.push({
            from: _indexPath,
            to: toIndexPath.copy()
          });

          toIndexPath.index++;
        }

        // Shift later from indices down if they have a larger index in the same section
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      for (var i = 0; i < moves.length; i++) {
        var a = moves[i].from;
        for (var j = i; j < moves.length; j++) {
          var b = moves[j].from;

          if (b.section === a.section && b.index > a.index) {
            b.index--;
          }
        }
      }

      // Interleave the moves so they can be applied one by one rather than all at once
      for (var _i = 0; _i < moves.length; _i++) {
        var _a = moves[_i];
        for (var _j = moves.length - 1; _j > _i; _j--) {
          var _b = moves[_j];

          if (_b.from.section === _a.to.section) {
            if (_b.from.index < _a.to.index) {
              _a.to.index++;
            } else {
              _b.from.index++;
            }
          }
        }
      }

      // Finally, perform the moves
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = moves[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var move = _step7.value;

          this.moveItem(move.from, move.to);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      this.endTransaction(animated);
    }

    /**
     * Moves the item in the given IndexPathSet to a new section
     * such that the first item in the IndexPathSet is first in the new section
     * and all others follow in the same order as in the IndexPathSet.
     * @param {IndexPathSet} indexPathSet the IndexPathSet to move
     * @param {number} toSection the destination section to create
     * @param {boolean} [animated=true] whether the move should be animated
     */

  }, {
    key: 'moveItemsToNewSection',
    value: function moveItemsToNewSection(indexPathSet, toSection, animated) {
      this.startTransaction();

      // Insert a new section
      this.insertSection(toSection, []);

      // Adjust the index paths to move, and move them to the new section
      indexPathSet.adjustForInsertedSection(toSection);
      this.moveItems(indexPathSet, new _IndexPath2.default(toSection, 0));

      this.endTransaction(animated);
    }

    /**
     * Replaces the item at an IndexPath with a different item
     * @abstract
     * @param {IndexPath} indexPath the IndexPath to replace
     * @param {*} item the replacement item
     * @param {boolean} [animated=true] whether the replacement should be animated
     */

  }, {
    key: 'replaceItem',
    value: function replaceItem(indexPath, item, animated) {}

    /**
     * Replaces a section with a different array of items
     * @abstract
     * @param {number} section - The section to replace
     * @param {Array} items - The replacement items
     * @param {boolean} [animated=true] whether the replacement should be animated
     */

  }, {
    key: 'replaceSection',
    value: function replaceSection(section, items, animated) {}

    /**
     * Performs a drag and drop reorder operation. By default, calls
     * `moveSection`, `moveItemsToNewSection`, or `moveItems` depending on the
     * drag and drop targets.
     * @param {DragTarget} dragTarget - the drag target
     * @param {DragTarget} dropTarget - the drop target
     * @param {DropOperation} dropOperation - the operation to perform
     * @param {IndexPathSet} indexPathSet - the IndexPathSet to reorder
     */

  }, {
    key: 'performReorder',
    value: function performReorder(dragTarget, dropTarget, dropOperation, indexPathSet) {
      if (dragTarget.type === 'section') {
        this.moveSection(dragTarget.indexPath.section, dropTarget.indexPath.section);
      } else {
        if (dropTarget.type === 'section') {
          this.moveItemsToNewSection(indexPathSet, dropTarget.indexPath.section);
        } else {
          this.moveItems(indexPathSet, dropTarget.indexPath);
        }
      }
    }

    /**
     * Performs a drop operation on the collection view. By default,
     * calls `insertSection` or `insertItems` depending on the drop target.
     * @param {DragTarget} dropTarget - the target of the drop
     * @param {DropOperation} dropOperation - the operation to perform
     * @param {Array} items - the items being dropped
     */

  }, {
    key: 'performDrop',
    value: function performDrop(dropTarget, dropOperation, items) {
      if (dropTarget.type === 'section') {
        this.insertSection(dropTarget.indexPath.section, items);
      } else {
        this.insertItems(dropTarget.indexPath, items);
      }
    }
  }]);

  return DataSource;
}(_events.EventEmitter);

exports.default = DataSource;