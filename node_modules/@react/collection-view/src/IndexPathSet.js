'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _IndexPath = require('./IndexPath');

var _IndexPath2 = _interopRequireDefault(_IndexPath);

var _IndexSet = require('./IndexSet');

var _IndexSet2 = _interopRequireDefault(_IndexSet);

var _Range = require('./Range');

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The IndexPathSet class stores a sorted set of {@link IndexPath} values.
 * It works like an {@link IndexSet}, but instead of storing integer
 * indexes, it stores {@link IndexPath} values instead.
 * Interally, it is stored as a multi-level {@link IndexSet}.
 */
var IndexPathSet = function () {
  /**
   * Creates a new IndexPathSet
   */
  function IndexPathSet() {
    _classCallCheck(this, IndexPathSet);

    this.sectionIndexes = new _IndexSet2.default();
    this.sectionIndexSets = new Map();
  }

  /**
   * Adds an IndexPath to the set
   * @param {IndexPath} indexPath an IndexPath to add
   */


  _createClass(IndexPathSet, [{
    key: 'addIndexPath',
    value: function addIndexPath(indexPath) {
      this.addRangeInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));
    }

    /**
     * Removes an IndexPath from the set
     * @param {IndexPath} indexPath an IndexPath to remove
     */

  }, {
    key: 'removeIndexPath',
    value: function removeIndexPath(indexPath) {
      this.removeRangeInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));
    }

    /**
     * Adds a range of indices in the given section to the set
     * @param {number} section the section to add to
     * @param {Range} range the range to add
     */

  }, {
    key: 'addRangeInSection',
    value: function addRangeInSection(section, range) {
      if (!this.sectionIndexSets.has(section)) {
        this.sectionIndexSets.set(section, new _IndexSet2.default());
        this.sectionIndexes.addIndex(section);
      }

      this.sectionIndexSets.get(section).addRange(range);
    }

    /**
     * Removes a range of indices in the given section from the set
     * @param {number} section the section to remove from
     * @param {Range} range the range to remove
     */

  }, {
    key: 'removeRangeInSection',
    value: function removeRangeInSection(section, range) {
      var indexSet = this.sectionIndexSets.get(section);

      if (indexSet) {
        indexSet.removeRange(range);
        if (indexSet.isEmpty) {
          this.removeSection(section);
        }
      }
    }

    /**
     * Removes all items in the given section
     * @param {number} section - the section to remove
     */

  }, {
    key: 'removeSection',
    value: function removeSection(section) {
      this.sectionIndexes.removeIndex(section);
      this.sectionIndexSets.delete(section);
    }

    /**
     * Returns whether the given IndexPath is in the set
     * @param {IndexPath} indexPath the IndexPath to check
     * @return {boolean}
     */

  }, {
    key: 'contains',
    value: function contains(indexPath) {
      var indexSet = this.sectionIndexSets.get(indexPath.section);

      if (!indexSet) {
        return false;
      }

      return indexSet.containsIndex(indexPath.index);
    }

    /**
     * Toggles the given IndexPath
     * @param {IndexPath} indexPath the IndexPath to toggle
     */

  }, {
    key: 'toggleIndexPath',
    value: function toggleIndexPath(indexPath) {
      if (this.contains(indexPath)) {
        this.removeIndexPath(indexPath);
      } else {
        this.addIndexPath(indexPath);
      }
    }

    /**
     * Removes all of the IndexPaths from the set
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.sectionIndexes.clear();
      this.sectionIndexSets.clear();
    }

    /**
     * Increments the IndexPaths above the range index in
     * the given section by the range length
     * @param {number} section the section to adjust
     * @param {Range} range the range to adjust by
     */

  }, {
    key: 'adjustForInsertionInSection',
    value: function adjustForInsertionInSection(section, range) {
      var indexSet = this.sectionIndexSets.get(section);
      if (!indexSet) {
        return;
      }

      indexSet.adjustForInsertedRange(range);
    }

    /**
     * Decrements the IndexPaths above the range index in
     * the given section by the range length
     * @param {number} section the section to adjust
     * @param {Range} range the range to adjust by
     */

  }, {
    key: 'adjustForDeletionInSection',
    value: function adjustForDeletionInSection(section, range) {
      var indexSet = this.sectionIndexSets.get(section);
      if (!indexSet) {
        return;
      }

      indexSet.adjustForDeletedRange(range);
      if (indexSet.isEmpty) {
        this.sectionIndexSets.delete(section);
        this.sectionIndexes.removeIndex(section);
      }
    }

    /**
     * Adjusts the IndexPaths in the set for a item move
     * @param {IndexPath} from the source index path
     * @param {IndexPath} to the destination index path
     */

  }, {
    key: 'adjustForMove',
    value: function adjustForMove(from, to) {
      var contains = this.contains(from);

      this.adjustForDeletionInSection(from.section, new _Range2.default(from.index, from.index));
      this.adjustForInsertionInSection(to.section, new _Range2.default(to.index, to.index));

      if (contains) {
        this.addIndexPath(to);
      }
    }
  }, {
    key: '_adjustSectionIndexSets',
    value: function _adjustSectionIndexSets(section, dir) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Array.from(this.sectionIndexSets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              sectionIndex = _step$value[0],
              indexSet = _step$value[1];

          if (sectionIndex >= section) {
            this.sectionIndexSets.delete(sectionIndex);
            this.sectionIndexSets.set(sectionIndex + dir, indexSet);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Adjusts the IndexPaths in the set for an insertion of a new section
     * @param {number} section the index of the inserted section
     */

  }, {
    key: 'adjustForInsertedSection',
    value: function adjustForInsertedSection(section) {
      this.sectionIndexes.adjustForInsertedRange(new _Range2.default(section, section));
      this._adjustSectionIndexSets(section, +1);
    }

    /**
     * Adjusts the IndexPaths in the set for an deletion of a section
     * @param {number} section the index of the deleted section
     */

  }, {
    key: 'adjustForDeletedSection',
    value: function adjustForDeletedSection(section) {
      this.sectionIndexes.adjustForDeletedRange(new _Range2.default(section, section));
      this.sectionIndexSets.delete(section);
      this._adjustSectionIndexSets(section, -1);
    }

    /**
     * Adjusts the IndexPaths in the set for a section move
     * @param {number} fromSection the index of the source section
     * @param {number} toSection the index of the destination section
     */

  }, {
    key: 'adjustForMovedSection',
    value: function adjustForMovedSection(fromSection, toSection) {
      this.sectionIndexes.adjustForMove(fromSection, toSection);

      var indexSet = this.sectionIndexSets.get(fromSection);
      this._adjustSectionIndexSets(fromSection, -1);
      this._adjustSectionIndexSets(toSection, +1);

      if (indexSet) {
        this.sectionIndexSets.set(toSection, indexSet);
      }
    }

    /**
     * The first IndexPath in the set, or null if the set is empty
     * @type {IndexPath}
     */

  }, {
    key: Symbol.iterator,


    /**
     * Returns an iterator over all of the IndexPaths in the set
     * @return {Generator}
     */
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, section, indexSet, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, index;

      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 3;
              _iterator2 = this.sectionIndexes[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 37;
                break;
              }

              section = _step2.value;
              indexSet = this.sectionIndexSets.get(section);
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context.prev = 11;
              _iterator3 = indexSet[Symbol.iterator]();

            case 13:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context.next = 20;
                break;
              }

              index = _step3.value;
              _context.next = 17;
              return new _IndexPath2.default(section, index);

            case 17:
              _iteratorNormalCompletion3 = true;
              _context.next = 13;
              break;

            case 20:
              _context.next = 26;
              break;

            case 22:
              _context.prev = 22;
              _context.t0 = _context['catch'](11);
              _didIteratorError3 = true;
              _iteratorError3 = _context.t0;

            case 26:
              _context.prev = 26;
              _context.prev = 27;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 29:
              _context.prev = 29;

              if (!_didIteratorError3) {
                _context.next = 32;
                break;
              }

              throw _iteratorError3;

            case 32:
              return _context.finish(29);

            case 33:
              return _context.finish(26);

            case 34:
              _iteratorNormalCompletion2 = true;
              _context.next = 5;
              break;

            case 37:
              _context.next = 43;
              break;

            case 39:
              _context.prev = 39;
              _context.t1 = _context['catch'](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t1;

            case 43:
              _context.prev = 43;
              _context.prev = 44;

              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }

            case 46:
              _context.prev = 46;

              if (!_didIteratorError2) {
                _context.next = 49;
                break;
              }

              throw _iteratorError2;

            case 49:
              return _context.finish(46);

            case 50:
              return _context.finish(43);

            case 51:
            case 'end':
              return _context.stop();
          }
        }
      }, value, this, [[3, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);
    })

    /**
     * Returns a iterator that emits all IndexPaths in the set in reverse
     * @type {Iterator}
     */

  }, {
    key: 'equals',


    /**
     * Returns whether this set is equal to another one
     * @param {IndexPathSet} other an IndexPathSet to compare
     * @return {boolean}
     */
    value: function equals(other) {
      if (!other || !(other instanceof IndexPathSet)) {
        return false;
      }

      if (other === this) {
        return true;
      }

      if (!other.sectionIndexes.equals(this.sectionIndexes)) {
        return false;
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.sectionIndexes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var section = _step4.value;

          if (!this.sectionIndexSets.get(section).equals(other.sectionIndexSets.get(section))) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return true;
    }

    /**
     * Returns a copy of this IndexPathSet
     * @return {IndexPathSet}
     */

  }, {
    key: 'copy',
    value: function copy() {
      var res = new this.constructor();
      res.sectionIndexes.addIndexSet(this.sectionIndexes);

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.sectionIndexSets[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              section = _step5$value[0],
              indexSet = _step5$value[1];

          res.sectionIndexSets.set(section, indexSet.copy());
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return res;
    }
  }, {
    key: 'firstIndexPath',
    get: function get() {
      var firstSection = this.sectionIndexes.firstIndex;
      if (firstSection === -1) {
        return null;
      }

      return new _IndexPath2.default(firstSection, this.sectionIndexSets.get(firstSection).firstIndex);
    }

    /**
     * The last IndexPath in the set, or null if the set is empty
     * @type {IndexPath}
     */

  }, {
    key: 'lastIndexPath',
    get: function get() {
      var lastSection = this.sectionIndexes.lastIndex;
      if (lastSection === -1) {
        return null;
      }

      return new _IndexPath2.default(lastSection, this.sectionIndexSets.get(lastSection).lastIndex);
    }

    /**
     * The number of IndexPaths in the set
     * @type {number}
     */

  }, {
    key: 'length',
    get: function get() {
      var length = 0;

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.sectionIndexSets.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var indexSet = _step6.value;

          length += indexSet.length;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return length;
    }

    /**
     * Whether the set is empty
     * @type {boolean}
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      return this.sectionIndexes.isEmpty;
    }
  }, {
    key: 'reverseIterator',
    get: function get() {
      var self = this;

      return _defineProperty({}, Symbol.iterator, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, section, indexSet, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, index;

        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iteratorNormalCompletion7 = true;
                _didIteratorError7 = false;
                _iteratorError7 = undefined;
                _context2.prev = 3;
                _iterator7 = self.sectionIndexes.reverseIterator[Symbol.iterator]();

              case 5:
                if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
                  _context2.next = 37;
                  break;
                }

                section = _step7.value;
                indexSet = self.sectionIndexSets.get(section);
                _iteratorNormalCompletion8 = true;
                _didIteratorError8 = false;
                _iteratorError8 = undefined;
                _context2.prev = 11;
                _iterator8 = indexSet.reverseIterator[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                  _context2.next = 20;
                  break;
                }

                index = _step8.value;
                _context2.next = 17;
                return new _IndexPath2.default(section, index);

              case 17:
                _iteratorNormalCompletion8 = true;
                _context2.next = 13;
                break;

              case 20:
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2['catch'](11);
                _didIteratorError8 = true;
                _iteratorError8 = _context2.t0;

              case 26:
                _context2.prev = 26;
                _context2.prev = 27;

                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                  _iterator8.return();
                }

              case 29:
                _context2.prev = 29;

                if (!_didIteratorError8) {
                  _context2.next = 32;
                  break;
                }

                throw _iteratorError8;

              case 32:
                return _context2.finish(29);

              case 33:
                return _context2.finish(26);

              case 34:
                _iteratorNormalCompletion7 = true;
                _context2.next = 5;
                break;

              case 37:
                _context2.next = 43;
                break;

              case 39:
                _context2.prev = 39;
                _context2.t1 = _context2['catch'](3);
                _didIteratorError7 = true;
                _iteratorError7 = _context2.t1;

              case 43:
                _context2.prev = 43;
                _context2.prev = 44;

                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }

              case 46:
                _context2.prev = 46;

                if (!_didIteratorError7) {
                  _context2.next = 49;
                  break;
                }

                throw _iteratorError7;

              case 49:
                return _context2.finish(46);

              case 50:
                return _context2.finish(43);

              case 51:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee, this, [[3, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);
      }));
    }
  }]);

  return IndexPathSet;
}();

exports.default = IndexPathSet;