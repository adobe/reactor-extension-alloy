'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _DOMBackend = require('./dom/DOMBackend');

var _DOMBackend2 = _interopRequireDefault(_DOMBackend);

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _Scroller = require('./Scroller');

var _Scroller2 = _interopRequireDefault(_Scroller);

var _Size = require('./Size');

var _Size2 = _interopRequireDefault(_Size);

var _View2 = require('./View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MIN_DRAG_DELTA = 5;
var DECELERATION_FRICTION = 0.95;
var RUBBER_BAND_FRICTION = 0.55;
var ELASTIC_DECELERATION = 0.03;
var ELASTIC_ACCELERATION = 0.08;
var HIDE_INDICATORS = 0.1;
var MIN_VELOCITY = 0.01;

var ScrollView = function (_View) {
  _inherits(ScrollView, _View);

  function ScrollView() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ScrollView);

    var _this = _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call(this));

    _this.backend = options.backend || _DOMBackend2.default;

    var _ref = options.rubberBandEffect ? options.rubberBandEffect : { horizontal: false, vertical: true },
        horizontal = _ref.horizontal,
        vertical = _ref.vertical;

    _this.horizontalRubberBand = horizontal;
    _this.verticalRubberBand = vertical;

    _this._size = new _Size2.default(0, 0);
    _this._contentSize = new _Size2.default(0, 0);
    _this._contentOffset = new _Point2.default(0, 0);
    _this._lineOffset = 10;
    _this._scrolling = false;
    _this._scrollTimeout = null;
    _this._scrollEndTime = 0;

    // Add an attribute so other things can detect that our fake scrollview is actually scrollable.
    _this.setAttribute('data-scrollable', 'true');

    _this.css({
      position: 'relative',
      overflow: 'hidden',
      touchAction: 'none'
    });

    _this.bindScrollEvents();

    _this.inner = new _View3.default();
    _this.inner.css({
      position: 'absolute',
      transform: 'translate3d(0, 0, 0)'
    });

    _this.updateAccessibilityAttributes(options);

    _this.addChild(_this.inner);

    _this._decelerationAnimation = _this._decelerationAnimation.bind(_this);

    _this.verticalScroller = new _Scroller2.default(_this);
    _this.addChild(_this.verticalScroller);
    _this.horizontalScroller = new _Scroller2.default(_this, 'horizontal');
    _this.addChild(_this.horizontalScroller);
    return _this;
  }

  _createClass(ScrollView, [{
    key: 'updateAccessibilityAttributes',
    value: function updateAccessibilityAttributes(props) {
      if (!props.role && !this.attrs.role) {
        this.setAttribute('role', 'presentation');
        if (this.inner) {
          this.inner.setAttribute('role', 'presentation');
        }
      }
      for (var key in props) {
        var value = props[key];
        switch (key) {
          case 'aria-multiselectable':
            // ignore aria-multiselectable
            break;
          case 'role':
            this.setAttribute(key, value);
            if (this.inner) {
              // set WAI-ARIA role of inner so that the scrolling content region has no role.
              this.inner.setAttribute('role', value === 'grid' ? 'rowgroup' : 'presentation');
            }
            break;
          default:
            if ((key === 'id' || /^aria-\w+/.test(key)) && value !== this.attrs[key]) {
              this.setAttribute(key, value);
            }
            break;
        }
      }
    }
  }, {
    key: 'bindScrollEvents',
    value: function bindScrollEvents() {
      this.onEvent('wheel', this.scroll.bind(this));
      this.onEvent('touchStart', this.touchStart.bind(this));
      this.onEvent('touchMove', this.touchMove.bind(this));
      this.onEvent('touchEnd', this.touchEnd.bind(this));
      this.onEvent('touchCancel', this.touchEnd.bind(this));
      this.onEvent('scroll', this._onScroll.bind(this));
    }
  }, {
    key: 'render',
    value: function render() {
      return _get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), 'renderBackendView', this).call(this, this.backend);
    }

    /**
     * Get the outer size of the scroll view
     * @type {Size}
     */

  }, {
    key: 'setSize',
    value: function setSize(size) {
      this._size = size;
      this.inner.css({
        width: size.width + 'px'
      });

      this.verticalScroller.updateScrollViewSize();
      this.horizontalScroller.updateScrollViewSize();
    }
  }, {
    key: 'setContentSize',
    value: function setContentSize(size) {
      var oldSize = this._contentSize;
      this._contentSize = size;
      this.inner.css({
        width: size.width + 'px',
        height: size.height + 'px'
      });

      this.verticalScroller.updateScrollViewSize();
      this.horizontalScroller.updateScrollViewSize();

      if (oldSize.height < this.size.height && oldSize.height > this.size.height) {
        this.verticalScroller.flash();
      }
      if (oldSize.width < this.size.width && oldSize.width > this.size.width) {
        this.horizontalScroller.flash();
      }
    }

    /**
     * Get the height of the scrollable content
     * @type {number}
     */

  }, {
    key: '_onScroll',


    /**
     * Prevent ScrollView itself from scrolling in response to focus events or screen reader
     * @type {ScrollEvent} The scroll event
     * @private
     */
    value: function _onScroll(e) {
      e.preventDefault();
      var node = this.getDOMNode();
      if (node && node.scrollTop !== 0) {
        node.scrollTop = 0;
      }
    }
  }, {
    key: 'scroll',
    value: function scroll(e) {
      var _this2 = this;

      var deltaX = e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? e.deltaX : e.deltaX * this._lineOffset; // TODO - lineOffset?
      var deltaY = e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? e.deltaY : e.deltaY * this._lineOffset;

      if (!this._scrolling) {
        this.scrollStarted(deltaX, deltaY);
      }

      if (this.setContentOffset(new _Point2.default(this._contentOffset.x + deltaX, this._contentOffset.y + deltaY))) {
        e.stopPropagation();
        e.preventDefault();
      }

      // So we don't constantly call clearTimeout and setTimeout,
      // keep track of the current timeout time and only reschedule
      // the timer when it is getting close.
      var now = Date.now();
      if (this._scrollEndTime <= now + 50) {
        this._scrollEndTime = now + 300;

        clearTimeout(this._scrollTimeout);
        this._scrollTimeout = setTimeout(function () {
          _this2.scrollEnded();
        }, 300);
      }
    }
  }, {
    key: 'scrollStarted',
    value: function scrollStarted(deltaX, deltaY) {
      this._scrolling = true;
      this.inner.css({ pointerEvents: 'none' });
      if (deltaX !== 0) {
        this.horizontalScroller.scrollStarted();
      }
      if (deltaY !== 0) {
        this.verticalScroller.scrollStarted();
      }
    }
  }, {
    key: 'scrollEnded',
    value: function scrollEnded() {
      this._scrolling = false;
      this.inner.css({ pointerEvents: 'auto' });
      this.verticalScroller.scrollEnded();
      this.horizontalScroller.scrollEnded();
    }
  }, {
    key: '_rubberBand',
    value: function _rubberBand(offset, d) {
      var x = Math.abs(offset);
      var res = RUBBER_BAND_FRICTION * x * d / (d + RUBBER_BAND_FRICTION * x);
      return offset < 0 ? -res : res;
    }

    /**
     * Updates offset of the inner scrollable view
     * @param {Point} offset
     * @returns {boolean} - true if offset changed, false otherwise
     */

  }, {
    key: 'setContentOffset',
    value: function setContentOffset(offset) {
      // If decelerating, allow any offset, otherwise constrain it
      var constrainedX = this._decelerating ? offset.x : Math.max(0, Math.min(this._contentSize.width - this.size.width, offset.x));
      var constrainedY = this._decelerating ? offset.y : Math.max(0, Math.min(this._contentSize.height - this.size.height, offset.y));

      // If dragging, allow rubber banding
      if (this._dragging) {
        if (this.horizontalRubberBand) {
          constrainedX += this._rubberBand(offset.x - constrainedX, this.size.width);
        }
        if (this.verticalRubberBand) {
          constrainedY += this._rubberBand(offset.y - constrainedY, this.size.height);
        }
      }
      var newContentOffset = new _Point2.default(constrainedX, constrainedY);
      if (this._contentOffset.equals(newContentOffset)) {
        return false;
      }
      this._contentOffset = newContentOffset;

      var transform = 'translate3d(' + -this._contentOffset.x + 'px, ' + -this._contentOffset.y + 'px, 0)';
      this.inner.css({
        WebkitTransform: transform,
        transform: transform
      });

      var value = this._contentOffset.y / (this._contentSize.height - this.size.height);
      this.verticalScroller.setValue(value);
      value = this._contentOffset.x / (this._contentSize.width - this.size.width);
      this.horizontalScroller.setValue(value);

      this.emit('scroll', this._contentOffset);

      // Emit a fake scroll event on the actual DOM node so other things can pick it up.
      this.triggerEvent('scroll');
      return true;
    }

    /**
     * Get the scroll content offset
     * @type {number}
     */

  }, {
    key: '_getEventX',
    value: function _getEventX(e) {
      // touch event
      if (e.targetTouches && e.targetTouches.length >= 1) {
        return e.targetTouches[0].clientX;
      }

      // other touch event
      if (e.changedTouches && e.changedTouches.length >= 1) {
        return e.changedTouches[0].clientX;
      }

      // mouse event
      return e.clientX;
    }
  }, {
    key: '_getEventY',
    value: function _getEventY(e) {
      // touch event
      if (e.targetTouches && e.targetTouches.length >= 1) {
        return e.targetTouches[0].clientY;
      }

      // other touch event
      if (e.changedTouches && e.changedTouches.length >= 1) {
        return e.changedTouches[0].clientY;
      }

      // mouse event
      return e.clientY;
    }
  }, {
    key: 'touchStart',
    value: function touchStart(event) {
      if (this._tracking) {
        return;
      }

      event.preventDefault();

      // Cancel the current deceleration animation
      if (this._decelerating) {
        this._decelerating = false;
        _raf2.default.cancel(this._decelerationTimer);
      }

      this._tracking = true;
      this._dragging = false;

      this._maxPoint = this.size.height - this._contentSize.height;
      this._startPosition = this._contentOffset;
      this._startTouchPosition = new _Point2.default(this._getEventX(event), this._getEventY(event));
      this._velocityX = 0;
      this._velocityY = 0;
    }
  }, {
    key: 'touchMove',
    value: function touchMove(event) {
      if (!this._tracking) {
        return;
      }

      var x = this._getEventX(event);
      var y = this._getEventY(event);
      var deltaX = this._startTouchPosition.x - x;
      var deltaY = this._startTouchPosition.y - y;

      if (!this._dragging) {
        if (Math.abs(deltaX) >= MIN_DRAG_DELTA || Math.abs(deltaY) >= MIN_DRAG_DELTA) {
          this._dragging = true;
          this._startTouchPosition = new _Point2.default(x, y);

          this.verticalScroller.scrollStarted();
          this.horizontalScroller.scrollStarted();
        }
      }

      if (this._dragging) {
        event.stopPropagation();
        event.preventDefault();

        var lastContentOffset = this._contentOffset;
        this.setContentOffset(new _Point2.default(this._startPosition.x + deltaX, this._startPosition.y + deltaY));

        var v = this._contentOffset.x - lastContentOffset.x;
        this._velocityX = 0.8 * v + 0.2 * this._velocityX;
        v = this._contentOffset.y - lastContentOffset.y;
        this._velocityY = 0.8 * v + 0.2 * this._velocityY;
      }
    }
  }, {
    key: 'touchEnd',
    value: function touchEnd(event) {
      this._tracking = false;

      if (this._dragging) {
        this._dragging = false;
        event.stopPropagation();

        this._decelerate(event);

        if (!this._decelerating) {
          this.verticalScroller.scrollEnded();
          this.horizontalScroller.scrollEnded();
        }
      }
    }
  }, {
    key: '_decelerate',
    value: function _decelerate(event) {
      var isRubberBanding = this._contentOffset.x < 0 || this._contentOffset.x > this._contentSize.width - this.size.width || this._contentOffset.y < 0 || this._contentOffset.y > this._contentSize.height - this.size.height;
      if (Math.abs(this._velocityX) > 1 || Math.abs(this._velocityY) > 1 || isRubberBanding) {
        this._decelerating = true;
        this._decelerationTimer = (0, _raf2.default)(this._decelerationAnimation);
      }
    }
  }, {
    key: '_decelerationAnimation',
    value: function _decelerationAnimation(t) {
      if (!this._decelerating) {
        return;
      }

      // Decelerate
      this._velocityX *= DECELERATION_FRICTION;
      this._velocityY *= DECELERATION_FRICTION;

      // Bounce back if we hit the edge
      var rubberBandX = 0;
      var rubberBandY = 0;

      if (this._contentOffset.x < 0) {
        rubberBandX = -this._contentOffset.x;
      } else if (this._contentOffset.x > this._contentSize.width - this.size.width) {
        rubberBandX = this._contentSize.width - this.size.width - this._contentOffset.x;
      }
      if (this._contentOffset.y < 0) {
        rubberBandY = -this._contentOffset.y;
      } else if (this._contentOffset.y > this._contentSize.height - this.size.height) {
        rubberBandY = this._contentSize.height - this.size.height - this._contentOffset.y;
      }

      if (rubberBandX !== 0) {
        if (rubberBandX * this._velocityX <= 0) {
          this._velocityX += rubberBandX * ELASTIC_DECELERATION;
        } else {
          this._velocityX = rubberBandX * ELASTIC_ACCELERATION;
        }
      }
      if (rubberBandY !== 0) {
        if (rubberBandY * this._velocityY <= 0) {
          this._velocityY += rubberBandY * ELASTIC_DECELERATION;
        } else {
          this._velocityY = rubberBandY * ELASTIC_ACCELERATION;
        }
      }

      this.setContentOffset(new _Point2.default(this._contentOffset.x + this._velocityX, this._contentOffset.y + this._velocityY));

      var vX = Math.abs(this._velocityX);
      var vY = Math.abs(this._velocityY);
      if (vX < HIDE_INDICATORS) {
        this.horizontalScroller.scrollEnded();
      }
      if (vY < HIDE_INDICATORS) {
        this.verticalScroller.scrollEnded();
      }

      if (vX < MIN_VELOCITY && vY < MIN_VELOCITY) {
        this._decelerating = false;
      }

      if (this._decelerating) {
        this._decelerationTimer = (0, _raf2.default)(this._decelerationAnimation);
      }
    }
  }, {
    key: 'size',
    get: function get() {
      return this._size;
    }

    /**
     * Set the outer size of the scroll view
     * @type {Size}
     */
    ,
    set: function set(size) {
      this.setSize(size);
    }
  }, {
    key: 'contentSize',
    get: function get() {
      return this._contentSize;
    }

    /**
     * Set the height of the scrollable content
     * @type {number}
     */
    ,
    set: function set(contentSize) {
      this.setContentSize(contentSize);
    }
  }, {
    key: 'contentOffset',
    get: function get() {
      return this._contentOffset;
    }

    /**
     * Set the scroll content offset
     * @type {number}
     */
    ,
    set: function set(offset) {
      this.setContentOffset(offset);
    }
  }]);

  return ScrollView;
}(_View3.default);

exports.default = ScrollView;