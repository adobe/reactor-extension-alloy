'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _View2 = require('./View');

var _View3 = _interopRequireDefault(_View2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * {@link CollectionView} creates instances of the {@link ReusableView} class to
 * represent views currently being displayed. ReusableViews manage a DOM node, handle
 * applying {@link LayoutInfo} objects to the view, and render content
 * as needed. Subclasses must implement the {@link render} method at a
 * minimum. Other methods can be overrided to customize behavior.
 */
var ReusableView = function (_View) {
  _inherits(ReusableView, _View);

  function ReusableView() {
    _classCallCheck(this, ReusableView);

    var _this = _possibleConstructorReturn(this, (ReusableView.__proto__ || Object.getPrototypeOf(ReusableView)).call(this));

    _this.viewType = null;

    /**
     * The LayoutInfo this view is currently representing.
     * @type {LayoutInfo}
     */
    _this.layoutInfo = null;

    /**
     * The CollectionView currently displaying this view.
     * @type {CollectionView}
     */
    _this.collectionView = null;

    /**
     * The content currently being displayed by this view, set by the collection view.
     */
    _this.content = null;

    _this.contentChanged = false;

    _this.css({
      position: 'absolute',
      overflow: 'hidden',
      top: 0,
      left: 0,
      transition: 'all',
      WebkitTransition: 'all',
      WebkitTransitionDuration: 'inherit',
      transitionDuration: 'inherit'
    });

    // set WAI-ARIA role="presentation", item role should be set in the item renderer
    _this.setAttribute('role', 'presentation');
    return _this;
  }

  /**
   * Applies the given LayoutInfo to the view.
   * If overridden, subclasses must call super.
   * @param {LayoutInfo} layoutInfo - The LayoutInfo to apply
   */


  _createClass(ReusableView, [{
    key: 'applyLayoutInfo',
    value: function applyLayoutInfo(layoutInfo) {
      if (!layoutInfo) {
        return;
      }

      var transform = 'translate3d(' + layoutInfo.rect.x + 'px, ' + layoutInfo.rect.y + 'px, 0)';
      if (layoutInfo.transform) {
        transform += ' ' + layoutInfo.transform;
      }

      this.css({
        width: layoutInfo.rect.width + 'px',
        height: layoutInfo.rect.height + 'px',
        opacity: layoutInfo.opacity,
        zIndex: layoutInfo.zIndex,
        WebkitTransform: transform,
        transform: transform
      });

      this.layoutInfo = layoutInfo;
    }

    /**
     * Prepares the view for reuse. Called just before the view is removed from the DOM.
     */

  }, {
    key: 'prepareForReuse',
    value: function prepareForReuse() {
      this.content = null;
      this.layoutInfo = null;
    }

    /**
     * Sets the content currently being displayed by the view and re-renders.
     */

  }, {
    key: 'setContent',
    value: function setContent(content) {
      this.content = content;
      this.contentChanged = true;
      this.flushUpdates();
    }
  }, {
    key: 'renderChildren',
    value: function renderChildren(context) {
      if (this.contentChanged) {
        this.render(context);
        this.contentChanged = false;
      }
    }

    /**
     * Renders the view. Must be implemented by subclasses.
     * @abstract
     */

  }, {
    key: 'render',
    value: function render(context) {
      throw new Error('Subclasses must implement render');
    }

    /**
     * Applies a state to the view, such as a selected state.
     * The default implementation applies CSS classes.
     * @param {string} state
     */

  }, {
    key: 'addState',
    value: function addState(state) {
      this.addClass(state);
    }

    /**
     * Removes a state from the view, such as a selected state.
     * The default implementation removes CSS classes.
     * @param {string} state
     */

  }, {
    key: 'removeState',
    value: function removeState(state) {
      this.removeClass(state);
    }

    /**
     * Sets whether the given state is applied.
     * @param {string} state
     * @param {boolean} enabled
     */

  }, {
    key: 'setState',
    value: function setState(state, enabled) {
      if (enabled) {
        this.addState(state);
      } else {
        this.removeState(state);
      }
    }

    /**
     * Sets focus to first child element of view if it is focusable.
     */

  }, {
    key: 'focus',
    value: function focus() {
      var node = this.backendView && this.getDOMNode().firstChild;

      if (node && typeof node.focus === 'function') {
        node.focus();
      }
    }
  }]);

  return ReusableView;
}(_View3.default);

exports.default = ReusableView;