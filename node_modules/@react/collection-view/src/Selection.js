'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _IndexPathSet2 = require('./IndexPathSet.js');

var _IndexPathSet3 = _interopRequireDefault(_IndexPathSet2);

var _Range = require('./Range');

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This class models the selection behavior for a collection view.
 * It extends IndexPathSet which implements the data structure for
 * storing the set of selected items, and implements the mouse/keyboard
 * interaction behavior.
 * @private
 */
var Selection = function (_IndexPathSet) {
  _inherits(Selection, _IndexPathSet);

  /**
   * Creates a new Selection
   * @param {CollectionData} content the content of the CollectionView
   */
  function Selection(content) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Selection);

    var _this = _possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).call(this));

    _this.content = content;
    _this.anchor = null;
    _this.current = null;
    _this.allowsMultipleSelection = options.allowsMultipleSelection !== false;
    _this.allowsEmptySelection = options.allowsEmptySelection !== false;

    _this._emptyCheck();
    return _this;
  }

  _createClass(Selection, [{
    key: '_emptyCheck',
    value: function _emptyCheck() {
      var firstIndexPath = void 0;
      if (!this.allowsEmptySelection && this.isEmpty && (firstIndexPath = this.content.firstIndexPath)) {
        this.replaceWith(firstIndexPath);
      }
    }

    /**
     * Toggles the given IndexPath in the selection
     * @param {IndexPath} indexPath the IndexPath to toggle
     */

  }, {
    key: 'toggleIndexPath',
    value: function toggleIndexPath(indexPath) {
      if (!this.allowsMultipleSelection && !(this.allowsEmptySelection && this.contains(indexPath))) {
        _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'clear', this).call(this);
      }

      if (!this.allowsEmptySelection && this.length === 1 && this.contains(indexPath)) {
        return;
      }

      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'toggleIndexPath', this).call(this, indexPath);

      // If we the item is now selected, make it the new anchor, otherwise
      // use the last selected item.
      var last = this.contains(indexPath) ? indexPath : this.lastIndexPath;
      this.anchor = last && last.copy();
      this.current = last && last.copy();
    }
  }, {
    key: '_makeRange',
    value: function _makeRange(a, b) {
      var min = a.min(b);
      var max = a.max(b);
      return [min, max];
    }
  }, {
    key: '_addRange',
    value: function _addRange(start, end) {
      for (var section = start.section; section <= end.section; section++) {
        var endIndex = section === end.section ? end.index : this.content.getSectionLength(section) - 1;
        var index = section === start.section ? start.index : 0;
        this.addRangeInSection(section, new _Range2.default(index, endIndex));
      }
    }
  }, {
    key: '_removeRange',
    value: function _removeRange(start, end) {
      for (var section = start.section; section <= end.section; section++) {
        var endIndex = section === end.section ? end.index : this.content.getSectionLength(section) - 1;
        var index = section === start.section ? start.index : 0;
        this.removeRangeInSection(section, new _Range2.default(index, endIndex));
      }
    }

    /**
     * Extends the selection to the given index path
     * @param {IndexPath} indexPath the IndexPath to extend the selection to
     */

  }, {
    key: 'extendTo',
    value: function extendTo(indexPath) {
      if (!this.allowsMultipleSelection) {
        return this.replaceWith(indexPath);
      }

      if (!this.anchor) {
        this.anchor = indexPath.copy();
      }

      this._removeRange.apply(this, _toConsumableArray(this._makeRange(this.anchor, this.current || indexPath)));
      this._addRange.apply(this, _toConsumableArray(this._makeRange(indexPath, this.anchor)));

      this.current = indexPath.copy();
    }

    /**
     * Clears the selection
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (!this.allowsEmptySelection) {
        return;
      }

      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'clear', this).call(this);
      this._emptyCheck();

      this.anchor = null;
      this.current = null;
    }

    /**
     * Clears the selection and replaces it with the given index path
     * @param {IndexPath} indexPath the IndexPath to replace the selection with
     */

  }, {
    key: 'replaceWith',
    value: function replaceWith(indexPath) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'clear', this).call(this);
      this.addIndexPath(indexPath);

      this.anchor = indexPath.copy();
      this.current = indexPath.copy();
    }

    /**
     * Selects all elements in the content
     */

  }, {
    key: 'selectAll',
    value: function selectAll() {
      if (!this.allowsMultipleSelection) {
        return;
      }

      this.clear();

      var start = this.content.firstIndexPath;
      if (start) {
        var end = this.content.lastIndexPath;
        this._addRange(start, end);
        this.anchor = start.copy();
        this.current = end.copy();
      }
    }
  }, {
    key: '_adjustSelectionIndex',
    value: function _adjustSelectionIndex(section, index, amount) {
      if (this.anchor && this.anchor.section === section && this.anchor.index >= index) {
        this.anchor.index += amount;
      }

      if (this.current && this.current.section === section && this.current.index >= index) {
        this.current.index += amount;
      }
    }
  }, {
    key: 'adjustForInsertionInSection',
    value: function adjustForInsertionInSection(section, range) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForInsertionInSection', this).call(this, section, range);
      this._adjustSelectionIndex(section, range.start, range.length);
      this._emptyCheck();
    }
  }, {
    key: 'adjustForDeletionInSection',
    value: function adjustForDeletionInSection(section, range) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForDeletionInSection', this).call(this, section, range);

      // null anchor and current if they were deleted
      if (this.anchor && this.anchor.section === section && range.contains(this.anchor.index)) {
        this.anchor = null;
      }

      if (this.current && this.current.section === section && range.contains(this.current.index)) {
        this.current = null;
      }

      this._adjustSelectionIndex(section, range.start, -range.length);
      this._emptyCheck();
    }
  }, {
    key: 'adjustForMove',
    value: function adjustForMove(from, to) {
      var anchor = from.equals(this.anchor) ? to : this.anchor;
      var current = from.equals(this.current) ? to : this.current;

      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForMove', this).call(this, from, to);

      this.anchor = anchor;
      this.current = current;
    }
  }, {
    key: '_adjustSelectionSection',
    value: function _adjustSelectionSection(section, count) {
      if (this.anchor && this.anchor.section >= section) {
        this.anchor.section += count;
      }

      if (this.current && this.current.section >= section) {
        this.current.section += count;
      }
    }
  }, {
    key: 'adjustForInsertedSection',
    value: function adjustForInsertedSection(section) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForInsertedSection', this).call(this, section);
      this._adjustSelectionSection(section, +1);
      this._emptyCheck();
    }
  }, {
    key: 'adjustForDeletedSection',
    value: function adjustForDeletedSection(section) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForDeletedSection', this).call(this, section);

      // null anchor and current if their section was deleted
      if (this.anchor && this.anchor.section === section) {
        this.anchor = null;
      }

      if (this.current && this.current.section === section) {
        this.current = null;
      }

      this._adjustSelectionSection(section, -1);
      this._emptyCheck();
    }
  }, {
    key: 'adjustForMovedSection',
    value: function adjustForMovedSection(fromSection, toSection) {
      _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'adjustForMovedSection', this).call(this, fromSection, toSection);

      if (this.anchor && this.anchor.section === fromSection) {
        this.anchor.section = toSection;
      }

      if (this.current && this.current.section === fromSection) {
        this.current.section = toSection;
      }
    }
  }, {
    key: 'adjustForReloadedSection',
    value: function adjustForReloadedSection(section) {
      this.removeSection(section);

      // null anchor and current if their section was deleted
      if (this.anchor && this.anchor.section === section) {
        this.anchor = null;
      }

      if (this.current && this.current.section === section) {
        this.current = null;
      }

      this._emptyCheck();
    }

    /**
     * Returns whether this Selection is equal to another one
     * @param {Selection} other the Selection to compare
     * @return {boolean}
     */

  }, {
    key: 'equals',
    value: function equals(other) {
      if (!_get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'equals', this).call(this, other) || this.content !== other.content) {
        return false;
      }

      if (this.anchor && !this.anchor.equals(other.anchor)) {
        return false;
      }

      if (this.current && !this.current.equals(other.current)) {
        return false;
      }

      return true;
    }

    /**
     * Copies the selection
     * @return {Selection}
     */

  }, {
    key: 'copy',
    value: function copy() {
      var res = new Selection(this.content, {
        allowsMultipleSelection: this.allowsMultipleSelection,
        allowsEmptySelection: this.allowsEmptySelection
      });

      res.sectionIndexes.addIndexSet(this.sectionIndexes);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.sectionIndexSets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              section = _step$value[0],
              indexSet = _step$value[1];

          res.sectionIndexSets.set(section, indexSet.copy());
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (this.anchor) {
        res.anchor = this.anchor.copy();
      }

      if (this.current) {
        res.current = this.current.copy();
      }

      return res;
    }

    /**
     * Returns an IndexPathSet containing the IndexPaths in the selection
     * @return {IndexPathSet}
     */

  }, {
    key: 'getIndexPathSet',
    value: function getIndexPathSet() {
      return _get(Selection.prototype.__proto__ || Object.getPrototypeOf(Selection.prototype), 'copy', this).call(this);
    }
  }]);

  return Selection;
}(_IndexPathSet3.default);

exports.default = Selection;