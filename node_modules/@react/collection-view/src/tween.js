'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tween;

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// use high res timer if available
var perf = global.performance;
var perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);
var getTime = perfNow ? perfNow.bind(perf) : function () {
  return Date.now ? Date.now() : new Date().getTime();
};

// check if we need to get the time each frame (see below)
var fixTs = false;
(0, _raf2.default)(function (t) {
  fixTs = t > 1e12 !== getTime() > 1e12;
});

function tween(begin, end, duration, ease, fn) {
  var canceled = false;
  var raf_id = void 0;

  var promise = new Promise(function (resolve) {
    var start = getTime();
    var diffX = end.x - begin.x;
    var diffY = end.y - begin.y;

    raf_id = (0, _raf2.default)(function run(t) {
      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.
      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
      if (fixTs) {
        t = getTime();
      }

      // check if we're done
      var delta = t - start;
      if (delta > duration) {
        fn(end);
        resolve();
      } else {
        // call frame callback after computing eased time and get the next frame
        var proceed = fn(new _Point2.default(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));
        if (proceed !== false && !canceled) {
          raf_id = (0, _raf2.default)(run);
        }
      }
    });
  });

  promise.cancel = function () {
    canceled = true;
    _raf2.default.cancel(raf_id);
  };

  return promise;
}

// easing functions
tween.linear = function (t) {
  return t;
};

tween.easeOut = function (t) {
  return Math.sin(t * Math.PI / 2);
};