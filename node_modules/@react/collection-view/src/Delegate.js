"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// These classes are only used for documentation purposes.
/* eslint no-unused-vars: ["off"] */

/**
 * The collection view delegate is an object with methods that will be called
 * by the {@link CollectionView} to configure its behavior. For example,
 * it has methods to classify item objects, and create instances of views
 * on behalf of the collection view.
 *
 * {@link EditableCollectionView} extends the delegate with more methods
 * related to handling user interaction. See {@link EditableCollectionViewDelegate}.
 *
 * @interface
 */
var CollectionViewDelegate = function () {
  function CollectionViewDelegate() {
    _classCallCheck(this, CollectionViewDelegate);
  }

  _createClass(CollectionViewDelegate, [{
    key: "getType",

    /**
     * Returns the type of view to display for the given item
     * @param {*} item - An item as returned by the {@link DataSource}
     * @return {string}
     */
    value: function getType(item) {}

    /**
     * Creates and returns a view for the item with the given parameters.
     * The content, and LayoutInfo for the view will be set subsequently,
     * and should not be set by the delegate.
     *
     * @param {string} type - The type of view to create
     * @param {number} section - The section of the view to create
     * @param {number} index - The index of the view to create
     * @return {ReusableView}
     */

  }, {
    key: "createView",
    value: function createView(type, section, index) {}

    /**
     * Returns the content to apply to the supplementary view with the
     * given parameters. The view will have been created by a previous
     * call to {@link createView}.
     *
     * @param {string} type - The type of supplementary view
     * @param {number} section - The section of the supplementary view
     * @param {number} index - The index of the supplementary view
     * @return {*}
     */

  }, {
    key: "getContentForExtraView",
    value: function getContentForExtraView(type, section, index) {}

    /**
     * Returns an IndexPath to use as the anchor of the scroll position
     *
     * @param {Rect} visibleRect - The visible rectangle
     * @return {IndexPath}
     */

  }, {
    key: "getScrollAnchor",
    value: function getScrollAnchor(visibleRect) {}
  }]);

  return CollectionViewDelegate;
}();

/**
 * {@link EditableCollectionView} extends the existing {@link CollectionViewDelegate}
 * with additional methods to allow configuration of its behavior. These methods relate
 * to user interaction, specifically drag and drop. All of the methods are optional,
 * and if not provided, the collection view will use its default behavior.
 *
 * @interface
 */


var EditableCollectionViewDelegate = function (_CollectionViewDelega) {
  _inherits(EditableCollectionViewDelegate, _CollectionViewDelega);

  function EditableCollectionViewDelegate() {
    _classCallCheck(this, EditableCollectionViewDelegate);

    return _possibleConstructorReturn(this, (EditableCollectionViewDelegate.__proto__ || Object.getPrototypeOf(EditableCollectionViewDelegate)).apply(this, arguments));
  }

  _createClass(EditableCollectionViewDelegate, [{
    key: "shouldSelectItem",

    /**
     * Returns whether the user is allowed to select the given indexPath
     * @param {IndexPath} indexPath
     * @return {boolean}
     */
    value: function shouldSelectItem(indexPath) {}

    /**
     * Returns whether the user is allowed to drag the given DragTarget
     * @param {DragTarget} dragTarget
     * @param {IndexPathSet} selectedIndexPaths
     * @return {boolean}
     */

  }, {
    key: "shouldDrag",
    value: function shouldDrag(dragTarget, selectedIndexPaths) {}

    /**
     * Returns a bit mask representing the allowed drop operations for a drag source.
     * @param {DragTarget} dragTarget
     * @param {IndexPathSet} selectedIndexPaths
     * @return {DropOperation}
     */

  }, {
    key: "getAllowedDropOperations",
    value: function getAllowedDropOperations(dragTarget, selectedIndexPaths) {}

    /**
     * Should set data to be dragged for a given DragTarget on the provided
     * DataTransfer object. For example, plain text and json versions of the
     * items to be dragged could be set.
     * @param {DragTarget} dragTarget - The initial target of the drag
     * @param {DataTransfer} dataTransfer - The DOM DataTransfer object for the drag
     * @param {IndexPathSet} selectedIndexPaths
     */

  }, {
    key: "prepareDragData",
    value: function prepareDragData(dragTarget, dataTransfer, selectedIndexPaths) {}

    /**
     * Should return a view to display as the image under the cursor during the drag
     * @param {DragTarget} dragTarget - The initial target of the drag
     * @param {IndexPathSet} selectedIndexPaths
     * @return {ReusableView}
     */

  }, {
    key: "getDragView",
    value: function getDragView(dragTarget, selectedIndexPaths) {}

    /**
     * Called when a drag initiated by this collection view is dropped somewhere.
     * @param {DragTarget} dragTarget - The initial target of the drag
     * @param {DataTransfer} dataTransfer - The DOM DataTransfer object for the drag
     */

  }, {
    key: "dropAccepted",
    value: function dropAccepted(dragTarget, dataTransfer) {}

    /**
     * Returns whether a drop event should be accepted. Called when the drag enters the
     * collection view. Usually, you will look at the drag types to determine whether a
     * drop should be accepted.
     * @param {Event} event - The DOM event
     * @return {boolean}
     */

  }, {
    key: "shouldAcceptDrop",
    value: function shouldAcceptDrop(event) {}

    /**
     * Returns a {@link DragTarget} specifying where a drag should be dropped.
     * The given target is the {@link DragTarget} returned by the layout.
     * Use this method if you want to override what the layout returns.
     * @param {DragTarget} target - The original target from the layout
     * @param {Point} point - The point on the screen where the drag is
     * @return {DragTarget}
     */

  }, {
    key: "getDropTarget",
    value: function getDropTarget(target, point) {}

    /**
     * Gets the drop operation that will occur when dropping on the given target.
     * @param {DragTarget} dropTarget - the drop target
     * @param {DropOperation} allowedOperations - a bit mask representing the allowed drop operations
     */

  }, {
    key: "getDropOperation",
    value: function getDropOperation(dropTarget, allowedOperations) {}

    /**
     * Called when the drop target within this collection view changes.
     * @param {DragTarget} target - The new drop target
     */

  }, {
    key: "dropTargetUpdated",
    value: function dropTargetUpdated(target) {}

    /**
     * Returns an array of items or sections to insert for the given drop target.
     * @param {DragTarget} dropTarget - The target of the drop
     * @param {DataTransfer} dataTransfer - The DOM DataTransfer object for the drop
     * @return {Array}
     */

  }, {
    key: "itemsForDrop",
    value: function itemsForDrop(dropTarget, dataTransfer) {}

    /**
     * Returns whether the user is allowed to delete the items in the given index paths.
     * @param {IndexPathSet} indexPaths
     * @return {boolean}
     */

  }, {
    key: "shouldDeleteItems",
    value: function shouldDeleteItems(indexPaths) {}
  }]);

  return EditableCollectionViewDelegate;
}(CollectionViewDelegate);

/**
 * {@link ListLayout} calls these methods on the same delegate object as the collection
 * view uses in order to determine layout information. All of the methods are optional:
 * if not provided, the default values from the properties of ListLayout are used.
 * @interface
 */


var ListLayoutDelegate = function (_CollectionViewDelega2) {
  _inherits(ListLayoutDelegate, _CollectionViewDelega2);

  function ListLayoutDelegate() {
    _classCallCheck(this, ListLayoutDelegate);

    return _possibleConstructorReturn(this, (ListLayoutDelegate.__proto__ || Object.getPrototypeOf(ListLayoutDelegate)).apply(this, arguments));
  }

  _createClass(ListLayoutDelegate, [{
    key: "indentationForItem",

    /**
     * Returns a CSS style object for the header view in the provided section,
     * or `null` for no header.
     * @param {number} section - The section the item would be in
     * @param {number} index - The index of the item inside the section
     * @return {number} - The amount of indentation in px
     */
    value: function indentationForItem(section, index) {}
  }]);

  return ListLayoutDelegate;
}(CollectionViewDelegate);

/** @external {DataTransfer} https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer */
/** @external {EventEmitter} https://nodejs.org/api/events.html#events_class_events_eventemitter */