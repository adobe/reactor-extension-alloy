'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CollectionView2 = require('./CollectionView.js');

var _CollectionView3 = _interopRequireDefault(_CollectionView2);

var _DragTarget = require('./DragTarget');

var _DragTarget2 = _interopRequireDefault(_DragTarget);

var _DropOperation = require('./DropOperation');

var _DropOperation2 = _interopRequireDefault(_DropOperation);

var _IndexPath = require('./IndexPath');

var _IndexPath2 = _interopRequireDefault(_IndexPath);

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

var _Range = require('./Range');

var _Range2 = _interopRequireDefault(_Range);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _Selection = require('./Selection');

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCROLLTOITEM_DURATION = 200;

/**
 * The EditableCollectionView class extends {@link CollectionView} with support for multiple selection,
 * keyboard interaction, drag and drop, and content reordering. It interacts with your {@link DataSource}
 * to allow users to drop new items and sections into the collection view to be inserted, drag and drop
 * views in the collection view to allow reordering of items or sections, and supports deletions of the
 * selected items via keyboard interaction. It also extends the collection view's delegate with additional
 * methods in {@link EditableCollectionViewDelegate} to allow overriding some of this behavior. Additionally,
 * the {@link Layout} is involved very closely in determining the behavior of views during drag and drop,
 * and keyboard selection behavior.
 */

var EditableCollectionView = function (_CollectionView) {
  _inherits(EditableCollectionView, _CollectionView);

  function EditableCollectionView() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, EditableCollectionView);

    /**
     * Whether the user can select items. Default is `true`.
     * @type {boolean}
     */
    var _this = _possibleConstructorReturn(this, (EditableCollectionView.__proto__ || Object.getPrototypeOf(EditableCollectionView)).call(this, options));

    _this.canSelectItems = options.canSelectItems !== false;

    /**
     * Whether the user can select multiple items at once. Default is `true`.
     * @type {boolean}
     */
    _this.allowsMultipleSelection = options.allowsMultipleSelection !== false;

    /**
     * Whether the user can select no items. Default is `true`.
     * @type {boolean}
     */
    _this.allowsEmptySelection = options.allowsEmptySelection !== false;

    /**
     * The default selection mode: either 'replace' or 'toggle'. Default is 'replace'.
     * @type {string}
     */
    _this.selectionMode = options.selectionMode || 'replace';

    /**
     * The keyboard interaction mode: either 'selection' or 'focus'. Controls arrow key behavior.
     * Default is 'selection' if canSelectItems is enabled, otherwise 'focus'.
     * @type {string}
     */
    _this.keyboardMode = options.keyboardMode || (_this.canSelectItems ? 'selection' : 'focus');

    /**
     * Whether to emit selection changes on mouse up. Default is `false`,
     * meaning emit on mouse down.
     * @type {boolean}
     */
    _this.selectOnMouseUp = options.selectOnMouseUp || false;

    /**
     * Whether the user can drag items. Default is `false`.
     * @type {boolean}
     */
    _this.canDragItems = options.canDragItems || false;

    /**
     * Whether the user can reorder items via drag and drop. Default is `false`.
     * @type {boolean}
     */
    _this.canReorderItems = options.canReorderItems || false;

    /**
     * Whether the user can reorder sections via drag and drop. Default is `false`.
     * @type {boolean}
     */
    _this.canReorderSections = options.canReorderSections || false;

    /**
     * Whether the collection view accepts drops. Default is `false`.
     * If `true`, the collection view accepts all types of drops. Alternatively,
     * it can be set to an array of accepted drop types.
     * @type {boolean|string[]}
     */
    _this.acceptsDrops = options.acceptsDrops || false;

    /**
     * Whether the user can delete items using the keyboard. Default is `false`.
     * @type {boolean}
     */
    _this.canDeleteItems = options.canDeleteItems || false;

    /**
     * The collection view delegate. The delegate is used by the collection view to create and configure views,
     * and can be used to customize drag and drop behavior.
     * @type {EditableCollectionViewDelegate}
     */
    _this.delegate = _this.delegate;

    _this._selection = new _Selection2.default(_this._content, {
      allowsMultipleSelection: _this.allowsMultipleSelection,
      allowsEmptySelection: _this.allowsEmptySelection
    });

    _this._mouseOffset = null;
    _this._dragTarget = null;
    _this._dropTarget = null;
    _this._selectOnMouseUp = null;

    // Make keyboard focusable
    _this.setAttribute('tabIndex', -1);

    // Bind events
    _this.mouseDown = _this.mouseDown.bind(_this);
    _this.mouseUp = _this.mouseUp.bind(_this);
    _this.keyDown = _this.keyDown.bind(_this);
    _this.onFocus = _this.onFocus.bind(_this);
    _this.onBlur = _this.onBlur.bind(_this);
    _this._setupEvents();
    return _this;
  }

  _createClass(EditableCollectionView, [{
    key: 'updateAccessibilityAttributes',
    value: function updateAccessibilityAttributes(props) {
      var _props$allowsMultiple = props.allowsMultipleSelection,
          allowsMultipleSelection = _props$allowsMultiple === undefined ? true : _props$allowsMultiple;

      if (props['aria-multiselectable']) {
        if (!this.attrs['aria-multiselectable'] || this.attrs['aria-multiselectable'] !== allowsMultipleSelection) {
          this.setAttribute('aria-multiselectable', allowsMultipleSelection);
        }
      }
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), 'updateAccessibilityAttributes', this).call(this, props);
    }
  }, {
    key: '_setupEvents',
    value: function _setupEvents() {
      this.onEvent('mouseDown', this.mouseDown);
      this.onEvent('mouseUp', this.mouseUp);
      this.onEvent('keyDown', this.keyDown);
      this.onEvent('focus', this.onFocus);
      this.onEvent('blur', this.onBlur);
      this.backend.registerDragEvents(this);
    }
  }, {
    key: '_teardownEvents',
    value: function _teardownEvents() {
      this.offEvent('mouseDown', this.mouseDown);
      this.offEvent('mouseUp', this.mouseUp);
      this.offEvent('keyDown', this.keyDown);
      this.offEvent('focus', this.onFocus);
      this.offEvent('blur', this.onBlur);
      this.backend.unregisterDragEvents(this);
    }
  }, {
    key: '_setDataSource',
    value: function _setDataSource(dataSource) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_setDataSource', this).call(this, dataSource);
      this._selection = new _Selection2.default(this._content, {
        allowsMultipleSelection: this.allowsMultipleSelection,
        allowsEmptySelection: this.allowsEmptySelection
      });
    }
  }, {
    key: 'getReusableView',
    value: function getReusableView(layoutInfo) {
      var view = _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), 'getReusableView', this).call(this, layoutInfo);
      if (layoutInfo.type !== 'item') {
        return view;
      }

      this._updateViewState(view);
      return view;
    }

    // MARK: selection support

  }, {
    key: 'mouseDown',
    value: function mouseDown(e) {
      var point = this.convertPoint(new _Point2.default(e.clientX, e.clientY));
      var index = this.indexPathAtPoint(point);
      if (!index) {
        if (!e.metaKey && !e.shiftKey) {
          this.clearSelection();
        }

        // Emit an event when the user clicks on the background (e.g. not on an item view)
        this.emit('backgroundClick', point);
        return;
      }

      var layoutInfo = this.layout.getLayoutInfo('item', index.section, index.index);
      this._mouseOffset = new _Point2.default(point.x - layoutInfo.rect.x, point.y - layoutInfo.rect.y);

      this.focusItem(index);

      // If clicking on an already selected index without any modifier keys, replace the selection
      // with that index on mouse up.
      if (!e.metaKey && !e.shiftKey && this._selection.contains(index)) {
        this._selectOnMouseUp = index;
      } else {
        this.selectItem(index, e.metaKey || this.selectionMode === 'toggle', e.shiftKey, !this.selectOnMouseUp);
      }
    }
  }, {
    key: 'mouseUp',
    value: function mouseUp(e) {
      if (this._selectOnMouseUp != null) {
        this.selectItem(this._selectOnMouseUp, this.selectionMode === 'toggle');
        this._selectOnMouseUp = null;
      }

      if (this.selectOnMouseUp) {
        this.emit('selectionChanged', this.selectedIndexPaths);
      }
    }

    /**
     * Selects the item at the given IndexPath. By default it replaces the current
     * selection, unless the `toggle` or `extend` options are true.
     * @param {IndexPath} indexPath - The IndexPath to select
     * @param {boolean} toggle - Whether to toggle the IndexPath.
     *    Adds it to the selection if not already in it, or removes it if it is.
     * @param {boolean} extend - Whether to extend the selection to the given IndexPath.
     *    If true, the all items between the current selection anchor and the given IndexPath
     *    are selected
     * @param {boolean} emit - Whether to emit the `selectionChanged` event
     */

  }, {
    key: 'selectItem',
    value: function selectItem(indexPath) {
      var toggle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var extend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var emit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (!indexPath || !this.canSelectItems) {
        return;
      }

      if (this.delegate.shouldSelectItem && !this.delegate.shouldSelectItem(indexPath)) {
        return;
      }

      if (extend) {
        this._selection.extendTo(indexPath);
      } else if (toggle) {
        this._selection.toggleIndexPath(indexPath);
      } else {
        this._selection.replaceWith(indexPath);
      }

      this._updateSelection(emit);
    }

    /**
     * Clears the selection
     */

  }, {
    key: 'clearSelection',
    value: function clearSelection() {
      this._selection.clear();
      this._updateSelection();
    }

    /**
     * Selects all items in the collection view
     */

  }, {
    key: 'selectAll',
    value: function selectAll() {
      if (!this.canSelectItems) {
        return;
      }

      this._selection.selectAll();
      this._updateSelection();
    }
  }, {
    key: '_updateSelection',
    value: function _updateSelection(emit) {
      if (!this.canSelectItems) {
        return;
      }

      this._updateVisibleViewStates();

      if (emit !== false) {
        this.emit('selectionChanged', this.selectedIndexPaths);
      }
    }
  }, {
    key: '_updateVisibleViewStates',
    value: function _updateVisibleViewStates() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._visibleViews.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var view = _step.value;

          this._updateViewState(view);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_updateViewState',
    value: function _updateViewState(view) {
      var layoutInfo = view.layoutInfo;

      if (layoutInfo.type !== 'item') {
        return;
      }

      var indexPath = new _IndexPath2.default(layoutInfo.section, layoutInfo.index);

      view.setState('selected', this._selection.contains(indexPath));
      view.setState('focused', this._focusedIndexPath && this._focusedIndexPath.equals(indexPath));
    }

    /**
     * The currently selected IndexPaths
     * @type {IndexPathSet}
     */

  }, {
    key: 'focusItem',


    /**
     * Focus the item at the given IndexPath.
     * @param {IndexPath} indexPath - The IndexPath to of item to focus
     */
    value: function focusItem(indexPath) {
      var _this2 = this;

      if (!indexPath || indexPath.equals(this._focusedIndexPath) && !this.getItemView(indexPath.section, indexPath.index)) {
        return;
      }

      this._focusedIndexPath = indexPath;

      if (this._scrollAnimation) {
        if (this._focusItemRaf) {
          _raf2.default.cancel(this._focusItemRaf);
        }
        this._focusItemRaf = (0, _raf2.default)(function () {
          return _this2._focusItemNow(indexPath);
        });
      } else {
        this._focusItemNow(indexPath);
      }
    }
  }, {
    key: '_focusItemNow',
    value: function _focusItemNow(indexPath) {
      var _this3 = this;

      if (!indexPath) {
        return;
      }

      var view = this.getItemView(indexPath.section, indexPath.index);

      this._focusItemRaf = null;

      var _focusItemView = function _focusItemView() {
        view = _this3.getItemView(indexPath.section, indexPath.index);
        if (!view) {
          return;
        }

        _this3.setAttribute('tabIndex', -1);
        (0, _raf2.default)(function () {
          return view.focus();
        });
      };

      // If scrolling, and view is not yet present in the viewport,
      if (this._scrollAnimation && !view) {
        // focus the EditableCollectionView until animation completes,
        this.focus();
        // then restore focus to the appropriate item.
        this._scrollAnimation.then(_focusItemView);
      } else {
        // Otherwise, focus the appropriate item.
        _focusItemView();
      }

      // update focused state and tabIndex for visible views
      this._updateVisibleViewStates();
    }

    // MARK: drag and drop support

  }, {
    key: 'dragStart',
    value: function dragStart(event) {
      var point = this.convertPoint(new _Point2.default(event.clientX, event.clientY));
      var target = this.layout.getDragTarget(point);
      if (!target) {
        return _DropOperation2.default.NONE;
      }

      if (target.type === 'section' && !this.canReorderSections) {
        return _DropOperation2.default.NONE;
      }

      if (target.type === 'item' && !(this.canReorderItems || this.canDragItems)) {
        return _DropOperation2.default.NONE;
      }

      var indexPaths = this.selectedIndexPaths;
      if (this.delegate.shouldDrag && !this.delegate.shouldDrag(target, indexPaths)) {
        return _DropOperation2.default.NONE;
      }

      var dragView = this._getDragView(target, indexPaths);
      if (dragView) {
        dragView.renderBackendView(this.backend);
        this.backend.setDragImage(event, dragView);
      }

      // Ask the delegate for drag data if possible, otherwise use a default format
      if (this.delegate.prepareDragData) {
        this.delegate.prepareDragData(target, event.dataTransfer, indexPaths);
      } else {
        var items = void 0;
        if (target.type === 'section') {
          items = this._content.getItemsInSection(target.indexPath.section);
        } else {
          items = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = indexPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var indexPath = _step2.value;

              items.push(this.getItem(indexPath));
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        event.dataTransfer.setData('CollectionViewData', JSON.stringify(items));
      }

      this._selectOnMouseUp = null;
      this._dragTarget = target;

      // Default to allowing all drop operations for this drag, but allow the delegate to override.
      var allowedOperations = _DropOperation2.default.ALL;
      if (this.delegate.getAllowedDropOperations) {
        allowedOperations = this.delegate.getAllowedDropOperations(target, indexPaths);
      }

      return allowedOperations;
    }
  }, {
    key: '_getDragView',
    value: function _getDragView(target, indexPaths) {
      var dragView = this._getDragViewFromDelegate(target, indexPaths);
      if (dragView) {
        return dragView;
      }

      var view = this.getItemView(target.indexPath.section || 0, target.indexPath.index || 0);
      if (!view) {
        return null;
      }

      return view;
    }
  }, {
    key: '_getDragViewFromDelegate',
    value: function _getDragViewFromDelegate(target, indexPaths) {
      if (this.delegate.getDragView) {
        return this.delegate.getDragView(target, indexPaths);
      }
    }
  }, {
    key: '_shouldAcceptDrop',
    value: function _shouldAcceptDrop(event) {
      if (this.canReorderItems && this._dragTarget) {
        return true;
      }

      if (this.acceptsDrops) {
        // If this.acceptsDrops is an array of types, check if the drag
        // has any of the accepted types.
        if (Array.isArray(this.acceptsDrops)) {
          var types = new Set(event.dataTransfer.types);
          if (!this.acceptsDrops.some(function (type) {
            return types.has(type);
          })) {
            return false;
          }
        }

        // Ask the delegate if it has a shouldAcceptDrop method.
        if (this.delegate.shouldAcceptDrop && !this.delegate.shouldAcceptDrop(event)) {
          return false;
        }

        return true;
      }

      return false;
    }
  }, {
    key: 'dragEntered',
    value: function dragEntered(event, allowedOperations) {
      if (this._shouldAcceptDrop(event)) {
        this._enableTransitions();
        return _DropOperation2.default.MOVE;
      }

      return _DropOperation2.default.NONE;
    }
  }, {
    key: '_getDropTargetView',
    value: function _getDropTargetView(dropTarget) {
      if (dropTarget && dropTarget.dropPosition === _DragTarget2.default.DROP_ON) {
        return this.getView(dropTarget.type, dropTarget.indexPath.section, dropTarget.indexPath.index);
      }

      return null;
    }
  }, {
    key: '_setDropTarget',
    value: function _setDropTarget(dropTarget) {
      if (this._dropTarget && dropTarget && this._dropTarget.equals(dropTarget)) {
        return false;
      }

      var dropTargetView = this._getDropTargetView(this._dropTarget);
      if (dropTargetView) {
        dropTargetView.removeState('drop-target');
      }

      dropTargetView = this._getDropTargetView(dropTarget);
      if (dropTargetView) {
        dropTargetView.addState('drop-target');
      }

      this._dropTarget = dropTarget;

      if (typeof this.delegate.dropTargetUpdated === 'function') {
        this.delegate.dropTargetUpdated(dropTarget);
      }

      return true;
    }
  }, {
    key: 'dragMoved',
    value: function dragMoved(event, allowedOperations) {
      var point = this.convertPoint(new _Point2.default(event.clientX, event.clientY));
      var target = this.layout.getDropTarget(point);

      // Call the delegate to override the target from the layout
      if (target && this.delegate.getDropTarget) {
        target = this.delegate.getDropTarget(target, point);
      }

      var dropOperation = _DropOperation2.default.NONE;
      if (target) {
        // Ask the delegate to get the drop operation,
        // or default to the first allowed operation.
        if (this.delegate.getDropOperation) {
          dropOperation = this.delegate.getDropOperation(target, allowedOperations);
        } else {
          // Get the least significant bit that is set
          dropOperation = allowedOperations & -allowedOperations;
        }
      }

      if (this._setDropTarget(target)) {
        this.relayoutNow();
      }

      var scrollBottom = this.size.height - 60;
      var scrollTop = 60;
      var scrollLeft = 60;
      var scrollRight = this.size.width - 60;
      var x = point.x - this._contentOffset.x;
      var y = point.y - this._contentOffset.y;
      if (x < scrollLeft || x > scrollRight || y < scrollTop || y > scrollBottom) {
        var scrollSpeedX = 0;
        var scrollSpeedY = 0;
        if (x < scrollLeft) {
          scrollSpeedX = x - scrollLeft;
        } else if (x > scrollRight) {
          scrollSpeedX = x - scrollRight;
        }
        if (y < scrollTop) {
          scrollSpeedY = y - scrollTop;
        } else if (y > scrollBottom) {
          scrollSpeedY = y - scrollBottom;
        }
        this._scroll(event, scrollSpeedX, scrollSpeedY);
      } else {
        this._stopScrolling();
      }

      return dropOperation;
    }
  }, {
    key: '_scroll',
    value: function _scroll(event, scrollSpeedX, scrollSpeedY) {
      var _this4 = this;

      this._scrollSpeedX = scrollSpeedX * 0.33;
      this._scrollSpeedY = scrollSpeedY * 0.33;

      var frame = function frame() {
        _this4.setContentOffset(new _Point2.default(_this4._contentOffset.x + _this4._scrollSpeedX, _this4._contentOffset.y + _this4._scrollSpeedY));
        if (_this4._scrollTimer) {
          _this4._scrollTimer = (0, _raf2.default)(frame);
        }
      };

      this._scrollTimer = this._scrollTimer || (0, _raf2.default)(frame);
    }
  }, {
    key: '_stopScrolling',
    value: function _stopScrolling() {
      if (this._scrollTimer) {
        _raf2.default.cancel(this._scrollTimer);
        this._scrollTimer = null;
      }
    }
  }, {
    key: 'dragExited',
    value: function dragExited() {
      var _this5 = this;

      this._setDropTarget(null);
      this.relayoutNow();

      this._stopScrolling();

      if (!this._dragTarget) {
        setTimeout(function () {
          if (!_this5._dragTarget) {
            _this5._disableTransitions();
          }
        }, this.transitionDuration);
      }
    }
  }, {
    key: 'dragEnd',
    value: function dragEnd(event, dropOperation) {
      this.dragExited();

      var target = this._dragTarget;
      this._dragTarget = null;
      this._setDropTarget(null);

      if (!this._transaction) {
        this._disableTransitions();
      }

      if (dropOperation && this.delegate.dragAccepted) {
        this.delegate.dragAccepted(target, dropOperation);
      }
    }
  }, {
    key: 'drop',
    value: function drop(event, dropOperation) {
      var _this6 = this;

      var dropTarget = this._dropTarget;
      if (!dropTarget) {
        return;
      }

      this._setDropTarget(null);

      if (this._dragTarget && dropTarget.dropPosition === _DragTarget2.default.DROP_BETWEEN) {
        var dragTarget = this._dragTarget;
        (0, _raf2.default)(function () {
          _this6.dataSource.performReorder(dragTarget, dropTarget, dropOperation, _this6._selection.getIndexPathSet());
        });
      } else {
        var items = null;

        // Ask the delegate to deserialize the drag data for us, otherwise try the default format
        if (this.delegate.itemsForDrop) {
          items = this.delegate.itemsForDrop(dropTarget, event.dataTransfer);
        } else {
          var json = event.dataTransfer.getData('CollectionViewData');
          items = json && JSON.parse(json);
        }

        if (!Array.isArray(items)) {
          return;
        }

        (0, _raf2.default)(function () {
          _this6.dataSource.performDrop(dropTarget, dropOperation, items);
        });
      }
    }

    // MARK: transactions

  }, {
    key: '_performTransaction',
    value: function _performTransaction(transaction) {
      // Copy selection so we can modify safely during the transaction
      transaction.selection = this._selection.copy();

      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performTransaction', this).call(this, transaction);

      // If the selection was modified, update the real one
      if (!transaction.selection.equals(this._selection)) {
        this._selection = transaction.selection;
        this._updateSelection();
      }
    }
  }, {
    key: '_performInsertItem',
    value: function _performInsertItem(item, indexPath) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performInsertItem', this).call(this, item, indexPath);
      this._transaction.selection.adjustForInsertionInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));
    }
  }, {
    key: '_performRemoveItem',
    value: function _performRemoveItem(indexPath) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performRemoveItem', this).call(this, indexPath);
      this._transaction.selection.adjustForDeletionInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));
    }
  }, {
    key: '_performMoveItem',
    value: function _performMoveItem(from, to) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performMoveItem', this).call(this, from, to);
      this._transaction.selection.adjustForMove(from, to);
    }
  }, {
    key: '_performInsertSection',
    value: function _performInsertSection(section, items) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performInsertSection', this).call(this, section, items);
      this._transaction.selection.adjustForInsertedSection(section);
    }
  }, {
    key: '_performRemoveSection',
    value: function _performRemoveSection(section) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performRemoveSection', this).call(this, section);
      this._transaction.selection.adjustForDeletedSection(section);
    }
  }, {
    key: '_performMoveSection',
    value: function _performMoveSection(fromSection, toSection) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performMoveSection', this).call(this, fromSection, toSection);
      this._transaction.selection.adjustForMovedSection(fromSection, toSection);
    }
  }, {
    key: '_performReloadSection',
    value: function _performReloadSection(section, items) {
      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performReloadSection', this).call(this, section, items);
      this._transaction.selection.adjustForReloadedSection(section);
    }

    // MARK: keyboard support

  }, {
    key: 'keyDown',
    value: function keyDown(event) {
      this.emit('keyDown', event);

      if (event.isDefaultPrevented && event.isDefaultPrevented()) {
        return;
      }

      switch (event.keyCode) {
        case 13: // enter
        case 32:
          // space
          event.preventDefault();
          this.selectItem(this._focusedIndexPath, event.metaKey || this.selectionMode === 'toggle', event.shiftKey);
          break;
        case 37:
          // left
          event.preventDefault();
          if (event.shiftKey) {
            return this.selectLeft();
          }

          return this.moveLeft();

        case 38:
          // up
          event.preventDefault();
          if (event.shiftKey) {
            return this.selectUp();
          }

          return this.moveUp();

        case 39:
          // right
          event.preventDefault();
          if (event.shiftKey) {
            return this.selectRight();
          }

          return this.moveRight();

        case 40:
          // down
          event.preventDefault();
          if (event.shiftKey) {
            return this.selectDown();
          }

          return this.moveDown();

        case 27:
          // escape
          event.preventDefault();
          return this.clearSelection();

        case 65:
          // A
          if (event.metaKey) {
            event.preventDefault();
            this.selectAll();
          }

          return;

        case 46: // delete
        case 8:
          // backspace
          if (this.canDeleteItems) {
            event.preventDefault();
          }
          return this.delete();
      }
    }
  }, {
    key: 'onFocus',
    value: function onFocus(event) {
      this.emit('focus', event);
      if (!this.backendView) {
        return;
      }

      var node = this.getDOMNode();
      if (node === event.target) {
        return;
      }

      // prevent scrollview from scrolling on focus
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && 'scrollTop' in node) {
        node.scrollTop = 0;
      }

      var focusedIndexPath = void 0;
      var restoringFocus = node === event.relatedTarget;

      if (restoringFocus) {
        focusedIndexPath = this._focusedIndexPath;
      } else {
        focusedIndexPath = this.indexPathAtDOMNode(event.target);
      }

      if (focusedIndexPath) {
        this._focusedIndexPath = focusedIndexPath;

        // Select if keyboardMode is selection, selectionMode is toggle, and selection has not already happened.
        if (this.keyboardMode === 'selection' && this.selectionMode === 'toggle' && this._selection.isEmpty) {
          this.selectItem(focusedIndexPath, false, false);
        }

        if (!restoringFocus) {
          this.scrollToItem(focusedIndexPath, SCROLLTOITEM_DURATION);
        }

        // update focused state and tabIndex for visible views
        this._updateVisibleViewStates();
      }
    }
  }, {
    key: 'onBlur',
    value: function onBlur(event) {
      this.emit('blur', event);
    }
  }, {
    key: 'scroll',
    value: function scroll(e) {
      var _this7 = this;

      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), 'scroll', this).call(this, e);
      var indexPath = this._focusedIndexPath;

      if (indexPath) {
        var view = this.getItemView(indexPath.section, indexPath.index);
        // if the focused item has scrolled out of view and no longer exists in DOM
        if (!view && this.attrs.tabIndex !== 0) {
          this.setAttribute('tabIndex', 0);
          // set focus to the collection view and make sure that it can still receive focus with the tab key
          this.focus();
        } else if (view && this.attrs.tabIndex !== -1) {
          // otherwise the collection view itself should not receive focus with the tab key,
          this.setAttribute('tabIndex', -1);
          // focus should be restored to the focused item
          (0, _raf2.default)(function () {
            return _this7.focusItem(indexPath);
          });
        }
      }
    }
  }, {
    key: '_moveSelection',
    value: function _moveSelection(method, indexPath) {
      var extend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var select = true;

      // If keyboardMode is focus, move the focused item instead of changing the selection.
      if (this._focusedIndexPath) {
        indexPath = this._focusedIndexPath;
      }

      if (this.keyboardMode === 'focus') {
        select = extend;
      }

      if (!indexPath) {
        return;
      }

      indexPath = this.layout[method](indexPath);
      if (select) {
        this.selectItem(indexPath, false, extend);
      }

      this.scrollToItem(indexPath, SCROLLTOITEM_DURATION);
      this.focusItem(indexPath);
    }

    /**
     * Selects the item above the currently selected one, replacing the existing selection.
     */

  }, {
    key: 'moveUp',
    value: function moveUp() {
      this._moveSelection('indexPathAbove', this._selection.firstIndexPath);
    }

    /**
     * Selects the item below the currently selected one, replacing the existing selection.
     */

  }, {
    key: 'moveDown',
    value: function moveDown() {
      this._moveSelection('indexPathBelow', this._selection.lastIndexPath);
    }

    /**
     * Selects the item to the left of the currently selected one, replacing the existing selection.
     */

  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      this._moveSelection('indexPathLeftOf', this._selection.firstIndexPath);
    }

    /**
     * Selects the item to the right of the currently selected one, replacing the existing selection.
     */

  }, {
    key: 'moveRight',
    value: function moveRight() {
      this._moveSelection('indexPathRightOf', this._selection.lastIndexPath);
    }

    /**
     * Selects the item above the currently selected one, extending the existing selection.
     */

  }, {
    key: 'selectUp',
    value: function selectUp() {
      this._moveSelection('indexPathAbove', this._selection.current, true);
    }

    /**
     * Selects the item below the currently selected one, extending the existing selection.
     */

  }, {
    key: 'selectDown',
    value: function selectDown() {
      this._moveSelection('indexPathBelow', this._selection.current, true);
    }

    /**
     * Selects the item to the left of the currently selected one, extending the existing selection.
     */

  }, {
    key: 'selectLeft',
    value: function selectLeft() {
      this._moveSelection('indexPathLeftOf', this._selection.current, true);
    }

    /**
     * Selects the item to the right of the currently selected one, extending the existing selection.
     */

  }, {
    key: 'selectRight',
    value: function selectRight() {
      this._moveSelection('indexPathRightOf', this._selection.current, true);
    }

    /**
     * Triggers a deletion of the currently selected items via the data source
     */

  }, {
    key: 'delete',
    value: function _delete() {
      var selectedIndexPaths = this.selectedIndexPaths;
      var shouldDelete = this.canDeleteItems && (!this.delegate.shouldDeleteItems || this.delegate.shouldDeleteItems(selectedIndexPaths));

      if (shouldDelete) {
        this.dataSource.removeItems(selectedIndexPaths);
      }
    }
  }, {
    key: 'selectedIndexPaths',
    get: function get() {
      return this._selection.getIndexPathSet();
    },
    set: function set(indexPaths) {
      if (!this.canSelectItems) {
        return;
      }
      this._selection.clear();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = indexPaths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var indexPath = _step3.value;

          this._selection.toggleIndexPath(indexPath);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._updateSelection(false);
    }

    /**
     * The currently selected IndexPath
     * @type {IndexPath}
     */

  }, {
    key: 'focusedIndexPath',
    get: function get() {
      return this._focusedIndexPath;
    }
  }]);

  return EditableCollectionView;
}(_CollectionView3.default);

exports.default = EditableCollectionView;