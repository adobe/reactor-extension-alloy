'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DropOperation = require('../DropOperation');

var _DropOperation2 = _interopRequireDefault(_DropOperation);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Map strings used by the HTML5 DnD API to our DropOperation constants.
var DROP_OPERATION = {
  none: _DropOperation2.default.NONE,
  move: _DropOperation2.default.MOVE,
  copy: _DropOperation2.default.COPY,
  link: _DropOperation2.default.LINK
};

// See https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed
var DROP_OPERATION_ALLOWED = Object.assign({}, DROP_OPERATION, {
  copyMove: _DropOperation2.default.COPY | _DropOperation2.default.MOVE,
  copyLink: _DropOperation2.default.COPY | _DropOperation2.default.LINK,
  linkMove: _DropOperation2.default.LINK | _DropOperation2.default.MOVE,
  all: _DropOperation2.default.ALL,
  uninitialized: _DropOperation2.default.ALL
});

var DROP_EFFECT = (0, _utils.invert)(DROP_OPERATION);
var EFFECT_ALLOWED = (0, _utils.invert)(DROP_OPERATION_ALLOWED);

var DragHandler = function () {
  function DragHandler() {
    _classCallCheck(this, DragHandler);

    this.mouseDown = this.mouseDown.bind(this);
    this.dragStart = this.dragStart.bind(this);
    this.dragOver = this.dragOver.bind(this);
    this.dragEnter = this.dragEnter.bind(this);
    this.dragLeave = this.dragLeave.bind(this);
    this.dragEnd = this.dragEnd.bind(this);
    this.drop = this.drop.bind(this);

    this.views = new Set();
    this.dragView = null;
    this.dragX = 0;
    this.dragY = 0;
    this.dropEffect = 'none';
    this.dragOverView = null;
    this.dragOverElements = new Set();
    this.hasSetupEvents = false;
    this.bodyIsDraggable = false;
  }

  _createClass(DragHandler, [{
    key: 'setupEvents',
    value: function setupEvents() {
      if (this.hasSetupEvents || typeof document === 'undefined') {
        return;
      }

      document.addEventListener('mousedown', this.mouseDown, false);
      document.addEventListener('dragstart', this.dragStart, false);
      document.addEventListener('dragover', this.dragOver, false);
      document.addEventListener('dragenter', this.dragEnter, false);
      document.addEventListener('dragleave', this.dragLeave, false);
      document.addEventListener('dragend', this.dragEnd, false);
      document.addEventListener('drop', this.drop, false);

      this.hasSetupEvents = true;
    }
  }, {
    key: 'teardownEvents',
    value: function teardownEvents() {
      if (!this.hasSetupEvents || typeof document === 'undefined') {
        return;
      }

      document.removeEventListener('mousedown', this.mouseDown, false);
      document.removeEventListener('dragstart', this.dragStart, false);
      document.removeEventListener('dragover', this.dragOver, false);
      document.removeEventListener('dragenter', this.dragEnter, false);
      document.removeEventListener('dragleave', this.dragLeave, false);
      document.removeEventListener('dragend', this.dragEnd, false);
      document.removeEventListener('drop', this.drop, false);

      this.bodyIsDraggable = false;
      this.hasSetupEvents = false;
    }
  }, {
    key: 'registerView',
    value: function registerView(view) {
      this.setupEvents();
      this.views.add(view);
    }
  }, {
    key: 'unregisterView',
    value: function unregisterView(view) {
      this.views.delete(view);
      if (this.views.size === 0) {
        this.teardownEvents();
      }
    }
  }, {
    key: 'containsPoint',
    value: function containsPoint(view, event) {
      var rect = view.getRect();
      return event.clientX >= rect.x && event.clientX <= rect.maxX && event.clientY >= rect.y && event.clientY <= rect.maxY;
    }
  }, {
    key: 'hitTest',
    value: function hitTest(event) {
      var possibleViews = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _view = _step.value;

          if (this.containsPoint(_view, event)) {
            possibleViews.push(_view);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (possibleViews.length > 1) {
        var innerView = null;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = possibleViews[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var view = _step2.value;

            if (innerView) {
              if (innerView.getDOMNode().contains(view.getDOMNode())) {
                innerView = view;
              }
            } else if (view.getDOMNode().contains(event.target)) {
              innerView = view;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return innerView;
      } else {
        return possibleViews[0] || null;
      }
    }
  }, {
    key: '_isElementChildOfCollectionView',
    value: function _isElementChildOfCollectionView(element) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.views[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var view = _step3.value;

          if (view.getDOMNode().contains(element)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }
  }, {
    key: 'mouseDown',
    value: function mouseDown(event) {
      // Firefox has problems focusing text fields if there are any draggable superviews
      var isTextInput = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable;

      var element = event.target;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.views[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var view = _step4.value;

          if (view.getDOMNode().contains(element)) {
            if (isTextInput) {
              view.removeAttribute('draggable');
            } else {
              view.setAttribute('draggable', 'true');
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: 'dragStart',
    value: function dragStart(event) {
      if (!this._isElementChildOfCollectionView(event.target)) {
        return;
      }

      var view = this.hitTest(event);
      if (!view) {
        event.preventDefault();
        return;
      }

      var allowedDropOperations = view.dragStart(event);
      if (!allowedDropOperations) {
        event.preventDefault();
        return;
      }

      this.dragView = view;
      event.dataTransfer.effectAllowed = EFFECT_ALLOWED[allowedDropOperations];
    }
  }, {
    key: 'setDragImage',
    value: function setDragImage(event, view) {
      if (!this._isElementChildOfCollectionView(event.target)) {
        return;
      }

      // Edge and IE Specific. Since, setDragImage function is not exposed in both.
      if (!event.dataTransfer.setDragImage) {
        return;
      }

      // In Firefox, the drag view must be within the viewport
      var mustBeInViewport = 'MozAppearance' in document.documentElement.style;

      var node = view.getDOMNode().cloneNode(true);
      node.classList.add('dragging');
      node.style.zIndex = -100;
      node.style.position = 'absolute';
      node.style.top = 0;
      node.style.left = mustBeInViewport ? 0 : '-100000px';
      node.style.padding = '10px';
      document.body.appendChild(node);

      var size = node.getBoundingClientRect();
      event.dataTransfer.setDragImage(node, size.width / 2, size.height / 2);

      setTimeout(function () {
        document.body.removeChild(node);
      }, 0);
    }
  }, {
    key: 'dragOver',
    value: function dragOver(event) {
      if (!this._isElementChildOfCollectionView(event.target)) {
        return;
      }

      event.preventDefault();

      if (event.clientX === this.dragX && event.clientY === this.dragY) {
        event.dataTransfer.dropEffect = this.dropEffect;
        return;
      }

      var allowedOperations = DROP_OPERATION_ALLOWED[event.dataTransfer.effectAllowed];

      var target = this.hitTest(event);
      if (target !== this.dragOverView) {
        if (this.dragOverView) {
          this.dragOverView.dragExited();
          this.dropEffect = 'none';
        }

        if (target) {
          var dropEffect = target.dragEntered(event, allowedOperations);
          this.dropEffect = DROP_EFFECT[dropEffect] || 'none';
          this.dragEnteredEffect = this.dropEffect;
        }

        this.dragOverView = target;
      }

      if (target && this.dragEnteredEffect !== 'none') {
        var _dropEffect = target.dragMoved(event, allowedOperations);
        if (_dropEffect != null) {
          this.dropEffect = DROP_EFFECT[_dropEffect] || 'none';
        }
      }

      event.dataTransfer.dropEffect = this.dropEffect;
      this.dragX = event.clientX;
      this.dragY = event.clientY;
    }
  }, {
    key: 'dragEnter',
    value: function dragEnter(event) {
      this.dragOverElements.add(event.target);
    }
  }, {
    key: 'dragLeave',
    value: function dragLeave(event) {
      this.dragOverElements.delete(event.target);
      if (this.dragOverElements.size === 0) {
        this.dragEnd(event);
      }
    }

    // dragEnd always gets called to remove drag animations
    // Does not require check to see if it's a collection-view as users can't drag more than one thing at a time
    // and probably wanna cancel their drag if they go outside the drag area anyways...

  }, {
    key: 'dragEnd',
    value: function dragEnd(event) {
      if (this.dragView) {
        this.dragView.dragEnd(event, DROP_OPERATION[event.dataTransfer.dropEffect]);
        this.dragView = null;
      }

      if (this.dragOverView) {
        this.dragOverView.dragExited();
        this.dragOverView = null;
      }

      this.dragX = 0;
      this.dragY = 0;
      this.dropEffect = 'none';
    }
  }, {
    key: 'drop',
    value: function drop(event) {
      if (!this._isElementChildOfCollectionView(event.target)) {
        return;
      }

      event.preventDefault();

      var target = this.dragOverView;
      if (!target) {
        target = this.hitTest(event);
      }

      if (!target) {
        return;
      }

      target.drop(event, DROP_OPERATION[this.dropEffect]);
      target.dragExited();

      this.dragOverView = null;
    }
  }]);

  return DragHandler;
}();

exports.default = new DragHandler();