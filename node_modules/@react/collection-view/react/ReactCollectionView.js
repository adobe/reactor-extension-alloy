'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableCollectionView = exports.CollectionView = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _src = require('../src');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ReactBackend = require('./ReactBackend');

var _ReactBackend2 = _interopRequireDefault(_ReactBackend);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _ReactReusableView = require('./ReactReusableView');

var _ReactReusableView2 = _interopRequireDefault(_ReactReusableView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionView = exports.CollectionView = createReactComponent(_src.CollectionView);
var EditableCollectionView = exports.EditableCollectionView = createReactComponent(_src.EditableCollectionView);

function createReactComponent(Super) {
  var Collection = function (_Super) {
    _inherits(Collection, _Super);

    function Collection(props) {
      _classCallCheck(this, Collection);

      var _this = _possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).call(this, props));

      _react2.default.Component.call(_this, props);

      _this.reactEvents = {};
      _this.backend = _ReactBackend2.default;
      _this.updateSize = _this.updateSize.bind(_this);

      if (props.className) {
        _this.addClass(props.className);
      }
      return _this;
    }

    _createClass(Collection, [{
      key: 'createView',
      value: function createView(type, section, index) {
        return new _ReactReusableView2.default(type);
      }
    }, {
      key: '_getDragViewFromDelegate',
      value: function _getDragViewFromDelegate(target, indexPaths) {
        if (this.delegate.renderDragView) {
          var view = new _src.ReusableView();
          var element = this.delegate.renderDragView(target, indexPaths);
          view.replaceChildren(element);
          return view;
        }
      }

      /**
       * Returns the IndexPath that the given React component represents.
       * Returns null if the view is not currently visible.
       * @param {ReactComponent} component
       * @return {IndexPath}
       */

    }, {
      key: 'indexPathForComponent',
      value: function indexPathForComponent(component) {
        return this.indexPathForView(component.props.reusableView);
      }

      /**
       * Returns the visible React component for the given section and index.
       * You can also pass an IndexPath as the only argument instead.
       * Returns null if the view is not currently visible.
       * @param {number|IndexPath} section
       * @param {number} index
       * @return {ReactComponent}
       */

    }, {
      key: 'componentForItem',
      value: function componentForItem(section, index) {
        var view = this.getItemView(section, index);
        return view && view.component;
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.updateSize(this.props);
        this.updateEvents(this.props);

        if (!this.props.width || !this.props.height) {
          window.addEventListener('resize', this.updateSize, false);
        }
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(props) {
        // This component should never re-render. All prop
        // changes are handled by componentWillReceiveProps.
        return false;
      }

      /**
       * Updates the size of the collection view.
       * By default, it will fill the containing dom node.
       * @param {object} props
       */

    }, {
      key: 'updateSize',
      value: function updateSize() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var dom = _reactDom2.default.findDOMNode(this);
        this.size = new _src.Size(props.width || dom.clientWidth, props.height || dom.clientHeight);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(props) {
        this.updateSize(props);

        // Update CSS class name
        if (props.className !== this.props.className) {
          if (this.props.className) {
            this.removeClass(this.props.className);
          }

          this.addClass(props.className);
        }

        this.updateAccessibilityAttributes(props);

        // Update CollectionView properties
        for (var key in props) {
          if (this[key] !== undefined && props[key] !== undefined && props[key] !== this[key]) {
            this[key] = props[key];
          }
        }

        // Update events
        this.updateEvents(props);
      }
    }, {
      key: 'eventName',
      value: function eventName(key) {
        return key.replace(/^on([A-Z])/, function (m, letter) {
          return letter.toLowerCase();
        });
      }
    }, {
      key: 'updateEvents',
      value: function updateEvents(props) {
        // Remove events that are no longer on the props
        for (var key in this.reactEvents) {
          if (!props[key]) {
            var event = this.eventName(key);
            this.removeListener(event, this.reactEvents[key]);
            delete this.reactEvents[key];
          }
        }

        // Replace/add events from the new props
        for (var _key in props) {
          if (/^on[A-Z]/.test(_key) && this.reactEvents[_key] !== props[_key]) {
            var _event = this.eventName(_key);

            // Remove old event if any
            if (this.reactEvents[_key]) {
              this.removeListener(_event, this.reactEvents[_key]);
              delete this.reactEvents[_key];
            }

            // Add new event, if it exists
            if (props[_key]) {
              this.on(_event, props[_key]);
              this.reactEvents[_key] = props[_key];
            }
          }
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._teardownEvents) {
          this._teardownEvents();
          window.removeEventListener('resize', this.updateSize, false);
        }
      }
    }]);

    return Collection;
  }(Super);

  // Make it into a React component by extending the prototype


  Collection.displayName = Super.name;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.getOwnPropertyNames(_react2.default.Component.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      Object.defineProperty(Collection.prototype, key, Object.getOwnPropertyDescriptor(_react2.default.Component.prototype, key));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return Collection;
}