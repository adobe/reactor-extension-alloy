"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _collectionView = require("@react/collection-view");

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _createId = _interopRequireDefault(require("../../utils/createId"));

var _events = require("events");

var _class;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ItemNode = (0, _autobindDecorator["default"])(_class =
/*#__PURE__*/
function () {
  function ItemNode(item, parent, hasChildren, index) {
    _classCallCheck(this, ItemNode);

    this.id = (0, _createId["default"])();
    this.item = item;
    this.children = null;
    this.hasChildren = hasChildren;
    this.parent = parent;
    this.isLoading = false;
    this.index = index;
    this.highlightedChild = null;
  }

  _createClass(ItemNode, [{
    key: "getItemId",
    value: function getItemId() {
      return "".concat(this.id, "-item");
    }
  }, {
    key: "getColumnId",
    value: function getColumnId() {
      return "".concat(this.id, "-column");
    }
  }, {
    key: "walk",
    value: function walk(fn) {
      if (!this.children) {
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children.sections[0][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          fn(child);
          child.walk(fn);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "updateChildIndices",
    value: function updateChildIndices() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var end = arguments.length > 1 ? arguments[1] : undefined;

      if (!this.children) {
        return;
      }

      if (end == null) {
        end = this.children.sections[0].length;
      }

      for (var i = start; i < end; i++) {
        this.children.sections[0][i].index = i;
      }
    }
  }]);

  return ItemNode;
}()) || _class;
/*
 * ColumnViewDataSource is the base class for data sources of a ColumnView.
 * There are two required methods that must be implemented by subclasses:
 * `getChildren`, and `hasChildren`.
 */


var ColumnViewDataSource =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(ColumnViewDataSource, _EventEmitter);

  function ColumnViewDataSource(dataSource) {
    var _this;

    _classCallCheck(this, ColumnViewDataSource);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColumnViewDataSource).call(this));
    _this.root = new ItemNode(null, null, false);
    _this.navigationStack = [];
    _this.lookup = new Map();
    _this.selectedItems = new Set();
    _this.dataSource = dataSource;

    if (dataSource && typeof dataSource.on === 'function') {
      dataSource.on('insertChild', _this.insertChild);
      dataSource.on('removeItem', _this.removeItem);
      dataSource.on('moveItem', _this.moveItem);
      dataSource.on('reloadItem', _this.reloadItem);
    }

    return _this;
  }

  _createClass(ColumnViewDataSource, [{
    key: "teardown",
    value: function teardown() {
      if (this.dataSource && typeof this.dataSource.removeListener === 'function') {
        this.dataSource.removeListener('insertChild', this.insertChild);
        this.dataSource.removeListener('removeItem', this.removeItem);
        this.dataSource.removeListener('moveItem', this.moveItem);
        this.dataSource.removeListener('reloadItem', this.reloadItem);
      }
    }
    /**
     * Returns an array of children for an item
     * @param {object} item
     * @return {object[]}
     * @abstract
     */

  }, {
    key: "getChildren",
    value: function () {
      var _getChildren = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(item) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.dataSource) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this.dataSource.getChildren(item));

              case 2:
                throw new Error('Must be implemented by subclass');

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getChildren(_x) {
        return _getChildren.apply(this, arguments);
      }

      return getChildren;
    }()
    /**
     * Returns whether an item has children
     * @param {object} item
     * @return {boolean}
     * @abstract
     */

  }, {
    key: "hasChildren",
    value: function hasChildren(item) {
      if (this.dataSource) {
        return this.dataSource.hasChildren(item);
      }

      throw new Error('Must be implemented by subclass');
    }
    /**
     * Navigates to an item by loading its children and showing them in a new column
     * @param {object} item
     */

  }, {
    key: "navigateToItem",
    value: function () {
      var _navigateToItem = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(item) {
        var _this2 = this;

        var parentNode, stack, node, children, childNodes;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                parentNode = this._lookupItem(item);

                if (!(!parentNode || this.navigationStack[this.navigationStack.length - 1] === parentNode)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                // Build the new navigation stack and immediately trigger a navigate
                // so that the columns to the right of the selected item are cleared while
                // the new column loads.
                stack = [];
                node = parentNode;

                while (node) {
                  stack.unshift(node);
                  node = node.parent;
                } // Store the highlighted child so that when we go away and come back from this column,
                // the same item will be highlighted.


                if (parentNode.parent) {
                  parentNode.parent.highlightedChild = parentNode.item;
                }

                this.navigationStack = stack;
                this.emit('navigate', stack.slice(1).map(function (i) {
                  return i.item;
                })); // Load children if needed

                if (parentNode.children) {
                  _context2.next = 24;
                  break;
                }

                parentNode.isLoading = true;

                this._reloadItem(parentNode);

                _context2.next = 14;
                return this.getChildren(parentNode.item);

              case 14:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 17;
                  break;
                }

                _context2.t0 = [];

              case 17:
                children = _context2.t0;
                childNodes = children.map(function (child, index) {
                  var node = new ItemNode(child, parentNode, _this2.hasChildren(child), index);

                  _this2.lookup.set(child, node);

                  return node;
                });
                parentNode.hasChildren = childNodes.length > 0;
                parentNode.children = new _collectionView.ArrayDataSource([childNodes]);
                parentNode.isLoading = false;

                this._reloadItem(parentNode);

                this.emit('navigate', stack.slice(1).map(function (i) {
                  return i.item;
                }));

              case 24:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function navigateToItem(_x2) {
        return _navigateToItem.apply(this, arguments);
      }

      return navigateToItem;
    }()
    /**
     * Navigates to the previous column
     */

  }, {
    key: "navigateToPrevious",
    value: function () {
      var _navigateToPrevious = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(this.navigationStack.length > 2)) {
                  _context3.next = 3;
                  break;
                }

                _context3.next = 3;
                return this.navigateToItem(this.navigationStack[this.navigationStack.length - 2].item);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function navigateToPrevious() {
        return _navigateToPrevious.apply(this, arguments);
      }

      return navigateToPrevious;
    }()
    /**
     * Navigates to the first child of the last column
     */

  }, {
    key: "navigateToNext",
    value: function () {
      var _navigateToNext = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var item;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                item = this.navigationStack[this.navigationStack.length - 1];

                if (!(item && item.hasChildren)) {
                  _context4.next = 4;
                  break;
                }

                _context4.next = 4;
                return this.navigateToItem(item.highlightedChild || item.children.getItem(0, 0).item);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function navigateToNext() {
        return _navigateToNext.apply(this, arguments);
      }

      return navigateToNext;
    }()
  }, {
    key: "setNavigatedPath",
    value: function () {
      var _setNavigatedPath = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(navigationPath) {
        var lastItem, index, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(this.navigationStack.length === 0)) {
                  _context5.next = 3;
                  break;
                }

                _context5.next = 3;
                return this.navigateToItem(null);

              case 3:
                // If last navigated item is the same, there is nothing to update.
                lastItem = navigationPath.length > 0 ? navigationPath[navigationPath.length - 1] : null;

                if (!(this.navigationStack[this.navigationStack.length - 1].item === lastItem)) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return");

              case 6:
                // Find the deepest already loaded item
                index = navigationPath.length - 1;

                while (index >= 0 && !this._lookupItem(navigationPath[index])) {
                  index--;
                }

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context5.prev = 11;
                _iterator2 = navigationPath.slice(index)[Symbol.iterator]();

              case 13:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context5.next = 22;
                  break;
                }

                item = _step2.value;

                if (this._lookupItem(item)) {
                  _context5.next = 17;
                  break;
                }

                return _context5.abrupt("break", 22);

              case 17:
                _context5.next = 19;
                return this.navigateToItem(item);

              case 19:
                _iteratorNormalCompletion2 = true;
                _context5.next = 13;
                break;

              case 22:
                _context5.next = 28;
                break;

              case 24:
                _context5.prev = 24;
                _context5.t0 = _context5["catch"](11);
                _didIteratorError2 = true;
                _iteratorError2 = _context5.t0;

              case 28:
                _context5.prev = 28;
                _context5.prev = 29;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 31:
                _context5.prev = 31;

                if (!_didIteratorError2) {
                  _context5.next = 34;
                  break;
                }

                throw _iteratorError2;

              case 34:
                return _context5.finish(31);

              case 35:
                return _context5.finish(28);

              case 36:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[11, 24, 28, 36], [29,, 31, 35]]);
      }));

      function setNavigatedPath(_x3) {
        return _setNavigatedPath.apply(this, arguments);
      }

      return setNavigatedPath;
    }()
  }, {
    key: "_lookupItem",
    value: function _lookupItem(parent) {
      if (!parent) {
        return this.root;
      }

      var node = this.lookup.get(parent);

      if (node) {
        return node;
      } // If nothing was found in the lookup, an equivalent object may exist with different object identity.
      // Search through the map to find one that matches the isItemEqual comparator.


      return this._findItem(this.lookup.values(), parent, function (node) {
        return node.item;
      });
    }
    /**
     * Returns whether the given item is in the navigation path
     * @param {object} item
     * @return {boolean}
     */

  }, {
    key: "isNavigated",
    value: function isNavigated(item) {
      var node = this._lookupItem(item);

      if (!node) {
        return false;
      }

      return this.navigationStack.includes(node);
    }
    /**
     * Returns the deepest-most leaf node in the navigation path.
     * @return {object}
     */

  }, {
    key: "getDetailNode",
    value: function getDetailNode() {
      var node = this.navigationStack[this.navigationStack.length - 1];

      if (node && !node.hasChildren) {
        return node;
      }

      return null;
    }
    /**
     * Returns the deepest-most leaf node in the navigation path
     * for display in the detail column.
     * @return {object}
     */

  }, {
    key: "getDetailItem",
    value: function getDetailItem() {
      var node = this.getDetailNode();

      if (node) {
        return node.item;
      }

      return null;
    }
  }, {
    key: "reloadItem",
    value: function reloadItem(item) {
      var node = this._lookupItem(item);

      this._reloadItem(node);
    }
  }, {
    key: "_reloadItem",
    value: function _reloadItem(node) {
      if (node && node.parent) {
        node.parent.children.emit('reloadItem', new _collectionView.IndexPath(0, node.index), false);
      }
    }
    /**
     * Adds the item to the selection set
     * @param {object} item
     */

  }, {
    key: "selectItem",
    value: function selectItem(item) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // Do nothing if this item is already selected.
      if (this.isSelected(item)) {
        return;
      }

      this.selectedItems.add(item);

      var node = this._lookupItem(item);

      if (node) {
        // Reload all parents in case they are e.g. displaying the selected child count
        while (node.parent !== null) {
          this._reloadItem(node);

          node = node.parent;
        }
      }

      if (emit) {
        this.emit('selectionChange', this.getSelection());
      }
    }
    /**
     * Removes the item from selection set
     * @param {object} item
     */

  }, {
    key: "deselectItem",
    value: function deselectItem(item) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // Find a selected item that matches this item using the comparator.
      var selectedItem = this._findSelectedItem(item);

      if (!selectedItem) {
        return;
      }

      this.selectedItems["delete"](selectedItem);

      var node = this._lookupItem(selectedItem);

      if (node) {
        // Reload all parents in case they are e.g. displaying the selected child count
        while (node.parent !== null) {
          this._reloadItem(node);

          node = node.parent;
        }
      }

      if (emit) {
        this.emit('selectionChange', this.getSelection());
      }
    }
    /**
     * Sets the selection state for the given items
     * @param {object[]} items
     * @param {boolean} selected
     */

  }, {
    key: "setSelected",
    value: function setSelected(items, selected) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;

          if (selected) {
            this.selectItem(item, false);
          } else {
            this.deselectItem(item, false);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.emit('selectionChange', this.getSelection());
    }
    /**
     * Replaces the selection with the given items
     * @param {object[]} items
     */

  }, {
    key: "replaceSelection",
    value: function replaceSelection(items) {
      this.selectedItems = new Set();
      this.setSelected(items, true);
    }
    /**
     * Removes all items from the selection set
     */

  }, {
    key: "clearSelection",
    value: function clearSelection() {
      this.setSelected(this.getSelection(), false);
    }
    /**
     * Return an array of selected objects
     * @return {object[]}
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return Array.from(this.selectedItems);
    }
    /**
     * Returns whether the item is in the selection set
     * @param {object} item
     * @return {boolean}
     */

  }, {
    key: "isSelected",
    value: function isSelected(item) {
      return !!this._findSelectedItem(item);
    }
  }, {
    key: "_findSelectedItem",
    value: function _findSelectedItem(item) {
      // If the selected items set has this item by object equality, just return it
      if (this.selectedItems.has(item)) {
        return item;
      } // Otherwise, find an item that matches the comparator


      return this._findItem(this.selectedItems, item);
    }
  }, {
    key: "_findItem",
    value: function _findItem(haystack, needle, getItem) {
      var isItemEqual = this.dataSource ? this.dataSource.isItemEqual : this.isItemEqual;

      if (typeof isItemEqual !== 'function') {
        return null;
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = haystack[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var node = _step4.value;
          var item = getItem ? getItem(node) : node;

          if (isItemEqual(item, needle)) {
            return node;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return null;
    }
    /**
     * Inserts a child into the given parent item.
     * @param {object} parent - The parent object to insert into
     * @param {number} index - The child insertion index
     * @param {object} child - The child to insert
     */

  }, {
    key: "insertChild",
    value: function insertChild(parent, index, child) {
      var parentNode = this._lookupItem(parent);

      if (!parentNode) {
        return;
      } // Make sure the disclosure indicator is correct


      if (!parentNode.hasChildren) {
        parentNode.hasChildren = true;

        this._reloadItem(parentNode);
      } // If the children have been loaded, insert the new child


      if (parentNode.children) {
        parentNode.children.startTransaction();
        var node = new ItemNode(child, parentNode, this.hasChildren(child), index);
        parentNode.children.insertItem(new _collectionView.IndexPath(0, index), node);
        parentNode.updateChildIndices(index + 1);
        this.lookup.set(child, node);
        parentNode.children.endTransaction();
      }
    }
    /**
     * Removes an item from the tree view.
     * @param {object} item - The item to remove
     */

  }, {
    key: "removeItem",
    value: function removeItem(item) {
      var _this3 = this;

      var node = this._lookupItem(item);

      if (!node) {
        return;
      }

      var parentNode = node.parent;

      if (!parentNode.children) {
        return;
      } // Remove the child


      parentNode.children.startTransaction();
      parentNode.children.removeItem(new _collectionView.IndexPath(0, node.index));
      parentNode.updateChildIndices(node.index);
      this.lookup["delete"](node.item);
      node.walk(function (child) {
        _this3.lookup["delete"](child.item);
      }); // Make sure the disclosure indicator is correct

      if (parentNode.children.sections[0].length === 0) {
        parentNode.hasChildren = false;

        this._reloadItem(parentNode);
      } // If the item is in the navigation path, navigate to the parent


      var stackIndex = this.navigationStack.indexOf(node);

      if (stackIndex >= 1) {
        this.navigateToItem(this.navigationStack[stackIndex - 1].item);
      } // Commit changes to UI


      parentNode.children.endTransaction();
    }
    /**
     * Moves an item to a new parent, or to a new index within the same parent
     * @param {object} fromParent - The item to move
     * @param {object} [toParent] - The parent item to move to. If not provided, the item is moved within the same parent.
     * @param {number} toIndex - The index to move the item to
     */

  }, {
    key: "moveItem",
    value: function moveItem(item, toParent, toIndex) {
      var node = this._lookupItem(item);

      if (!node) {
        return;
      }

      var fromNode = node.parent;

      if (!fromNode.children) {
        return;
      } // If only an index is provided, move within the same parent.


      if (typeof toParent === 'number') {
        toIndex = toParent;
        toParent = fromNode.item;
      } // If the destination node is not loaded, just remove the child from view.
      // It will get re-loaded from the new parent when the user navigates there.


      var toNode = this._lookupItem(toParent);

      if (!toNode) {
        return this.removeItem(item);
      }

      node.parent = toNode; // Move items and update indices of changed items

      if (fromNode === toNode) {
        fromNode.children.startTransaction();
        fromNode.children.moveItem(new _collectionView.IndexPath(0, node.index), new _collectionView.IndexPath(0, toIndex));
        fromNode.updateChildIndices(Math.min(node.index, toIndex), Math.max(node.index, toIndex) + 1);
      } else {
        fromNode.children.startTransaction();
        fromNode.children.removeItem(new _collectionView.IndexPath(0, node.index));
        fromNode.updateChildIndices(node.index); // If the destination node's children are loaded, insert the item.
        // Otherwise, the item will be re-loaded when the user navigates there.

        if (toNode.children) {
          toNode.children.startTransaction();
          toNode.children.insertItem(new _collectionView.IndexPath(0, toIndex), node);
          toNode.updateChildIndices(toIndex);
        }
      } // Reload both parents to ensure the disclosure indicators are correct


      if (fromNode.children.sections[0].length === 0) {
        fromNode.hasChildren = false;

        this._reloadItem(fromNode);
      }

      if (!toNode.hasChildren) {
        toNode.hasChildren = true;

        this._reloadItem(toNode);
      } // If the item is in the navigation path, navigate to the parent


      if (fromNode !== toNode) {
        var stackIndex = this.navigationStack.indexOf(node) - 1;

        if (stackIndex >= 0) {
          // If the destination node is a parent of the moved item, navigate to the parent.
          var toStackIndex = this.navigationStack.indexOf(toNode);

          if (toStackIndex >= 0 && toStackIndex < stackIndex) {
            stackIndex = toStackIndex;
          }

          this.navigateToItem(this.navigationStack[stackIndex].item);
        }
      } // Commit changes to UI


      fromNode.children.endTransaction();

      if (fromNode !== toNode && toNode.children) {
        toNode.children.endTransaction();
      }
    }
  }]);

  return ColumnViewDataSource;
}(_events.EventEmitter);

exports["default"] = ColumnViewDataSource;