"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _classnames = _interopRequireDefault(require("classnames"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _createId = _interopRequireDefault(require("../../utils/createId"));

var _focusRing = _interopRequireDefault(require("../../utils/focusRing"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _class, _class2, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

if (process.env.SCALE_MEDIUM && process.env.SCALE_LARGE) {
  require("../../spectrum-css/splitview/index.css");

  require("../../spectrum-css/splitview/index-diff.css");
} else if (process.env.SCALE_LARGE) {
  require("../../spectrum-css/splitview/index-lg.css");
} else {
  require("../../spectrum-css/splitview/index.css");
}

if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHT) require("../../spectrum-css/splitview/multiStops/light.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARK) require("../../spectrum-css/splitview/multiStops/dark.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHTEST) require("../../spectrum-css/splitview/multiStops/lightest.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARKEST) require("../../spectrum-css/splitview/multiStops/darkest.css");
var COLLAPSE_THREASHOLD = 50;
var ORIENTATIONS = {
  horizontal: 'width',
  vertical: 'height'
};
var CURSORS = {
  horizontal: {
    "default": 'ew-resize',
    min: ['e-resize', 'w-resize'],
    max: ['w-resize', 'e-resize']
  },
  vertical: {
    "default": 'ns-resize',
    min: ['s-resize', 'n-resize'],
    max: ['n-resize', 's-resize']
  }
};

var SplitView = (0, _convertUnsafeMethod["default"])(_class = (0, _autobindDecorator["default"])(_class = (0, _focusRing["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SplitView, _React$Component);

  function SplitView() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SplitView);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SplitView)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "primaryId", (0, _createId["default"])());

    _defineProperty(_assertThisInitialized(_this), "state", {
      dividerPosition: _this.props.primarySize === undefined ? _this.props.primaryDefault : _this.props.primarySize,
      hovered: false,
      dragging: false
    });

    return _this;
  }

  _createClass(SplitView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var children = _react["default"].Children.toArray(this.props.children);

      if (children.length !== 2) {
        throw new Error("SplitView must have 2 children, ".concat(children.length, " found."));
      }

      var _this$props = this.props,
          primaryPane = _this$props.primaryPane,
          orientation = _this$props.orientation,
          resizable = _this$props.resizable,
          className = _this$props.className,
          ariaLabel = _this$props['aria-label'],
          ariaLabelledby = _this$props['aria-labelledby'];
      var _this$state = this.state,
          dividerPosition = _this$state.dividerPosition,
          hovered = _this$state.hovered,
          dragging = _this$state.dragging,
          minPos = _this$state.minPos,
          maxPos = _this$state.maxPos;
      var dimension = ORIENTATIONS[orientation];
      var secondaryPane = Number(!primaryPane);

      var primary = _react["default"].createElement("div", {
        className: "spectrum-SplitView-pane",
        style: _defineProperty({}, dimension, dividerPosition),
        id: this.primaryId
      }, children[primaryPane]);

      var secondary = _react["default"].createElement("div", {
        className: "spectrum-SplitView-pane",
        style: {
          flex: 1
        }
      }, children[secondaryPane]);
      /**
       * Fix for:
       * ESLint warning:  Non-interactive elements should not be assigned mouse or keyboard event listeners jsx-a11y/no-noninteractive-element-interactions
       * ESLint error: The attribute aria-valuenow is not supported by the role separator jsx-a11y/role-supports-aria-props
       * ESLint error: The attribute aria-valuemin is not supported by the role separator jsx-a11y/role-supports-aria-props
       * ESLint error: The attribute aria-valuemax is not supported by the role separator jsx-a11y/role-supports-aria-props
       * ESLint error: `tabIndex` should only be declared on interactive elements jsx-a11y/no-noninteractive-tabindex
       */


      var splitterProps = {
        tabIndex: resizable ? 0 : null,
        'aria-valuenow': (dividerPosition - minPos) / (maxPos - minPos) * 100 | 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        'aria-controls': this.primaryId,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledby,
        'onKeyDown': this.onKeyDown
      };
      return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions
        _react["default"].createElement("div", {
          ref: function ref(r) {
            return _this2.container = r;
          },
          className: (0, _classnames["default"])('spectrum-SplitView', "spectrum-SplitView--".concat(orientation), className),
          onMouseMove: resizable ? this.onMouseMove : null,
          onMouseDown: resizable ? this.onMouseDown : null,
          onMouseLeave: resizable ? this.onMouseLeave : null
        }, primaryPane === 0 ? primary : secondary, _react["default"].createElement("div", _extends({
          className: (0, _classnames["default"])('spectrum-SplitView-splitter', {
            'is-draggable': resizable,
            'is-hovered': hovered,
            'is-active': dragging,
            'is-collapsed-start': dividerPosition === 0 && primaryPane === 0,
            'is-collapsed-end': dividerPosition === 0 && primaryPane === 1
          }),
          role: "separator"
        }, splitterProps), resizable ? _react["default"].createElement("div", {
          className: "spectrum-SplitView-gripper"
        }) : null), primaryPane === 1 ? primary : secondary)
      );
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('resize', this.resize, false);
      this.resize();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.resize, false);
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var primarySize = this.props.primarySize;

      if (nextProps.primarySize !== primarySize) {
        this.updatePosition(nextProps.primarySize === undefined ? nextProps.primaryDefault : nextProps.primarySize);
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e) {
      this._over = true;

      if (this.state.dragging) {
        return;
      }

      this.updateCursor(e);
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(e) {
      if (this.state.hovered) {
        if (this.props.onMouseDown) {
          this.props.onMouseDown();
        }

        if (this.props.primarySize !== undefined) {
          return;
        }

        window.addEventListener('mousemove', this.onMouseDragged, false);
        window.addEventListener('mouseup', this.onMouseUp, false);
        this.setState({
          dragging: true
        });
        this._offset = this.getOffset();
      }
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      var rect = this.container.getBoundingClientRect();
      return this.props.orientation === 'horizontal' ? rect.left : rect.top;
    }
  }, {
    key: "getPosition",
    value: function getPosition(e) {
      return this.props.orientation === 'horizontal' ? e.clientX : e.clientY;
    }
  }, {
    key: "onMouseDragged",
    value: function onMouseDragged(e) {
      if (!this.state.dragging) {
        return;
      }

      e.preventDefault();
      var _this$props2 = this.props,
          primaryPane = _this$props2.primaryPane,
          collapsible = _this$props2.collapsible;

      var pos = this.getPosition(e) - this._offset;

      if (primaryPane === 1) {
        pos = this._size - pos;
      }

      if (collapsible && pos < this.state.minPos - COLLAPSE_THREASHOLD) {
        pos = 0;
      }

      this.updatePosition(pos);
      this.updateCursor(e);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      if (!this.state.dragging) {
        return;
      }

      window.removeEventListener('mouseup', this.mouseUp, false);
      window.removeEventListener('mousemove', this.mouseDragged, false);
      this.setState({
        dragging: false
      });
      this.updateCursor(e);

      if (!this._over) {
        document.body.style.cursor = null;
      }

      if (this.props.onResizeEnd) {
        this.props.onResizeEnd(this.state.dividerPosition);
      }
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave() {
      this._over = false;
      this.setState({
        hovered: false
      });

      if (!this.state.dragging) {
        document.body.style.cursor = null;
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var _this3 = this;

      this._size = this.props.orientation === 'horizontal' ? this.container.offsetWidth : this.container.offsetHeight;
      var _this$props3 = this.props,
          primaryMin = _this$props3.primaryMin,
          primaryMax = _this$props3.primaryMax,
          secondaryMin = _this$props3.secondaryMin,
          secondaryMax = _this$props3.secondaryMax;
      this.setState({
        minPos: Math.max(primaryMin, this._size - secondaryMax),
        maxPos: Math.min(primaryMax, this._size - secondaryMin)
      }, function () {
        _this3.updatePosition(_this3.state.dividerPosition);
      });
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(x) {
      var isKeyboard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this._lastPosition = this.state.dividerPosition;
      var pos = Math.max(this.state.minPos, Math.min(this.state.maxPos, x));

      if (this.props.collapsible && x === 0) {
        pos = 0;
      }

      if (pos !== this.state.dividerPosition) {
        this.setState({
          dividerPosition: pos
        });

        if (this.props.onResize) {
          this.props.onResize(pos);
        }

        if (isKeyboard && this.props.onResizeEnd) {
          this.props.onResizeEnd(pos);
        }
      }
    }
  }, {
    key: "updateCursor",
    value: function updateCursor(e) {
      var over = this.state.dragging || this.dividerContainsPoint(this.getPosition(e));
      var wasOver = this.state.dragging ? false : this.state.hovered;

      if (!wasOver && over) {
        var _this$props4 = this.props,
            primaryPane = _this$props4.primaryPane,
            orientation = _this$props4.orientation;
        var cursors = CURSORS[orientation];
        var cursor = cursors["default"];

        if (this.state.dividerPosition <= this.state.minPos) {
          cursor = cursors.min[primaryPane];
        } else if (this.state.dividerPosition >= this.state.maxPos) {
          cursor = cursors.max[primaryPane];
        }

        this.setState({
          hovered: this._over
        });
        document.body.style.cursor = cursor;
      } else if (wasOver && !over) {
        this.setState({
          hovered: false
        });
        document.body.style.cursor = null;
      }
    }
  }, {
    key: "dividerContainsPoint",
    value: function dividerContainsPoint(x) {
      x -= this.getOffset();

      if (this.props.primaryPane === 1) {
        x = this._size - x;
      }

      var padding = 10;
      var d1 = this.state.dividerPosition - padding;
      var d2 = this.state.dividerPosition + padding;
      return x >= d1 && x <= d2;
    }
  }, {
    key: "decrement",
    value: function decrement(e) {
      e.preventDefault();
      this.updatePosition(this.state.dividerPosition + (this.props.primaryPane === 0 ? -10 : 10), true);
    }
  }, {
    key: "increment",
    value: function increment(e) {
      e.preventDefault();
      this.updatePosition(this.state.dividerPosition + (this.props.primaryPane === 0 ? 10 : -10), true);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (!this.props.resizable || this.props.primarySize !== undefined) {
        return;
      }

      var _this$props5 = this.props,
          orientation = _this$props5.orientation,
          collapsible = _this$props5.collapsible;

      switch (e.key) {
        case 'Left':
        case 'ArrowLeft':
          if (orientation === 'horizontal') {
            this.decrement(e);
          }

          break;

        case 'Up':
        case 'ArrowUp':
          if (orientation === 'vertical') {
            this.decrement(e);
          }

          break;

        case 'Right':
        case 'ArrowRight':
          if (orientation === 'horizontal') {
            this.increment(e);
          }

          break;

        case 'Down':
        case 'ArrowDown':
          if (orientation === 'vertical') {
            this.increment(e);
          }

          break;

        case 'Home':
          e.preventDefault();
          this.updatePosition(collapsible ? 0 : this.state.minPos, true);
          break;

        case 'End':
          e.preventDefault();
          this.updatePosition(this.state.maxPos, true);
          break;

        case 'Enter':
          if (collapsible) {
            e.preventDefault();
            this.updatePosition(this.state.dividerPosition === 0 ? this._lastPosition || this.state.minPos : 0, true);
          }

          break;
      }
    }
  }]);

  return SplitView;
}(_react["default"].Component), _defineProperty(_class2, "propTypes", {
  /** A custom class name to apply to the split view */
  className: _propTypes["default"].string,

  /** The orientation of the split view panes - horizontal or vertical */
  orientation: _propTypes["default"].oneOf(['horizontal', 'vertical']),

  /** Whether the split view is resizable */
  resizable: _propTypes["default"].bool,

  /** Whether the primary pane of the split view is collapsible */
  collapsible: _propTypes["default"].bool,

  /** A function that should be applied when the splitter is moused down */
  onMouseDown: _propTypes["default"].func,

  /** A function that should be applied when the split view is dragged */
  onResize: _propTypes["default"].func,

  /** A function that should be applied when dragging ends on the split view */
  onResizeEnd: _propTypes["default"].func,

  /** The child index of the primary pane of the split view. 0 by default, meaning either left or top depending on orientation. */
  primaryPane: _propTypes["default"].oneOf([0, 1]),

  /** The minimum size of the primary pane */
  primaryMin: _propTypes["default"].number,

  /** The maximum size of the primary pane */
  primaryMax: _propTypes["default"].number,

  /** The size of the primary pane */
  primarySize: _propTypes["default"].number,

  /** The default size of the primary pane */
  primaryDefault: _propTypes["default"].number,

  /** The minimum size of the secondary pane */
  secondaryMin: _propTypes["default"].number,

  /** The maximum size of the secondary pane */
  secondaryMax: _propTypes["default"].number
}), _defineProperty(_class2, "defaultProps", {
  orientation: 'horizontal',
  resizable: true,
  collapsible: false,
  primaryDefault: 304,
  primaryPane: 0,
  primaryMin: 304,
  primaryMax: Infinity,
  secondaryMin: 304,
  secondaryMax: Infinity
}), _temp)) || _class) || _class) || _class;

exports["default"] = SplitView;