"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _events = require("../../utils/events");

var _classnames = _interopRequireDefault(require("classnames"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _createId = _interopRequireDefault(require("../../utils/createId"));

var _Menu = require("../../Menu");

var _Overlay = _interopRequireDefault(require("../../OverlayTrigger/js/Overlay"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _scrollToDOMNode = _interopRequireDefault(require("../../utils/scrollToDOMNode"));

require("../style/index.css");

var _class, _class2, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getLabel = function getLabel(o) {
  return typeof o === 'string' ? o : o.label;
};

var LISTBOX = '-listbox';
var OPTION = '-option-';

var Autocomplete = (0, _convertUnsafeMethod["default"])(_class = (0, _autobindDecorator["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Autocomplete, _React$Component);

  function Autocomplete(props) {
    var _this;

    _classCallCheck(this, Autocomplete);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Autocomplete).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "state", {
      value: '',
      showMenu: false,
      results: [],
      selectedIndex: -1,
      isFocused: false
    });

    _this.autocompleteId = (0, _createId["default"])();
    return _this;
  }

  _createClass(Autocomplete, [{
    key: "UNSAFE_componentWillMount",
    value: function UNSAFE_componentWillMount() {
      this.UNSAFE_componentWillReceiveProps(this.props);
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(props) {
      if (props.value != null && props.value !== this.state.value) {
        this.setValue(props.value, this._selectedValue !== props.value);
        this._selectedValue = null;
      }

      if (props.showMenu != null && props.showMenu !== this.state.showMenu) {
        this.setState({
          showMenu: props.showMenu
        });
      } // Reset selectedIndex to -1 if menu is not shown to prevent invalid selection


      if (!props.showMenu) {
        this.setState({
          selectedIndex: -1
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateSize();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateSize();
    }
  }, {
    key: "updateSize",
    value: function updateSize() {
      if (this.wrapper) {
        var width = this.wrapper.offsetWidth;

        if (width !== this.state.width) {
          this.setState({
            width: width
          });
        }
      }
    }
  }, {
    key: "onChange",
    value: function onChange(value) {
      var onChange = this.props.onChange;

      if (onChange) {
        onChange(value);
      }

      if (!this.state.showMenu) {
        this.showMenu();
      }

      if (this.props.value == null) {
        this.setValue(value);
      }
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      var showMenu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.setState({
        value: value,
        showMenu: this.props.showMenu == null ? this.state.isFocused && showMenu : this.props.showMenu,
        selectedIndex: this.props.allowCreate && this.state.selectedIndex === -1 ? -1 : 0
      });
      this.getCompletions(value);
    }
  }, {
    key: "getCompletions",
    value: function () {
      var _getCompletions = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(value) {
        var _this2 = this;

        var results, getCompletions;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.optionIdPrefix = this.optionIdPrefix || this.autocompleteId + LISTBOX;
                this._value = value;
                results = [];
                getCompletions = this.props.getCompletions;

                if (!getCompletions) {
                  _context.next = 8;
                  break;
                }

                _context.next = 7;
                return getCompletions(value);

              case 7:
                results = _context.sent;

              case 8:
                if (!(this._value === value)) {
                  _context.next = 11;
                  break;
                }

                this.setState({
                  results: results
                }, function () {
                  var list = _reactDom["default"].findDOMNode(_this2.getListRef());

                  if (list) {
                    list.scrollTop = 0;
                  }
                });
                return _context.abrupt("return", results);

              case 11:
                return _context.abrupt("return", this.state.results);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getCompletions(_x) {
        return _getCompletions.apply(this, arguments);
      }

      return getCompletions;
    }()
  }, {
    key: "onSelect",
    value: function onSelect(value, event) {
      this._selectedValue = value;
      this.onChange(getLabel(value));
      this.hideMenu();

      if (this.props.onSelect) {
        this.props.onSelect(value, event);
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      this.setState({
        isFocused: true
      });

      if (this.props.onFocus) {
        this.props.onFocus(event);
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      if (this.wrapper && this.wrapper.contains(event.relatedTarget)) {
        // If the element receiving focus is a child of the Autocomplete,
        // for example the toggle button on a ComboBox,
        // do nothing in order prevent hideMenu from executing twice.
        return;
      }

      this.hideMenu();
      this.setState({
        isFocused: false
      });
    }
  }, {
    key: "onEscape",
    value: function onEscape(event) {
      event.preventDefault();
      this.hideMenu();
    }
  }, {
    key: "onSelectFocused",
    value: function onSelectFocused(event) {
      // Autocomplete should accept space key as text entry
      if (event.key === ' ') {
        return;
      }

      var _this$state = this.state,
          _this$state$results = _this$state.results,
          results = _this$state$results === void 0 ? [] : _this$state$results,
          selectedIndex = _this$state.selectedIndex;
      var value = results[selectedIndex];

      if (value) {
        event.preventDefault();
        this.onSelect(value, event);
      } else if (this.props.allowCreate) {
        if (event.key !== 'Tab') {
          event.preventDefault();
        }

        this.onSelect(this.state.value, event);
      }
    }
  }, {
    key: "onFocusFirst",
    value: function onFocusFirst(event) {
      event.preventDefault();
      this.selectIndex(0);
    }
  }, {
    key: "onFocusLast",
    value: function onFocusLast(event) {
      event.preventDefault();
      this.selectIndex(this.state.results.length - 1);
    }
  }, {
    key: "onFocusPrevious",
    value: function onFocusPrevious(event) {
      event.preventDefault();
      var _this$state2 = this.state,
          _this$state2$results = _this$state2.results,
          results = _this$state2$results === void 0 ? [] : _this$state2$results,
          selectedIndex = _this$state2.selectedIndex;
      var index = selectedIndex - 1;

      if (index < 0) {
        index = results.length - 1;
      }

      this.selectIndex(index);
    }
  }, {
    key: "onFocusNext",
    value: function onFocusNext(event) {
      event.preventDefault(); // make sure menu is shown

      if (!this.state.showMenu) {
        this.showMenu();
      }

      var _this$state3 = this.state,
          _this$state3$results = _this$state3.results,
          results = _this$state3$results === void 0 ? [] : _this$state3$results,
          selectedIndex = _this$state3.selectedIndex;
      var index = results.length ? (selectedIndex + 1) % results.length : 0;
      this.selectIndex(index);
    }
  }, {
    key: "onPageDown",
    value: function onPageDown(event) {
      event.preventDefault();
      var _this$state4 = this.state,
          _this$state4$results = _this$state4.results,
          results = _this$state4$results === void 0 ? [] : _this$state4$results,
          selectedIndex = _this$state4.selectedIndex,
          showMenu = _this$state4.showMenu;
      var len = results.length;

      if (!showMenu || !len) {
        return;
      }

      var listNode = _reactDom["default"].findDOMNode(this.getListRef());

      var items = _toConsumableArray(listNode.children);

      var targetItem = items[selectedIndex === -1 ? 0 : selectedIndex];
      var nextPage = Math.min(targetItem.offsetTop + listNode.clientHeight, listNode.scrollHeight + listNode.clientHeight);
      var index = items.indexOf(targetItem) + 1;
      var item = items.slice(index).find(function (item) {
        return item.offsetTop + item.offsetHeight > nextPage;
      });

      if (item) {
        this.selectIndex(items.indexOf(item), true);
      } else {
        this.onFocusLast(event);
      }
    }
  }, {
    key: "onPageUp",
    value: function onPageUp(event) {
      event.preventDefault();
      var _this$state5 = this.state,
          _this$state5$results = _this$state5.results,
          results = _this$state5$results === void 0 ? [] : _this$state5$results,
          selectedIndex = _this$state5.selectedIndex,
          showMenu = _this$state5.showMenu;
      var len = results.length;

      if (!showMenu || !len) {
        return;
      }

      var listNode = _reactDom["default"].findDOMNode(this.getListRef());

      var items = _toConsumableArray(listNode.children);

      var targetItem = items[selectedIndex === -1 ? 0 : selectedIndex];
      var nextPage = Math.max(targetItem.offsetTop + targetItem.offsetHeight - listNode.clientHeight, 0);
      var index = items.indexOf(targetItem);
      var item = items.slice(0, index).reverse().find(function (item) {
        return item.offsetTop < nextPage;
      });

      if (item) {
        this.selectIndex(items.indexOf(item));
      } else {
        this.onFocusFirst(event);
      }
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(index) {
      this.selectIndex(index);
    }
  }, {
    key: "onAltArrowDown",
    value: function onAltArrowDown(event) {
      event.preventDefault();

      if (!this.state.showMenu) {
        this.showMenu();
      }
    }
  }, {
    key: "onAltArrowUp",
    value: function onAltArrowUp(event) {
      event.preventDefault();

      if (this.state.showMenu) {
        this.hideMenu();
      }
    }
  }, {
    key: "onTab",
    value: function onTab(event) {
      this.onSelectFocused(event);
    }
  }, {
    key: "selectIndex",
    value: function selectIndex(selectedIndex, alignToStart) {
      var _this3 = this;

      this.setState({
        selectedIndex: selectedIndex
      }, function () {
        if (_this3.menu && !isNaN(selectedIndex) && selectedIndex !== -1) {
          // make sure that the selected item scrolls into view
          var list = _reactDom["default"].findDOMNode(_this3.getListRef());

          if (list) {
            var node = list.children[selectedIndex];

            if (node) {
              (0, _scrollToDOMNode["default"])(node, list, alignToStart);
            }
          }
        }
      });
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.state.showMenu) {
        this.hideMenu();
      } else {
        this.showMenu();
      }
    }
  }, {
    key: "showMenu",
    value: function () {
      var _showMenu = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this4 = this;

        var results, selectedIndex;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.props.showMenu == null) {
                  this.setState({
                    showMenu: true
                  });
                }

                this.setState({
                  selectedIndex: -1
                });
                _context2.next = 4;
                return this.getCompletions(this.state.value);

              case 4:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 7;
                  break;
                }

                _context2.t0 = [];

              case 7:
                results = _context2.t0;
                // Reset the selected index based on the value
                selectedIndex = results.findIndex(function (result) {
                  return getLabel(result) === _this4.state.value;
                });

                if (selectedIndex !== -1) {
                  this.setState({
                    selectedIndex: selectedIndex
                  });
                }

                if (this.props.onMenuShow) {
                  this.props.onMenuShow();
                }

                if (this.props.onMenuToggle) {
                  this.props.onMenuToggle(true);
                }

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function showMenu() {
        return _showMenu.apply(this, arguments);
      }

      return showMenu;
    }()
  }, {
    key: "hideMenu",
    value: function hideMenu() {
      if (this.props.showMenu == null) {
        this.setState({
          showMenu: false
        });
      }

      this.setState({
        selectedIndex: -1
      });

      if (this.props.onMenuHide) {
        this.props.onMenuHide();
      }

      if (this.props.onMenuToggle) {
        this.props.onMenuToggle(false);
      }
    }
  }, {
    key: "getActiveDescendantId",
    value: function getActiveDescendantId() {
      var _this$state6 = this.state,
          selectedIndex = _this$state6.selectedIndex,
          showMenu = _this$state6.showMenu,
          _this$state6$results = _this$state6.results,
          results = _this$state6$results === void 0 ? [] : _this$state6$results;
      return showMenu && results.length > 0 && selectedIndex !== -1 ? this.optionIdPrefix + OPTION + selectedIndex : undefined;
    }
  }, {
    key: "getListboxId",
    value: function getListboxId() {
      var _this$state7 = this.state,
          showMenu = _this$state7.showMenu,
          _this$state7$results = _this$state7.results,
          results = _this$state7$results === void 0 ? [] : _this$state7$results;
      return showMenu && results.length > 0 ? this.autocompleteId + LISTBOX : undefined;
    }
  }, {
    key: "getListRef",
    value: function getListRef() {
      return this.menu && this.menu.getListRef();
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props = this.props,
          id = _this$props.id,
          className = _this$props.className,
          renderItem = _this$props.renderItem,
          _this$props$ariaHasp = _this$props['aria-haspopup'],
          ariaHaspopup = _this$props$ariaHasp === void 0 ? 'listbox' : _this$props$ariaHasp;
      var _this$state8 = this.state,
          isFocused = _this$state8.isFocused,
          _this$state8$results = _this$state8.results,
          results = _this$state8$results === void 0 ? [] : _this$state8$results,
          selectedIndex = _this$state8.selectedIndex,
          showMenu = _this$state8.showMenu,
          value = _this$state8.value;

      var children = _react["default"].Children.toArray(this.props.children);

      var trigger = children.find(function (c) {
        return c.props.autocompleteInput;
      }) || children[0];
      var menuShown = showMenu && results.length > 0;
      var inputId = id || trigger.props.id || this.autocompleteId;
      return _react["default"].createElement("div", {
        className: (0, _classnames["default"])('react-spectrum-Autocomplete', {
          'is-focused': isFocused
        }, className),
        ref: function ref(w) {
          return _this5.wrapper = w;
        },
        role: "combobox",
        "aria-controls": this.getListboxId(),
        "aria-expanded": menuShown,
        "aria-haspopup": ariaHaspopup,
        "aria-owns": this.getListboxId()
      }, children.map(function (child) {
        if (child === trigger) {
          return _react["default"].cloneElement(child, {
            value: value,
            onChange: (0, _events.chain)(child.props.onChange, _this5.onChange),
            onKeyDown: (0, _events.chain)(child.props.onKeyDown, _events.interpretKeyboardEvent.bind(_this5)),
            onFocus: (0, _events.chain)(child.props.onFocus, _this5.onFocus),
            onBlur: (0, _events.chain)(child.props.onBlur, _this5.onBlur),
            id: inputId,
            autoComplete: 'off',
            'aria-activedescendant': _this5.getActiveDescendantId(),
            'aria-autocomplete': 'list',
            'aria-controls': _this5.getListboxId()
          });
        }

        return _react["default"].cloneElement(child, {
          onFocus: (0, _events.chain)(child.props.onFocus, _this5.onFocus),
          onBlur: (0, _events.chain)(child.props.onBlur, _this5.onBlur)
        });
      }), _react["default"].createElement(_Overlay["default"], {
        target: this.wrapper,
        show: menuShown,
        placement: "bottom left",
        role: "presentation"
      }, _react["default"].createElement(_Menu.Menu, {
        onSelect: this.onSelect,
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        },
        style: {
          width: this.state.width + 'px'
        },
        role: "listbox",
        ref: function ref(m) {
          return _this5.menu = m;
        },
        id: this.getListboxId(),
        trapFocus: false
      }, results.map(function (result, i) {
        var label = getLabel(result);
        return _react["default"].createElement(_Menu.MenuItem, {
          role: "option",
          id: _this5.optionIdPrefix + OPTION + i,
          tabIndex: selectedIndex === i ? 0 : -1,
          key: "item-".concat(i),
          value: result,
          icon: result.icon,
          focused: selectedIndex === i,
          selected: label === value,
          onMouseEnter: _this5.onMouseEnter.bind(_this5, i),
          onMouseDown: function onMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, renderItem ? renderItem(result) : label);
      }))));
    }
  }]);

  return Autocomplete;
}(_react["default"].Component), _defineProperty(_class2, "propTypes", {
  /**
   * Allows input that isn't part of the list of options
   */
  allowCreate: _propTypes["default"].bool,

  /**
   * Value of the input, this puts the autocomplete in a controlled mode.
   */
  value: _propTypes["default"].string,

  /**
   * Callback for when value changes due to selection
   */
  onSelect: _propTypes["default"].func,

  /**
   * String for extra class names to add to the top level div
   */
  className: _propTypes["default"].string,

  /**
   * String that will override the default id generated by the instance
   */
  id: _propTypes["default"].string,

  /**
   * Callback for when the menu opens
   */
  onMenuShow: _propTypes["default"].func,

  /**
   * Callback for when the menu closes
   */
  onMenuHide: _propTypes["default"].func,

  /**
   * A callback for both show and hide, event is false if hiding, true if showing.
   * Reason for this was to add a controlled state in a backwards compatible way,
   * we couldn't use show/hide props for that, so we needed a new one.
   */
  onMenuToggle: _propTypes["default"].func,

  /**
   * Controlled state for showing/hiding menu.
   */
  showMenu: _propTypes["default"].bool,

  /**
   * A function that returns a wrapper component to render a list item label.
   * Useful in providing custom html to the rendered label.
   */
  renderItem: _propTypes["default"].func,

  /**
   * A function that returns the items to be displayed in the menu.
   * Called when the user types in the textfield.
   */
  getCompletions: _propTypes["default"].func.isRequired
}), _defineProperty(_class2, "defaultProps", {
  allowCreate: false
}), _temp)) || _class) || _class;

exports["default"] = Autocomplete;