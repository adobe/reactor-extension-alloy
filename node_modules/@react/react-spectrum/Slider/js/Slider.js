"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _number = require("../../utils/number");

var _classnames = _interopRequireDefault(require("classnames"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _createId = _interopRequireDefault(require("../../utils/createId"));

var _intl = require("../../utils/intl");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _class, _class2, _temp;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var intlMessages = {
  "cs-CZ": _interopRequireDefault(require("./../intl/cs-CZ.json"))["default"],
  "da-DK": _interopRequireDefault(require("./../intl/da-DK.json"))["default"],
  "de-DE": _interopRequireDefault(require("./../intl/de-DE.json"))["default"],
  "en-US": _interopRequireDefault(require("./../intl/en-US.json"))["default"],
  "es-ES": _interopRequireDefault(require("./../intl/es-ES.json"))["default"],
  "fi-FI": _interopRequireDefault(require("./../intl/fi-FI.json"))["default"],
  "fr-FR": _interopRequireDefault(require("./../intl/fr-FR.json"))["default"],
  "hu-HU": _interopRequireDefault(require("./../intl/hu-HU.json"))["default"],
  "it-IT": _interopRequireDefault(require("./../intl/it-IT.json"))["default"],
  "ja-JP": _interopRequireDefault(require("./../intl/ja-JP.json"))["default"],
  "ko-KR": _interopRequireDefault(require("./../intl/ko-KR.json"))["default"],
  "nb-NO": _interopRequireDefault(require("./../intl/nb-NO.json"))["default"],
  "nl-NL": _interopRequireDefault(require("./../intl/nl-NL.json"))["default"],
  "pl-PL": _interopRequireDefault(require("./../intl/pl-PL.json"))["default"],
  "pt-BR": _interopRequireDefault(require("./../intl/pt-BR.json"))["default"],
  "ru-RU": _interopRequireDefault(require("./../intl/ru-RU.json"))["default"],
  "sv-SE": _interopRequireDefault(require("./../intl/sv-SE.json"))["default"],
  "tr-TR": _interopRequireDefault(require("./../intl/tr-TR.json"))["default"],
  "uk-UA": _interopRequireDefault(require("./../intl/uk-UA.json"))["default"],
  "zh-CN": _interopRequireDefault(require("./../intl/zh-CN.json"))["default"],
  "zh-TW": _interopRequireDefault(require("./../intl/zh-TW.json"))["default"]
};

if (process.env.SCALE_MEDIUM && process.env.SCALE_LARGE) {
  require("../../spectrum-css/slider/index.css");

  require("../../spectrum-css/slider/index-diff.css");
} else if (process.env.SCALE_LARGE) {
  require("../../spectrum-css/slider/index-lg.css");
} else {
  require("../../spectrum-css/slider/index.css");
}

if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHT) require("../../spectrum-css/slider/multiStops/light.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARK) require("../../spectrum-css/slider/multiStops/dark.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHTEST) require("../../spectrum-css/slider/multiStops/lightest.css");
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARKEST) require("../../spectrum-css/slider/multiStops/darkest.css");
var formatMessage = (0, _intl.messageFormatter)(intlMessages);
var INPUT_POSTFIX = 'Input';
var LABEL_POSTFIX = '-label';
var STYLE_KEY = {
  FILL: {
    horizontal: 'width',
    vertical: 'height'
  },
  OFFSET: {
    horizontal: 'left',
    vertical: 'bottom'
  },
  OPPOSITE_OFFSET: {
    horizontal: 'right',
    vertical: 'top'
  }
};

var Slider = (0, _convertUnsafeMethod["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    var _this;

    _classCallCheck(this, Slider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Slider).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "state", {
      startValue: null,
      endValue: null,
      draggingHandle: null,
      focusedHandle: null
    });

    _defineProperty(_assertThisInitialized(_this), "findNearestHandle", function (pageX, pageY) {
      var closestDistance = Infinity; // Incredible large start value

      var closestHandle = 'startHandle';
      var handles = ['startHandle', 'endHandle']; // if variant is not range always return focused handle

      if (_this.props.variant !== 'range') {
        return closestHandle;
      } // Find the nearest handle


      handles.forEach(function (handle) {
        var rect = _this[handle + INPUT_POSTFIX].getBoundingClientRect();

        var top = rect.top + window.pageYOffset;
        var left = rect.left + window.pageXOffset;
        var distance = Math.floor(Math.sqrt(Math.pow(pageX - (left + rect.width / 2), 2) + Math.pow(pageY - (top + rect.height / 2), 2)));

        if (distance < closestDistance) {
          closestDistance = distance;
          closestHandle = handle;
        }
      });
      return closestHandle;
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function (e, sliderHandle) {
      if (!sliderHandle) {
        sliderHandle = _this.findNearestHandle(e.pageX, e.pageY);
      } else {
        // stop propagation of event up to .spectrum-Slider-controls
        e.stopPropagation();
      }

      var input = _this[sliderHandle + INPUT_POSTFIX];

      if (input) {
        input.focus();
      } // persist event for use after state change


      e.persist();

      _this.setState({
        sliderHandle: null,
        isMouseUp: false,
        draggingHandle: sliderHandle
      }, function () {
        return _this.onMouseMove(e);
      });

      window.addEventListener('mouseup', _this.onMouseUp);
      window.addEventListener('mousemove', _this.onMouseMove);
      document.body.classList.add(_this.isDraggedBodyClassName);
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function (e) {
      var draggingHandle = _this.state.draggingHandle;
      var input = draggingHandle && _this[draggingHandle + INPUT_POSTFIX]; // Blur the input so that focused styling is removed with mouse/touch interaction.

      if (input) {
        input.blur();
      }

      _this.setState({
        isMouseUp: true,
        draggingHandle: null
      }, function () {
        // Restore focus to the input so that keyboard interaction will continue to work.
        if (input) {
          input.focus();
        }
      });

      if (_this.props.onChangeEnd) {
        if (_this.props.variant === 'range') {
          _this.props.onChangeEnd(_this.state.startValue, _this.state.endValue);
        } else {
          _this.props.onChangeEnd(_this.state.startValue);
        }
      }

      window.removeEventListener('mouseup', _this.onMouseUp);
      window.removeEventListener('mousemove', _this.onMouseMove);
      document.body.classList.remove(_this.isDraggedBodyClassName);
    });

    _defineProperty(_assertThisInitialized(_this), "calculateHandlePosition", function (e) {
      var _this$props = _this.props,
          min = _this$props.min,
          max = _this$props.max,
          orientation = _this$props.orientation,
          step = _this$props.step;
      var vertical = orientation === 'vertical';

      var rect = _this.dom.getBoundingClientRect();

      var minOffset = vertical ? rect.top : rect.left;
      var offset = vertical ? e.clientY : e.clientX;
      var size = vertical ? rect.height : rect.width; // Compute percentage

      var percent = (offset - minOffset) / size;
      percent = (0, _number.clamp)(percent, 0, 1);

      if (vertical) {
        percent = 1 - percent;
      } // Compute real value based in min and max, and snap to nearest step.


      var value = min + (max - min) * percent;

      if (step) {
        value = Math.round(value / step) * step;
      }

      return value;
    });

    _defineProperty(_assertThisInitialized(_this), "getHandleValues", function (value, step) {
      var _this$state = _this.state,
          draggingHandle = _this$state.draggingHandle,
          startValue = _this$state.startValue,
          endValue = _this$state.endValue;

      if (draggingHandle === 'startHandle') {
        startValue = value;
      }

      if (draggingHandle === 'endHandle') {
        endValue = value;
      }

      step = !step ? 1 : step;

      if (+startValue + step > endValue) {
        return [_this.state.startValue, _this.state.endValue];
      } else {
        return [startValue, endValue];
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseMove", function (e) {
      e.preventDefault();

      var value = _this.calculateHandlePosition(e);

      if (_this.props.variant === 'range') {
        var _this$getHandleValues = _this.getHandleValues(value, _this.props.step),
            _this$getHandleValues2 = _slicedToArray(_this$getHandleValues, 2),
            startValue = _this$getHandleValues2[0],
            endValue = _this$getHandleValues2[1];

        _this.updateValues(startValue, endValue, _this.state.draggingHandle);
      } else {
        _this.updateValues(value, null, 'startHandle');
      }
    });

    _defineProperty(_assertThisInitialized(_this), "updateValues", function (startValue) {
      var endValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sliderHandle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var _this$props2 = _this.props,
          min = _this$props2.min,
          max = _this$props2.max,
          step = _this$props2.step,
          variant = _this$props2.variant,
          onChange = _this$props2.onChange;
      startValue = (0, _number.snapValueToStep)(startValue, min, max, step);

      if (variant === 'range') {
        endValue = (0, _number.snapValueToStep)(endValue, min, max, step);

        if (onChange && (startValue !== _this.state.startValue || endValue !== _this.state.endValue)) {
          onChange(startValue, endValue);
        }

        if (_this.props.startValue == null && _this.props.endValue == null) {
          _this.setState({
            startValue: startValue,
            endValue: endValue,
            focusedHandle: !_this.state.isMouseUp ? sliderHandle : null
          });
        }
      } else {
        if (onChange && startValue !== _this.state.startValue) {
          onChange(startValue);
        } // If value is not set in props (uncontrolled component), set state


        if (_this.props.value == null) {
          _this.setState({
            startValue: startValue,
            focusedHandle: !_this.state.isMouseUp ? sliderHandle : null
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onChange", function (e, sliderHandle) {
      var _this$props3 = _this.props,
          step = _this$props3.step,
          variant = _this$props3.variant;
      var _this$state2 = _this.state,
          startValue = _this$state2.startValue,
          endValue = _this$state2.endValue;
      var isStartHandle = sliderHandle === 'startHandle';
      var value = isStartHandle ? startValue : endValue;
      var inputValue = +e.target.value;

      if (inputValue !== value) {
        if (variant === 'range') {
          _this.setState({
            draggingHandle: sliderHandle
          }, function () {
            var _this$getHandleValues3 = _this.getHandleValues(inputValue, step),
                _this$getHandleValues4 = _slicedToArray(_this$getHandleValues3, 2),
                startValue = _this$getHandleValues4[0],
                endValue = _this$getHandleValues4[1];

            _this.updateValues(startValue, endValue, sliderHandle);

            _this.setState({
              draggingHandle: null
            });
          });
        } else {
          _this.updateValues(inputValue, null, sliderHandle);
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onFocus", function (e, sliderHandle) {
      _this.setState({
        focusedHandle: !_this.state.isMouseUp ? sliderHandle : null,
        topHandle: sliderHandle,
        isMouseUp: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onBlur", function (e, sliderHandle) {
      _this.setState({
        focusedHandle: null
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onClickSliderValue", function (e) {
      var selection = window.getSelection();
      var sliderHandle = 'startHandle';
      /* Clicking the portion of the slider value text label after the en-dash character should move focus to the endHandle. */

      if (_this.props.variant === 'range' && selection.focusOffset > e.target.textContent.indexOf('–')) {
        sliderHandle = 'endHandle';
      }

      _this[sliderHandle + INPUT_POSTFIX].focus();
    });

    _defineProperty(_assertThisInitialized(_this), "getAriaLabelledby", function () {
      var sliderHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var _this$props4 = _this.props,
          label = _this$props4.label,
          ariaLabelledby = _this$props4['aria-labelledby'],
          ariaLabel = _this$props4['aria-label'];
      var ids = [];

      if (ariaLabelledby) {
        ids.push(ariaLabelledby);
      }

      if (label || ariaLabel) {
        ids.push(_this.getLabelId());
      }

      if (sliderHandle) {
        ids.push(_this.getSliderHandleInputId(sliderHandle));
      }

      return ids.join(' ');
    });

    _defineProperty(_assertThisInitialized(_this), "renderSliderHandle", function (sliderHandle) {
      var _this$props5 = _this.props,
          disabled = _this$props5.disabled,
          max = _this$props5.max,
          min = _this$props5.min,
          orientation = _this$props5.orientation,
          step = _this$props5.step,
          variant = _this$props5.variant,
          ariaLabel = _this$props5['aria-label'],
          ariaDescribedby = _this$props5['aria-describedby'],
          getAriaValueText = _this$props5.getAriaValueText;
      var _this$state3 = _this.state,
          draggingHandle = _this$state3.draggingHandle,
          focusedHandle = _this$state3.focusedHandle,
          topHandle = _this$state3.topHandle,
          startValue = _this$state3.startValue,
          endValue = _this$state3.endValue;
      var isStartHandle = sliderHandle === 'startHandle';
      var value = isStartHandle ? startValue : endValue;
      var percent = (value - min) / (max - min);
      var isRange = variant === 'range';
      var isVertical = orientation === 'vertical';
      var isDragged = draggingHandle === sliderHandle;
      var isFocused = focusedHandle === sliderHandle;
      var isTopHandle = topHandle === sliderHandle;
      var styleKey = STYLE_KEY.OFFSET[orientation];
      var labelString = isStartHandle ? formatMessage('minimum') : formatMessage('maximum');
      var ariaValueMin = null;
      var ariaValueMax = null;

      if (isRange) {
        ariaLabel = labelString;
        ariaValueMin = isStartHandle ? min : startValue;
        ariaValueMax = isStartHandle ? endValue : max;
      }

      return _react["default"].createElement("div", {
        className: (0, _classnames["default"])('spectrum-Slider-handle', {
          'is-dragged': isDragged,
          'is-focused': isFocused,
          'is-tophandle': isTopHandle
        }),
        onMouseDown: !disabled && isRange ? function (e) {
          return _this.onMouseDown(e, sliderHandle);
        } : null,
        style: _defineProperty({}, styleKey, percent * 100 + '%'),
        role: "presentation"
      }, _react["default"].createElement("input", {
        id: _this.getSliderHandleInputId(sliderHandle),
        ref: function ref(i) {
          return _this[sliderHandle + INPUT_POSTFIX] = i;
        },
        type: "range",
        className: "spectrum-Slider-input",
        step: step,
        max: max,
        min: min,
        disabled: disabled,
        "aria-orientation": isVertical ? orientation : null,
        "aria-label": ariaLabel || null,
        "aria-labelledby": _this.getAriaLabelledby(isRange ? sliderHandle : null),
        "aria-describedby": ariaDescribedby,
        "aria-valuemin": ariaValueMin,
        "aria-valuemax": ariaValueMax,
        "aria-valuetext": getAriaValueText(value),
        defaultValue: undefined,
        value: value,
        onChange: !disabled ? function (e) {
          return _this.onChange(e, sliderHandle);
        } : null,
        onFocus: !disabled ? function (e) {
          return _this.onFocus(e, sliderHandle);
        } : null,
        onBlur: !disabled ? function (e) {
          return _this.onBlur(e, sliderHandle);
        } : null
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "setDOMReference", function (d) {
      return _this.dom = d;
    });

    _this.sliderId = (0, _createId["default"])();
    return _this;
  }

  _createClass(Slider, [{
    key: "UNSAFE_componentWillMount",
    value: function UNSAFE_componentWillMount() {
      this.UNSAFE_componentWillReceiveProps(this.props);
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(props) {
      // For range slider
      if (props.variant === 'range') {
        var startValue = props.startValue == null ? props.defaultStartValue : props.startValue;
        var endValue = props.endValue == null ? props.defaultEndValue : props.endValue;

        if (startValue == null && (this.state.startValue == null || this.props.min !== props.min)) {
          startValue = props.min;
        }

        if (endValue == null && (this.state.endValue == null || this.props.max !== props.max)) {
          endValue = props.max;
        }

        if (startValue != null && endValue != null) {
          this.setState({
            startValue: startValue,
            endValue: endValue
          });
        }
      } else {
        // For single slider
        var _startValue = props.value == null ? props.defaultValue : props.value;

        if (_startValue == null && (this.state.startValue == null || this.props.max !== props.max || this.props.min !== props.min)) {
          _startValue = props.min + (props.max - props.min) / 2;
        }

        if (_startValue != null) {
          this.setState({
            startValue: _startValue
          });
        }
      }

      this.isDraggedBodyClassName = 'u-isGrabbing';
    }
    /**
     * Finds the nearest handle based on X/Y coordinates
     *  @private
     */

  }, {
    key: "getLabelId",
    value: function getLabelId() {
      return this.sliderId + LABEL_POSTFIX;
    }
  }, {
    key: "getSliderHandleInputId",
    value: function getSliderHandleInputId(sliderHandle) {
      var _this$props$id = this.props.id,
          id = _this$props$id === void 0 ? this.sliderId : _this$props$id;
      return sliderHandle === 'startHandle' ? id : id + '-' + sliderHandle + INPUT_POSTFIX;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this,
          _ref3,
          _ref5;

      var _this$props6 = this.props,
          children = _this$props6.children,
          disabled = _this$props6.disabled,
          filled = _this$props6.filled,
          fillOffset = _this$props6.fillOffset,
          _this$props6$id = _this$props6.id,
          id = _this$props6$id === void 0 ? this.sliderId : _this$props6$id,
          label = _this$props6.label,
          max = _this$props6.max,
          min = _this$props6.min,
          orientation = _this$props6.orientation,
          renderLabel = _this$props6.renderLabel,
          variant = _this$props6.variant,
          ariaLabel = _this$props6['aria-label'],
          getAriaValueText = _this$props6.getAriaValueText,
          otherProps = _objectWithoutProperties(_this$props6, ["children", "disabled", "filled", "fillOffset", "id", "label", "max", "min", "orientation", "renderLabel", "variant", "aria-label", "getAriaValueText"]);

      var _this$state4 = this.state,
          startValue = _this$state4.startValue,
          endValue = _this$state4.endValue;
      var isRamp = variant === 'ramp';
      var isRange = variant === 'range';
      var isVertical = orientation === 'vertical';
      var sliderClasses = (0, _classnames["default"])('spectrum-Slider', this.props.className, {
        'spectrum-Slider--vertical': isVertical,
        'spectrum-Slider--ramp': isRamp,
        'spectrum-Slider--range': isRange,
        'spectrum-Slider--filled': filled && !fillOffset,
        'is-disabled': disabled
      });
      var shouldRenderLabel = renderLabel && label;
      var ariaLabelledby = this.getAriaLabelledby();
      var labelValue = isRange ? "".concat(getAriaValueText(startValue), "\u2013").concat(getAriaValueText(endValue)) : getAriaValueText(startValue);
      var delta = isRange ? endValue - startValue : startValue - min;
      var valueRange = max - min;
      var percent = delta / valueRange;
      var styleKeyFill = STYLE_KEY.FILL[orientation];
      var styleKeyOffset = STYLE_KEY.OFFSET[orientation];
      var styleKeyOppositeOffset = STYLE_KEY.OPPOSITE_OFFSET[orientation];
      var startPercent = (startValue - min) / (max - min);
      var endPercent = (endValue - min) / (max - min);
      var fillOffsetPercent = (fillOffset - min) / (max - min);
      var minFillPercent = Math.min(startPercent, fillOffsetPercent);
      var maxFillPercent = Math.max(startPercent, fillOffsetPercent);

      if (isRamp) {
        children = null;
      } // Range slider should always be filled


      if (isRange && !filled) {
        filled = true;
      }

      return _react["default"].createElement("div", {
        className: sliderClasses,
        ref: this.setDOMReference,
        role: isRange ? 'group' : 'presentation',
        "aria-labelledby": isRange ? ariaLabelledby : null
      }, (shouldRenderLabel || label && ariaLabelledby || ariaLabel) && _react["default"].createElement("div", {
        className: "spectrum-Slider-labelContainer"
      }, _react["default"].createElement("label", {
        id: this.getLabelId(),
        className: "spectrum-Slider-label",
        htmlFor: id,
        hidden: !shouldRenderLabel || null,
        "aria-label": !otherProps['aria-labelledby'] ? ariaLabel : null
      }, label), shouldRenderLabel &&
      /* eslint-disable-next-line jsx-a11y/click-events-have-key-events */
      _react["default"].createElement("div", {
        className: "spectrum-Slider-value",
        style: {
          outline: 0
        },
        role: "textbox",
        tabIndex: -1,
        "aria-readonly": "true",
        "aria-labelledby": ariaLabelledby,
        onClick: !disabled ? function (e) {
          return _this2.onClickSliderValue(e);
        } : null
      }, labelValue)), _react["default"].createElement("div", {
        className: "spectrum-Slider-controls",
        role: "presentation",
        onMouseDown: !disabled ? function (e) {
          return _this2.onMouseDown(e);
        } : null
      }, !isRamp && _react["default"].createElement("div", {
        className: "spectrum-Slider-track",
        role: "presentation",
        style: _defineProperty({}, styleKeyFill, (isRange ? startPercent : percent) * 100 + '%')
      }), isRamp && _react["default"].createElement("div", {
        className: "spectrum-Slider-ramp"
      }, _react["default"].createElement("svg", {
        width: "100%",
        viewBox: "0 0 240 16",
        preserveAspectRatio: "none",
        "aria-hidden": "true",
        focusable: "false"
      }, _react["default"].createElement("path", {
        d: "M240,4v8c0,2.3-1.9,4.1-4.2,4L1,9C0.4,9,0,8.5,0,8c0-0.5,0.4-1,1-1l234.8-7C238.1-0.1,240,1.7,240,4z"
      }))), children, this.renderSliderHandle('startHandle'), isRange && _react["default"].createElement("div", {
        className: "spectrum-Slider-track",
        role: "presentation",
        style: (_ref3 = {}, _defineProperty(_ref3, styleKeyOffset, startPercent * 100 + '%'), _defineProperty(_ref3, styleKeyOppositeOffset, (1 - endPercent) * 100 + '%'), _ref3)
      }), isRange ? this.renderSliderHandle('endHandle') : null, !isRamp && _react["default"].createElement("div", {
        className: "spectrum-Slider-track",
        role: "presentation",
        style: _defineProperty({}, styleKeyFill, (1 - (isRange ? endPercent : percent)) * 100 + '%')
      }), filled && fillOffset ? _react["default"].createElement("div", {
        className: (0, _classnames["default"])('spectrum-Slider-fill', {
          'spectrum-Slider-fill--right': startPercent > fillOffsetPercent
        }),
        role: "presentation",
        style: (_ref5 = {}, _defineProperty(_ref5, styleKeyOffset, minFillPercent * 100 + '%'), _defineProperty(_ref5, styleKeyFill, (maxFillPercent - minFillPercent) * 100 + '%'), _ref5)
      }) : null));
    }
  }]);

  return Slider;
}(_react["default"].Component), _defineProperty(_class2, "propTypes", {
  /**
   * The minimal number of the range.
   */
  min: _propTypes["default"].number,

  /**
   * The maximum number of the range.
   */
  max: _propTypes["default"].number,

  /**
   * The size of the incremental or decremental step.
   */
  step: _propTypes["default"].number,

  /**
   * Disable the slider if value is set to true.
   */
  disabled: _propTypes["default"].bool,

  /**
   * The orientation of the slider.
   */
  orientation: _propTypes["default"].oneOf(['horizontal', 'vertical']),

  /**
   * Set to true to render label.
   */
  renderLabel: _propTypes["default"].bool,

  /**
   * The label of the slider.
   */
  label: _propTypes["default"].node,

  /**
   * Whether the line of the slider should be filled.
   */
  filled: _propTypes["default"].bool,

  /**
   * Start point of the filled slider.
   */
  fillOffset: _propTypes["default"].number,

  /**
   * The variant
   */
  variant: _propTypes["default"].oneOf([null, 'ramp', 'range']),

  /**
   * The size of the slider. Small (S) or large (L) are available.
   */
  size: _propTypes["default"].oneOf([null, 'S', 'L']),

  /**
   * Callback function when the slider is changed.  If the variant is range, starting value
   * and ending value are passed to the callback function.  Otherwise, only the starting value
   * is passed into the callback function.
   */
  onChange: _propTypes["default"].func,

  /**
   * Utility function to return a string to use as the `aria-valuetext` for a slider `input` from its `value`. For example, to retrieve a time string from a minute in the day you could use:
   *
   * ```js
   * minutes => {
   *   const date = new Date();
   *   date.setHours(Math.floor(minutes / 60));
   *   date.setMinutes(minutes % 60);
   *   return date.toLocaleTimeString('en-us', {hour: '2-digit', minute: '2-digit'});
   * }
   * ```
   */
  getAriaValueText: _propTypes["default"].func
}), _defineProperty(_class2, "defaultProps", {
  min: 0,
  max: 100,
  step: 0,
  disabled: false,
  orientation: 'horizontal',
  renderLabel: false,
  label: null,
  filled: false,
  fillOffset: 0,
  variant: null,
  size: null,
  onChange: function onChange() {},
  getAriaValueText: function getAriaValueText(value) {
    return value;
  }
}), _temp)) || _class;

exports["default"] = Slider;