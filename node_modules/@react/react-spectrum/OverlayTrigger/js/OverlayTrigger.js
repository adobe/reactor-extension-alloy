"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _events = require("../../utils/events");

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _createId = _interopRequireDefault(require("../../utils/createId"));

var _ModalContainer = require("../../ModalContainer/js/ModalContainer.js");

var _Overlay = _interopRequireDefault(require("./Overlay"));

var _ownerDocument = _interopRequireDefault(require("react-overlays/lib/utils/ownerDocument"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _class, _class2, _temp;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var triggerType = _propTypes["default"].oneOf(['click', 'longClick', 'hover', 'focus']);

var MOUSE_BUTTONS = {
  left: 0
};
/**
 * Check if value one is inside or equal to the of value
 *
 * @param {string} one
 * @param {string|array} of
 * @returns {boolean}
 */

function isOneOf(one, of) {
  if (Array.isArray(of)) {
    return of.indexOf(one) >= 0;
  }

  return one === of;
}
/**
 * Find all of the scrollable parents of a DOM node
 */


function getScrollParents(node) {
  var nodes = [];

  while (node.parentNode) {
    var style = window.getComputedStyle(node); // Look for scrollable nodes, both real and fake.

    if (/auto|scroll/.test(style.overflow + style.overflowY) || node.hasAttribute('data-scrollable')) {
      nodes.push(node);
    }

    node = node.parentNode;
  }

  return nodes;
}
/*
 * Class based on React-bootstrap
 * https://github.com/react-bootstrap/react-bootstrap/blob/master/src/OverlayTrigger.js
 */


var OverlayTrigger = (0, _convertUnsafeMethod["default"])(_class = (0, _autobindDecorator["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_Component) {
  _inherits(OverlayTrigger, _Component);

  function OverlayTrigger(props, context) {
    var _this;

    _classCallCheck(this, OverlayTrigger);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OverlayTrigger).call(this, props, context));

    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function (e) {
      if (!_this.props.disabled && e.button === MOUSE_BUTTONS.left) {
        var target = e.currentTarget;
        _this.longPressTimeout = setTimeout(function () {
          _this.longPressTimeout = null; // In Safari, buttons are force blurred after the mouse down event since we don't call e.preventDefault()
          // Changing Button to prevent default would be a breaking change. So, assume that we want to restore
          // focus to the trigger element when the overlay closes.

          _this._lastFocus = target;

          _this.show(e);
        }, 250);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function (e) {
      // Prevent focus from being forced back to the button on long click.
      // It will already be inside the popover/menu.
      if (!_this.longPressTimeout) {
        e.preventDefault();
      }

      if (!_this.props.disabled && _this.longPressTimeout && e.button === MOUSE_BUTTONS.left) {
        if (_this.props.onClick) {
          _this.props.onClick(e);
        }

        _this.hide(e);

        clearTimeout(_this.longPressTimeout);
        _this.longPressTimeout = null;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "windowMouseUp", function (e) {
      if (e.button === MOUSE_BUTTONS.left && !_reactDom["default"].findDOMNode(_assertThisInitialized(_this)).contains(e.target) && _this.longPressTimeout) {
        clearTimeout(_this.longPressTimeout);
        _this.longPressTimeout = null;
      }
    });

    _this.overlayId = (0, _createId["default"])();
    _this._mountNode = null;
    _this.longPressTimeout = null;
    _this._lastFocus = props.lastFocus;
    _this.boundariesElement = props.boundariesElement ? props.boundariesElement : function () {
      return (0, _ownerDocument["default"])(_assertThisInitialized(_this)).body;
    };
    _this._scrollParents = null;
    _this.state = {
      show: props.show === undefined ? props.defaultShow : props.show
    };
    return _this;
  }

  _createClass(OverlayTrigger, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if ('lastFocus' in nextProps && nextProps.lastFocus !== this.props.lastFocus) {
        this._lastFocus = nextProps.lastFocus;
      }

      if (nextProps.show !== this.props.show) {
        nextProps.show ? this.handleDelayedShow() : this.handleDelayedHide();
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this._mountNode = document.createElement('div');
      this.renderOverlay();
      document.body.addEventListener('mouseUp', this.windowMouseUp);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var isDisabled = prevProps.disabled;
      var shouldDisable = this.props.disabled;

      if (!isDisabled && shouldDisable) {
        this.hide();
      }

      this.renderOverlay();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      _ModalContainer.modalManager.removeFromModal(this._overlay);

      _reactDom["default"].unmountComponentAtNode(this._mountNode);

      this._mountNode = null;
      clearTimeout(this._hoverShowDelay);
      clearTimeout(this._hoverHideDelay);
      this.removeListenersFromScrollParents();
      document.body.removeEventListener('mouseUp', this.windowMouseUp);
    }
  }, {
    key: "handleToggle",
    value: function handleToggle(e) {
      if (this.state.show) {
        this.hide(e);
      } else {
        this.show(e);
      }
    }
  }, {
    key: "handleDelayedShow",
    value: function handleDelayedShow(e) {
      var _this2 = this;

      if (this._hoverHideDelay != null) {
        clearTimeout(this._hoverHideDelay);
        this._hoverHideDelay = null;
        return;
      }

      if (this.state.show || this._hoverShowDelay != null) {
        return;
      }

      var delay = this.props.delayShow != null ? this.props.delayShow : this.props.delay;

      if (!delay) {
        this.show(e);
        return;
      }

      this._hoverShowDelay = setTimeout(function () {
        _this2._hoverShowDelay = null;

        _this2.show(e);
      }, delay);
    }
  }, {
    key: "handleDelayedHide",
    value: function handleDelayedHide(e) {
      var _this3 = this;

      if (this._hoverShowDelay != null) {
        clearTimeout(this._hoverShowDelay);
        this._hoverShowDelay = null;
        return;
      }

      if (!this.state.show || this._hoverHideDelay != null) {
        return;
      }

      var delay = (!this.props.delayHide || this.props.delayHide === OverlayTrigger.defaultProps.delayHide) && this.props.delay != null ? this.props.delay : this.props.delayHide;

      if (!delay) {
        this.hide(e);
        return;
      }

      this._hoverHideDelay = setTimeout(function () {
        _this3._hoverHideDelay = null;

        _this3.hide(e);
      }, delay);
    } // Simple implementation of mouseEnter and mouseLeave.
    // React's built version is broken: https://github.com/facebook/react/issues/4251
    // for cases when the trigger is disabled and mouseOut/Over can cause flicker
    // moving from one child element to another.

  }, {
    key: "handleMouseOverOut",
    value: function handleMouseOverOut(handler, e) {
      var target = e.currentTarget;
      var related = e.relatedTarget || e.nativeEvent.toElement;

      if (!related || related !== target && !target.contains(related)) {
        handler(e);
      }
    }
  }, {
    key: "show",
    value: function show(e) {
      if (!this.state.show && !this.props.disabled) {
        this._lastFocus = this.rememberedFocus();
        this.listenToScrollParents();
        this.setState({
          show: true
        });

        if (this.props.onShow) {
          this.props.onShow(e);
        }
      }
    } // if we're already listening, remove listeners and reapply

  }, {
    key: "listenToScrollParents",
    value: function listenToScrollParents() {
      if (this._scrollParents) {
        this.removeListenersFromScrollParents();
      }

      this._scrollParents = getScrollParents(_reactDom["default"].findDOMNode(this));
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._scrollParents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          node.addEventListener('scroll', this.hide, false);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // if we have any listeners on parents, remove them

  }, {
    key: "removeListenersFromScrollParents",
    value: function removeListenersFromScrollParents() {
      if (this._scrollParents) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._scrollParents[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var node = _step2.value;
            node.removeEventListener('scroll', this.hide, false);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        this._scrollParents = null;
      }
    }
  }, {
    key: "hide",
    value: function hide(e) {
      this.removeListenersFromScrollParents();

      if (this.state.show) {
        this.setState({
          show: false
        });

        if (this.props.onHide) {
          this.props.onHide(e);
        }
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (e.key === 'ArrowDown' || e.key === 'Down') {
        if (e.altKey || e.target === _reactDom["default"].findDOMNode(this.dropdownRef.triggerRef)) {
          e.preventDefault();
          this.show(e);
        }
      }
    }
  }, {
    key: "onHide",
    value: function onHide(e) {
      // if we are in longClick mode and the onHide comes from the mouse up on the trigger, then ignore it
      // it's actually an onHide coming from rootClose
      if (isOneOf('longClick', this.props.trigger) && _reactDom["default"].findDOMNode(this).contains(e.target)) {
        return;
      }

      if (this.props.show === undefined) {
        this.hide(e);
      } else if (this.props.onHide) {
        this.props.onHide(e);
      }
    }
  }, {
    key: "onExited",
    value: function onExited(e) {
      this.restoreFocus(e);

      if (this.props.onExited) {
        this.props.onExited(e);
      }
    }
  }, {
    key: "rememberedFocus",
    value: function rememberedFocus() {
      if (!this._lastFocus && document && document.activeElement !== document.body) {
        this._lastFocus = document.activeElement;
      }

      return this._lastFocus;
    }
  }, {
    key: "restoreFocus",
    value: function restoreFocus(overlay) {
      if (this._lastFocus && typeof this._lastFocus.focus === 'function') {
        if (document) {
          var node;

          if (overlay) {
            node = _reactDom["default"].findDOMNode(overlay);
          }

          if (node && (node === document.activeElement || node.contains(document.activeElement)) || document.activeElement === document.body) {
            this._lastFocus.focus();
          }
        }

        if (!this.props.lastFocus) {
          this._lastFocus = null;
        }
      }
    }
  }, {
    key: "makeOverlay",
    value: function makeOverlay(overlay, props) {
      var _this$props$target = this.props.target,
          target = _this$props$target === void 0 ? this : _this$props$target;

      var _props$rootClose = props.rootClose,
          rootClose = _props$rootClose === void 0 ? true : _props$rootClose,
          overlayProps = _objectWithoutProperties(props, ["rootClose"]);

      delete overlayProps.crossOffset;
      delete overlayProps.defaultShow;
      delete overlayProps.flip;
      delete overlayProps.boundariesElement;

      var topOverlayProps = _objectSpread({
        id: overlay.props.id || overlayProps.id
      }, props);

      if (!overlay.props.id) {
        overlayProps.id = this.overlayId;
      }

      return _react["default"].createElement(_Overlay["default"], _extends({}, topOverlayProps, {
        show: this.state.show,
        onHide: this.onHide,
        onExited: this.onExited,
        target: target,
        rootClose: rootClose
      }), (0, _react.cloneElement)(overlay, overlayProps));
    }
  }, {
    key: "renderOverlay",
    value: function renderOverlay() {
      // Only add overlay to modalManager when it is shown.
      if (this._overlay.props.show) {
        _ModalContainer.modalManager.addToModal(this._overlay, true);
      }

      _reactDom["default"].unstable_renderSubtreeIntoContainer(this, this._overlay, this._mountNode);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          trigger = _this$props.trigger,
          show = _this$props.show,
          _this$props$selected = _this$props.selected,
          selected = _this$props$selected === void 0 ? this.state.show : _this$props$selected,
          props = _objectWithoutProperties(_this$props, ["trigger", "show", "selected"]);

      delete props.delay;
      delete props.delayShow;
      delete props.delayHide;
      delete props.defaultShow;
      delete props.onShow;
      delete props.onHide;

      var _React$Children$toArr = _react["default"].Children.toArray(this.props.children),
          _React$Children$toArr2 = _slicedToArray(_React$Children$toArr, 2),
          triggerChild = _React$Children$toArr2[0],
          overlayChild = _React$Children$toArr2[1];

      var triggerProps = {};
      delete props.children; // When Tooltip is shown,

      if (this.state.show && overlayChild.type && overlayChild.props.role === 'tooltip') {
        // Tooltip element id should match trigger element's aria-describedby value,
        if (!props.id) {
          props.id = overlayChild.props.id || this.overlayId;
        } // Tooltip should add aria-describedby attribute to trigger element.


        triggerProps['aria-describedby'] = props.id;
      } // Attach trigger events in case on un-controlled overlay


      if (show === undefined) {
        if (isOneOf('click', trigger) && !isOneOf('longClick', trigger)) {
          triggerProps.onClick = (0, _events.chain)(this.props.onClick, this.handleToggle);
        }

        if (isOneOf('longClick', trigger)) {
          delete props.onClick;
          triggerProps.onMouseDown = this.onMouseDown;
          triggerProps.onMouseUp = this.onMouseUp;
          triggerProps.onKeyDown = this.onKeyDown;
        }

        if (isOneOf('hover', trigger)) {
          triggerProps.onMouseOver = this.handleMouseOverOut.bind(this, this.handleDelayedShow);
          triggerProps.onMouseOut = this.handleMouseOverOut.bind(this, this.handleDelayedHide);
          props.onMouseOver = this.handleMouseOverOut.bind(this, this.handleDelayedShow);
          props.onMouseOut = this.handleMouseOverOut.bind(this, this.handleDelayedHide); // overlay should not trap focus when trigger is 'hover'

          props.trapFocus = false;
        }

        if (isOneOf('focus', trigger)) {
          triggerProps.onFocus = (0, _events.chain)(triggerChild.props.onFocus, this.handleDelayedShow);
          triggerProps.onBlur = (0, _events.chain)(triggerChild.props.onBlur, this.handleDelayedHide);
          props.onFocus = this.handleDelayedShow;
          props.onBlur = this.handleDelayedHide; // overlay should not trap focus when trigger is 'focus'

          props.trapFocus = false;
        }
      }

      triggerProps.selected = selected; // Remove previous overlay from modalManager

      if (this._overlay) {
        _ModalContainer.modalManager.removeFromModal(this._overlay);
      }

      this._overlay = this.makeOverlay(overlayChild, props);
      return (0, _react.cloneElement)(triggerChild, triggerProps);
    }
  }]);

  return OverlayTrigger;
}(_react.Component), _defineProperty(_class2, "propTypes", _objectSpread({}, _Overlay["default"].propTypes, {
  /**
   * Specify which action or actions trigger Overlay visibility
   */
  trigger: _propTypes["default"].oneOfType([triggerType, _propTypes["default"].arrayOf(triggerType)]),

  /**
   * A millisecond delay amount to show and hide the Overlay once triggered
   */
  delay: _propTypes["default"].number,

  /**
   * A millisecond delay amount before showing the Overlay once triggered.
   */
  delayShow: _propTypes["default"].number,

  /**
   * A millisecond delay amount before hiding the Overlay once triggered.
   */
  delayHide: _propTypes["default"].number,

  /**
   * The initial visibility state of the Overlay. For more nuanced visibility
   * control, consider using the Overlay component directly.
   */
  defaultShow: _propTypes["default"].bool,

  /**
   * Specify the position of the overlay relative to the trigger element.
   */
  placement: _propTypes["default"].string,

  /**
   * An element or text to overlay next to the target.
   */

  /**
   * Callback when the overlay trigger is blurred.
   */
  onBlur: _propTypes["default"].func,

  /**
   * Callback when the overlay trigger is clicked.
   */
  onClick: _propTypes["default"].func,

  /**
   * Callback when the overlay trigger receives focus.
   */
  onFocus: _propTypes["default"].func,

  /**
   * Callback when the mouse leaves the overlay trigger.
   */
  onMouseOut: _propTypes["default"].func,

  /**
   * Callback when the mouse is over the overlay trigger.
   */
  onMouseOver: _propTypes["default"].func,

  /**
   * Callback when the overlay show is invoked, determined by the 'trigger' prop.
   */
  onShow: _propTypes["default"].func,

  /**
   * Callback when the overlay is hidden.
   */
  onHide: _propTypes["default"].func,

  /**
   * Will cause the overlay to show in a controlled state.
   */
  show: _propTypes["default"].bool,

  /**
   * Overlay will be shifted by specified units in the placement's axis direction.
   */
  offset: _propTypes["default"].number,

  /**
   * Overlay will be shifted by specified units in the placement's cross-axis direction.
   */
  crossOffset: _propTypes["default"].number,

  /**
   * Whether overlay should be allowed to flip if it hits the boundary
   */
  flip: _propTypes["default"].bool,

  /**
   * Grey's out the trigger and removes interaction.
   */
  disabled: _propTypes["default"].bool,

  /**
   * By default, the body of the owning document. The overlay will do a hit test to see if it
   * extends outside the boundaries and move it to a new position if it collides.
   */
  boundariesElement: _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].string]),

  /**
   * The last component or element to have focus before the overlay opened.
   * If undefined, overlay will use the document.activeElement before it opened as the lastFocus.
   * Set the lastFocus prop to override this default behavior.
   */
  lastFocus: _propTypes["default"].oneOfType([_propTypes["default"].element, _propTypes["default"].object])
})), _defineProperty(_class2, "defaultProps", {
  defaultShow: false,
  trigger: ['hover', 'focus'],
  placement: 'left',
  offset: 0,
  crossOffset: 0,
  flip: true,
  disabled: false,
  delayHide: 100
}), _temp)) || _class) || _class;

exports["default"] = OverlayTrigger;