"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _closest = _interopRequireDefault(require("dom-helpers/query/closest"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _OpenTransition = _interopRequireDefault(require("../../utils/OpenTransition"));

var _ownerDocument = _interopRequireDefault(require("react-overlays/lib/utils/ownerDocument"));

var _Portal = _interopRequireDefault(require("react-overlays/lib/Portal"));

var _Position = _interopRequireDefault(require("./Position"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _RootCloseWrapper = _interopRequireDefault(require("react-overlays/lib/RootCloseWrapper"));

var _class, _class2, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var VISIBLE_OVERLAYS = new Map();
var DEFAULT_BUCKET_KEY = 'all';

var Overlay = (0, _convertUnsafeMethod["default"])(_class = (0, _autobindDecorator["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Overlay, _React$Component);

  function Overlay(props) {
    var _this;

    _classCallCheck(this, Overlay);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, props));
    _this.state = {
      exited: !_this.props.show
    };
    return _this;
  }

  _createClass(Overlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        targetNode: _reactDom["default"].findDOMNode(this.props.target)
      });
      this.mounted = true;
      this.addOverlay();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      this.removeOverlay();
    }
  }, {
    key: "addOverlay",
    value: function addOverlay() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var overlayBucketKey = this.overlayBucketKey;
      var visibleOverlays = VISIBLE_OVERLAYS.get(overlayBucketKey);

      if (!visibleOverlays) {
        VISIBLE_OVERLAYS.set(overlayBucketKey, []);
        visibleOverlays = VISIBLE_OVERLAYS.get(overlayBucketKey);
      }

      if (props.show && this.mounted && !visibleOverlays.includes(this)) {
        visibleOverlays.push(this);
      }
    }
  }, {
    key: "removeOverlay",
    value: function removeOverlay() {
      // Remove overlay from the stack of visible overlays
      var visibleOverlays = VISIBLE_OVERLAYS.get(this.overlayBucketKey);
      var index = visibleOverlays.indexOf(this);

      if (index >= 0) {
        visibleOverlays.splice(index, 1);
      }
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (nextProps.target && nextProps.target !== this.props.target) {
        this.setState(_objectSpread({}, this.state, {
          targetNode: _reactDom["default"].findDOMNode(nextProps.target)
        }));
      }
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.setState(_objectSpread({}, this.state, {
        exited: false
      }));
      this.addOverlay();

      if (this.props.onEntered) {
        var _this$props;

        (_this$props = this.props).onEntered.apply(_this$props, arguments);
      }
    }
  }, {
    key: "onExited",
    value: function onExited() {
      this.setState(_objectSpread({}, this.state, {
        exited: true
      }));
      this.removeOverlay();

      if (this.props.onExited) {
        var _this$props2;

        (_this$props2 = this.props).onExited.apply(_this$props2, arguments);
      }
    }
  }, {
    key: "getOverlayContainer",
    value: function getOverlayContainer(target) {
      var immediateAvailableContainer = (0, _closest["default"])(this.state.targetNode, '.react-spectrum-provider');
      return this.props.container || immediateAvailableContainer;
    }
  }, {
    key: "hide",
    value: function hide(e) {
      var visibleOverlays = VISIBLE_OVERLAYS.get(this.overlayBucketKey); // Only hide if this is the top overlay

      if (visibleOverlays[visibleOverlays.length - 1] === this && this.props.onHide) {
        this.props.onHide(e);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          containerPadding = _this$props3.containerPadding,
          target = _this$props3.target,
          _this$props3$containe = _this$props3.container,
          container = _this$props3$containe === void 0 ? this.getOverlayContainer(target) : _this$props3$containe,
          placement = _this$props3.placement,
          offset = _this$props3.offset,
          crossOffset = _this$props3.crossOffset,
          flip = _this$props3.flip,
          _this$props3$boundari = _this$props3.boundariesElement,
          boundariesElement = _this$props3$boundari === void 0 ? function () {
        return (0, _ownerDocument["default"])(_this2).body;
      } : _this$props3$boundari,
          shouldUpdatePosition = _this$props3.shouldUpdatePosition,
          rootClose = _this$props3.rootClose,
          children = _this$props3.children,
          show = _this$props3.show,
          onExit = _this$props3.onExit,
          onExiting = _this$props3.onExiting,
          onEnter = _this$props3.onEnter,
          onEntering = _this$props3.onEntering; // Don't un-render the overlay while it's transitioning out.

      var mountOverlay = show || !this.state.exited;

      if (!mountOverlay) {
        // Don't bother showing anything if we don't have to.
        return null;
      }

      var child = children; // Position is be inner-most because it adds inline styles into the child,
      // which the other wrappers don't forward correctly.

      child = _react["default"].createElement(_Position["default"], {
        container: container,
        containerPadding: containerPadding,
        target: target,
        placement: placement,
        shouldUpdatePosition: shouldUpdatePosition,
        offset: offset,
        crossOffset: crossOffset,
        flip: flip,
        boundariesElement: boundariesElement
      }, child); // This animates the child node by injecting props, so it must precede
      // anything that adds a wrapping div.

      child = _react["default"].createElement(_OpenTransition["default"], {
        "in": show,
        appear: true,
        onExit: onExit,
        onExiting: onExiting,
        onExited: this.onExited,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: this.onEntered
      }, child); // This goes after everything else because it adds a wrapping div.

      if (rootClose) {
        child = _react["default"].createElement(_RootCloseWrapper["default"], {
          onRootClose: this.hide
        }, child);
      }

      return _react["default"].createElement(_Portal["default"], {
        container: container
      }, child);
    }
  }, {
    key: "overlayBucketKey",
    get: function get() {
      var children = this.props.children;

      if (children && children.props) {
        return children.props.role === 'tooltip' ? 'tooltip' : DEFAULT_BUCKET_KEY;
      }

      return DEFAULT_BUCKET_KEY;
    }
  }]);

  return Overlay;
}(_react["default"].Component), _defineProperty(_class2, "defaultProps", {
  placement: 'left'
}), _temp)) || _class) || _class;

exports["default"] = Overlay;