"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ImageCache = void 0;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2019 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
**************************************************************************/
var DEFAULT_OPTIONS = {
  cacheSize: 500,
  maxConcurrentDownloads: 10
}; // static callback for use when preloading images.

var PRELOAD_CB = function PRELOAD_CB() {};
/**
 * This class caches images locally during a browser session,
 * and ensures that images are not reloaded from the network
 * as users scroll around. It can also preload images in advance.
 */


var ImageCache =
/*#__PURE__*/
function () {
  function ImageCache(options) {
    _classCallCheck(this, ImageCache);

    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this._cache = new Map();
    this._callbacks = {};
    this._xhr = {};
    this._queue = [];
    this._active = 0;
  }

  _createClass(ImageCache, [{
    key: "_loadImage",
    value: function _loadImage(url, options, callback) {
      // If the image is already loading, just add the callback
      if (this._callbacks[url]) {
        this._callbacks[url].add(callback);

        return;
      } // Save callback, and enqueue the url to load.


      this._callbacks[url] = new Set([callback]);

      this._enqueue(this._load.bind(this, url, options));
    }
  }, {
    key: "_enqueue",
    value: function _enqueue(fn) {
      this._queue.push(fn);

      this._runQueue();
    }
  }, {
    key: "_runQueue",
    value: function _runQueue() {
      var _this = this;

      // Run items from the queue until we reach the maximum concurrency limit
      while (this._queue.length > 0 && this._active < this.options.maxConcurrentDownloads) {
        var fn = this._queue.shift();

        this._active++;
        fn(function () {
          _this._active--;

          _this._runQueue();
        });
      }
    }
  }, {
    key: "_load",
    value: function () {
      var _load2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(url, options, callback) {
        var _this2 = this;

        var xhr, key;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._callbacks[url]) {
                  _context.next = 3;
                  break;
                }

                callback();
                return _context.abrupt("return");

              case 3:
                xhr = new XMLHttpRequest();
                xhr.open('GET', url);
                xhr.responseType = 'blob';

                if (options.headers) {
                  for (key in options.headers) {
                    xhr.setRequestHeader(key, options.headers[key]);
                  }
                }

                xhr.addEventListener('load', function () {
                  var blobURL = URL.createObjectURL(xhr.response);

                  _this2.set(url, blobURL);

                  _this2._callback(url, null, blobURL);

                  callback();
                });
                xhr.addEventListener('error', function (err) {
                  _this2._callback(url, err);

                  callback();
                });
                xhr.addEventListener('abort', function () {
                  callback();
                });
                this._xhr[url] = xhr;
                xhr.send();

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _load(_x, _x2, _x3) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_callback",
    value: function _callback(url, err, blobURL) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._callbacks[url][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var callback = _step.value;
          callback(err, blobURL);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete this._callbacks[url];
      delete this._xhr[url];
    }
  }, {
    key: "set",
    value: function set(url, blobURL) {
      // If the cache exceeds the maximum, delete the first key in the map,
      // which corresponds to the least recently used item.
      if (this._cache.size >= this.options.cacheSize) {
        var toDelete = this._cache.keys().next().value;

        this["delete"](toDelete);
      }

      this._cache.set(url, blobURL);
    }
  }, {
    key: "delete",
    value: function _delete(url) {
      var blobURL = this._cache.get(url);

      if (blobURL) {
        URL.revokeObjectURL(blobURL);

        this._cache["delete"](url);
      }
    }
    /**
     * Checks whether an image URL exists in the cache.
     */

  }, {
    key: "has",
    value: function has(url) {
      return this._cache.has(url);
    }
    /**
     * Gets a blob URL for an image if it exists already in the cache.
     */

  }, {
    key: "getCached",
    value: function getCached(url) {
      var blobURL = this._cache.get(url);

      if (blobURL) {
        // re-insert the blob url at the end of the map for LRU eviction strategy.
        this._cache["delete"](url);

        this._cache.set(url, blobURL);
      }

      return blobURL;
    }
    /**
     * Gets a blob url for an image and calls the callback. If the image is not already cached, 
     * it will be queued and loaded.
     * @param {string} url
     * @param {?object} options
     * @param {function} callback
     */

  }, {
    key: "get",
    value: function get(url, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (/^blob:/.test(url)) {
        return callback(null, url);
      }

      var blobURL = this.getCached(url);

      if (blobURL) {
        return callback(null, blobURL);
      }

      this._loadImage(url, options, callback);
    }
    /**
     * Aborts loading an image by URL for the provided callback function.
     */

  }, {
    key: "abort",
    value: function abort(url, callback) {
      // Ignore if this url is not currently loading, or the callback wasn't found.
      if (!this._callbacks[url] || !this._callbacks[url].has(callback)) {
        return;
      } // Delete the callback from the list. If it is the last one, continue.


      this._callbacks[url]["delete"](callback);

      if (this._callbacks[url].size > 0) {
        return;
      } // Abort the request, if one is in progress.


      if (this._xhr[url]) {
        this._xhr[url].abort();

        delete this._xhr[url];
      }

      delete this._callbacks[url];
    }
    /**
     * Queues an image to be preloaded
     */

  }, {
    key: "preload",
    value: function preload(url) {
      this.get(url, PRELOAD_CB);
    }
    /**
     * Aborts an image preload
     */

  }, {
    key: "abortPreload",
    value: function abortPreload(url) {
      this.abort(url, PRELOAD_CB);
    }
  }]);

  return ImageCache;
}();

exports.ImageCache = ImageCache;

var _default = new ImageCache();

exports["default"] = _default;