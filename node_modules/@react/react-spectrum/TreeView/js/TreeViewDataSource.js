"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _collectionView = require("@react/collection-view");

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _class;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Represents a node in the tree
 * @private
 */
var TreeItem = (0, _autobindDecorator["default"])(_class =
/*#__PURE__*/
function () {
  function TreeItem(item, parent, hasChildren, index) {
    _classCallCheck(this, TreeItem);

    this.item = item;
    this.hasChildren = hasChildren;
    this.children = null;
    this.isToggleable = true;
    this.isExpanded = false;
    this.isVisible = false;
    this.isLoading = false;
    this.parent = parent;
    this.level = parent ? parent.level + 1 : -1;
    this.index = index;
  }

  _createClass(TreeItem, [{
    key: "walk",
    value: function walk(fn) {
      var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.children) {
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          fn(child);

          if (child.isExpanded || all) {
            child.walk(fn);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "updateChildIndices",
    value: function updateChildIndices() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var end = arguments.length > 1 ? arguments[1] : undefined;

      if (!this.children) {
        return;
      }

      if (end == null) {
        end = this.children.length;
      }

      for (var i = start; i < end; i++) {
        this.children[i].index = i;
      }
    }
  }, {
    key: "nextSibling",
    get: function get() {
      if (!this.parent || !this.parent.children) {
        return null;
      }

      var siblings = this.parent.children;
      return siblings[this.index + 1];
    }
  }]);

  return TreeItem;
}()) || _class;
/*
 * TreeViewDataSource is the super class for all data sources used
 * by TreeView. It manages expanding and collapsing items, loading
 * children on demand, and manipulation of that data. Because it
 * uses content objects as the keys for many of its methods, all
 * items in the tree must be unique.
 */


var TreeViewDataSource =
/*#__PURE__*/
function (_ArrayDataSource) {
  _inherits(TreeViewDataSource, _ArrayDataSource);

  function TreeViewDataSource(dataSource) {
    var _this;

    _classCallCheck(this, TreeViewDataSource);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TreeViewDataSource).call(this, [[]]));
    _this.root = new TreeItem(null, null, false);
    _this.root.isExpanded = true;
    _this.lookup = new Map();
    _this.dataSource = dataSource;

    if (dataSource && typeof dataSource.on === 'function') {
      // Bind methods that come from ArrayDataSource
      _this.startTransaction = _this.startTransaction.bind(_assertThisInitialized(_this));
      _this.endTransaction = _this.endTransaction.bind(_assertThisInitialized(_this)); // Setup event handlers

      dataSource.on('startTransaction', _this.startTransaction);
      dataSource.on('endTransaction', _this.endTransaction);
      dataSource.on('insertChild', _this.insertChild);
      dataSource.on('removeItem', _this.removeItem);
      dataSource.on('moveItem', _this.moveItem);
      dataSource.on('reloadItem', _this.reloadItem);
    }

    process.nextTick(function () {
      return _this.loadData();
    });
    return _this;
  }

  _createClass(TreeViewDataSource, [{
    key: "teardown",
    value: function teardown() {
      if (this.dataSource && typeof this.dataSource.removeListener === 'function') {
        this.dataSource.removeListener('startTransaction', this.startTransaction);
        this.dataSource.removeListener('endTransaction', this.endTransaction);
        this.dataSource.removeListener('insertChild', this.insertChild);
        this.dataSource.removeListener('removeItem', this.removeItem);
        this.dataSource.removeListener('moveItem', this.moveItem);
        this.dataSource.removeListener('reloadItem', this.reloadItem);
      }
    }
  }, {
    key: "loadData",
    value: function () {
      var _loadData = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var items;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.lookup = new Map();
                _context.next = 3;
                return this.loadChildren(this.root);

              case 3:
                items = [];
                this.root.walk(function (child) {
                  child.isVisible = true;
                  items.push(child);
                });
                this.replaceSection(0, items, false);
                this.emit('load');

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function loadData() {
        return _loadData.apply(this, arguments);
      }

      return loadData;
    }()
  }, {
    key: "loadChildren",
    value: function () {
      var _loadChildren = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(parent) {
        var items, res, index, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item, node;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                parent.isLoading = true;
                this.reloadItem(parent.item);
                _context2.next = 4;
                return this.getChildren(parent.item);

              case 4:
                items = _context2.sent;
                res = [];
                index = 0;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context2.prev = 10;
                _iterator2 = items[Symbol.iterator]();

              case 12:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context2.next = 23;
                  break;
                }

                item = _step2.value;
                node = this.getTreeItem(item, parent, index++);

                if (!node.isExpanded) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 18;
                return this.loadChildren(node);

              case 18:
                res.push(node);
                this.lookup.set(item, node);

              case 20:
                _iteratorNormalCompletion2 = true;
                _context2.next = 12;
                break;

              case 23:
                _context2.next = 29;
                break;

              case 25:
                _context2.prev = 25;
                _context2.t0 = _context2["catch"](10);
                _didIteratorError2 = true;
                _iteratorError2 = _context2.t0;

              case 29:
                _context2.prev = 29;
                _context2.prev = 30;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 32:
                _context2.prev = 32;

                if (!_didIteratorError2) {
                  _context2.next = 35;
                  break;
                }

                throw _iteratorError2;

              case 35:
                return _context2.finish(32);

              case 36:
                return _context2.finish(29);

              case 37:
                parent.children = res;
                parent.hasChildren = res.length > 0;
                parent.isLoading = false;
                this.reloadItem(parent.item);

              case 41:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[10, 25, 29, 37], [30,, 32, 36]]);
      }));

      function loadChildren(_x) {
        return _loadChildren.apply(this, arguments);
      }

      return loadChildren;
    }()
  }, {
    key: "getTreeItem",
    value: function getTreeItem(item, parent, index) {
      return new TreeItem(item, parent, this.hasChildren(item), index);
    }
    /**
     * Loads and returns the child items for the given parent.
     * The parent will be `null` if it is the root.
     * @param {object} parent
     * @return {object[]}
     * @abstract
     */

  }, {
    key: "getChildren",
    value: function () {
      var _getChildren = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(parent) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.dataSource) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", this.dataSource.getChildren(parent));

              case 2:
                throw new Error('getChildren must be implemented by subclasses');

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getChildren(_x2) {
        return _getChildren.apply(this, arguments);
      }

      return getChildren;
    }()
    /**
     * Returns whether the given parent item has children
     * @param {object} parent
     * @return {boolean}
     * @abstract
     */

  }, {
    key: "hasChildren",
    value: function hasChildren(parent) {
      if (this.dataSource) {
        return this.dataSource.hasChildren(parent);
      }

      throw new Error('hasChildren must be implemented by subclasses');
    }
  }, {
    key: "_getItem",
    value: function _getItem(parent) {
      if (!parent) {
        return this.root;
      }

      var node = this.lookup.get(parent);

      if (node) {
        return node;
      } // If nothing was found in the lookup, an equivalent object may exist with different object identity.
      // Search through the map to find one that matches the isItemEqual comparator.


      return this._findItem(this.lookup.values(), parent);
    }
  }, {
    key: "_findItem",
    value: function _findItem(haystack, needle) {
      var isItemEqual = this.dataSource && this.dataSource.isItemEqual;

      if (typeof isItemEqual !== 'function') {
        return null;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = haystack[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var node = _step3.value;

          if (isItemEqual(node.item, needle)) {
            return node;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return null;
    }
    /**
     * Returns the row IndexPath for the provided item, and optionally
     * increments it by the given number of rows.
     * @param {object} item
     * @param {number?} inc
     * @returns {IndexPath}
     */

  }, {
    key: "indexPathForItem",
    value: function indexPathForItem(item) {
      var inc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var content = this._getItem(item);

      if (!content) {
        return null;
      }

      var index = this.sections[0].indexOf(content);

      if (index === -1) {
        return null;
      }

      return new _collectionView.IndexPath(0, index + inc);
    }
    /**
     * Reloads the given item
     * @param {object} item
     */

  }, {
    key: "reloadItem",
    value: function reloadItem(item) {
      var indexPath = this.indexPathForItem(item);

      if (indexPath) {
        this.emit('reloadItem', indexPath, false);
      }
    }
    /**
     * Returns an array of children that are currently
     * loaded for the given parent item, or null if the
     * children have not been loaded for that parent.
     * @param {object} parent
     * @return {object[]}
     */

  }, {
    key: "getLoadedChildren",
    value: function getLoadedChildren(parent) {
      var item = this._getItem(parent);

      if (!item || !item.children) {
        return null;
      }

      return item.children.map(function (child) {
        return child.item;
      });
    }
    /**
     * Returns whether the given content item is expanded
     * @param {object} item
     * @return {boolean}
     */

  }, {
    key: "isExpanded",
    value: function isExpanded(item) {
      var node = this._getItem(item);

      return node && node.isExpanded;
    }
    /**
     * Expands or collapses the given item depending on its current state.
     * @param {object} item
     */

  }, {
    key: "toggleItem",
    value: function () {
      var _toggleItem = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(item) {
        var node;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                node = this._getItem(item);

                if (node) {
                  _context4.next = 3;
                  break;
                }

                return _context4.abrupt("return");

              case 3:
                if (!node.isExpanded) {
                  _context4.next = 7;
                  break;
                }

                this.collapseItem(node.item);
                _context4.next = 9;
                break;

              case 7:
                _context4.next = 9;
                return this.expandItem(node.item);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function toggleItem(_x3) {
        return _toggleItem.apply(this, arguments);
      }

      return toggleItem;
    }()
    /**
     * Expands the given item, displaying all of its children.
     * @param {object} item
     * @param {boolean} showAnimation
     */

  }, {
    key: "expandItem",
    value: function () {
      var _expandItem = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(item) {
        var _this2 = this;

        var showAnimation,
            node,
            indexPath,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                showAnimation = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : true;
                node = this._getItem(item);

                if (!(!node || node.isExpanded)) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("return");

              case 4:
                // Update parent
                node.isExpanded = true;
                this.reloadItem(node.item); // Load children if needed.

                if (node.children) {
                  _context5.next = 9;
                  break;
                }

                _context5.next = 9;
                return this.loadChildren(node);

              case 9:
                // Add all children to the visible set
                this.startTransaction();
                indexPath = this.indexPathForItem(node.item);
                node.walk(function (child) {
                  indexPath.index++;

                  if (!child.isVisible) {
                    child.isVisible = true;

                    _this2.insertItem(indexPath, child);
                  }
                });
                this.endTransaction(showAnimation);

              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function expandItem(_x4) {
        return _expandItem.apply(this, arguments);
      }

      return expandItem;
    }()
    /**
     * Collapses the given item, hiding all of its children.
     * @param {object} item
     * @param {boolean} showAnimation
     */

  }, {
    key: "collapseItem",
    value: function collapseItem(item) {
      var _this3 = this;

      var showAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var node = this._getItem(item);

      if (!node || !node.isExpanded) {
        return;
      } // Update parent


      node.isExpanded = false;
      this.reloadItem(node.item); // Remove all children from visible

      this.startTransaction();
      var indexPath = this.indexPathForItem(node.item, +1);
      node.walk(function (child) {
        if (child.isVisible) {
          child.isVisible = false;

          _get(_getPrototypeOf(TreeViewDataSource.prototype), "removeItem", _this3).call(_this3, indexPath);
        }
      });
      this.endTransaction(showAnimation);
    }
  }, {
    key: "_findInsertionIndex",
    value: function _findInsertionIndex(parent, index) {
      var parentItem = this._getItem(parent);

      if (!parentItem.isExpanded) {
        return null;
      } // If there are no children, insert after the parent item.


      if (parentItem.children.length === 0) {
        return this.indexPathForItem(parentItem.item, +1);
      } // Check if appending to the parent


      if (index >= parentItem.children.length) {
        // Insert before the next sibling.
        var nextSibling = parentItem.nextSibling;

        if (nextSibling) {
          return this.indexPathForItem(nextSibling.item);
        } else {
          return new _collectionView.IndexPath(0, this.sections[0].length);
        }
      } // Otherwise, insert before the current item at the given index.


      return this.indexPathForItem(parentItem.children[index].item);
    }
    /**
     * Inserts a child into the given parent item.
     * @param {object} parent - The parent object to insert into
     * @param {number} index - The child insertion index
     * @param {object} child - The child to insert
     */

  }, {
    key: "insertChild",
    value: function insertChild(parent, index, child) {
      var parentItem = this._getItem(parent);

      if (!parentItem) {
        return;
      } // Make sure the disclosure indicator is correct


      if (!parentItem.hasChildren) {
        parentItem.hasChildren = true;
        this.reloadItem(parentItem.item);
      } // If the children have been loaded, insert the new child


      if (parentItem.children) {
        var insertionIndex = this._findInsertionIndex(parentItem.item, index);

        var childItem = new TreeItem(child, parentItem, this.hasChildren(child), index);
        parentItem.children.splice(index, 0, childItem);
        parentItem.updateChildIndices(index + 1);
        this.lookup.set(child, childItem); // Add to the visible items if the parent is expanded

        if (parentItem.isExpanded) {
          childItem.isVisible = true;
          this.insertItem(insertionIndex, childItem);
        }
      }
    }
    /**
     * Removes a child index from the given parent item.
     * @param {object} parent - The parent item to remove from
     * @param {number} index - The child index to remove
     */

  }, {
    key: "removeChild",
    value: function removeChild(parent, index) {
      var _this4 = this;

      var parentItem = this._getItem(parent);

      if (!parentItem || !parentItem.children) {
        return;
      } // Remove the child


      var child = parentItem.children[index];
      parentItem.children.splice(index, 1);
      parentItem.updateChildIndices(index); // Make sure the disclosure indicator is correct

      if (parentItem.children.length === 0) {
        parentItem.hasChildren = false;
        this.reloadItem(parentItem.item);
      } // Remove from the visible items if the parent is expanded


      if (parentItem.isExpanded) {
        this.startTransaction();
        var indexPath = this.indexPathForItem(child.item);
        child.isVisible = false;

        _get(_getPrototypeOf(TreeViewDataSource.prototype), "removeItem", this).call(this, indexPath); // Remove all children


        if (child.isExpanded) {
          child.walk(function (child) {
            child.isVisible = false;

            _get(_getPrototypeOf(TreeViewDataSource.prototype), "removeItem", _this4).call(_this4, indexPath);
          });
        }

        this.endTransaction();
      } // Remove all children from the lookup map


      child.walk(function (child) {
        _this4.lookup["delete"](child.item);
      }, true);
      this.lookup["delete"](child.item);
    }
    /**
     * Removes an item from the tree view.
     * @param {object} item - The item to remove
     */

  }, {
    key: "removeItem",
    value: function removeItem(item) {
      var node = this._getItem(item);

      if (!node) {
        return;
      }

      this.removeChild(node.parent.item, node.index);
    }
    /**
     * Moves an item from one parent to another
     * @param {object} fromParent - The parent item to move from
     * @param {number} fromIndex - The index of the child item to move
     * @param {object} toParent - The parent item to move to
     * @param {number} toIndex - The index to move the item to
     */

  }, {
    key: "moveChild",
    value: function moveChild(fromParent, fromIndex, toParent, toIndex) {
      var fromItem = this._getItem(fromParent);

      var toItem = this._getItem(toParent);

      if (!fromItem || !fromItem.children || !toItem) {
        return;
      } // Find the visible indexes to update


      var child = fromItem.children[fromIndex];
      var fromVisibleIndex = this.indexPathForItem(child.item);

      var toVisibleIndex = this._findInsertionIndex(toItem.item, toIndex); // Move the child to the new parent


      child.parent = toItem;
      child.level = toItem.level + 1;
      fromItem.children.splice(fromIndex, 1);

      if (toItem.children) {
        toItem.children.splice(toIndex, 0, child);
      } // Update indices of changed items


      if (fromItem === toItem) {
        fromItem.updateChildIndices(Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex) + 1);
      } else {
        fromItem.updateChildIndices(fromIndex);
        toItem.updateChildIndices(toIndex);
      } // Reload both parents to ensure the disclosure indicators are correct


      if (fromItem.children.length === 0) {
        fromItem.hasChildren = false;
        this.reloadItem(fromItem.item);
      }

      if (!toItem.hasChildren) {
        toItem.hasChildren = true;
        this.reloadItem(toItem.item);
      } // Move, remove, or insert the item from visible depending on whether parents are expanded


      if (fromItem.isExpanded && toItem.isExpanded) {
        if (toVisibleIndex.index > fromVisibleIndex.index) {
          toVisibleIndex.index--;
        }

        _get(_getPrototypeOf(TreeViewDataSource.prototype), "moveItem", this).call(this, fromVisibleIndex, toVisibleIndex);
      } else if (fromItem.isExpanded) {
        child.isVisible = false;

        _get(_getPrototypeOf(TreeViewDataSource.prototype), "removeItem", this).call(this, fromVisibleIndex);
      } else if (toItem.isExpanded) {
        child.isVisible = true;
        this.insertItem(toVisibleIndex, child);
      }
    }
    /**
     * Moves an item to a new parent, or to a new index within the same parent
     * @param {object} fromParent - The item to move
     * @param {object} [toParent] - The parent item to move to. If not provided, the item is moved within the same parent.
     * @param {number} toIndex - The index to move the item to
     */

  }, {
    key: "moveItem",
    value: function moveItem(item, toParent, toIndex) {
      var node = this._getItem(item);

      if (!node) {
        return;
      }

      if (typeof toParent === 'number') {
        toIndex = toParent;
        toParent = node.parent.item;
      }

      this.moveChild(node.parent.item, node.index, toParent, toIndex);
    }
  }, {
    key: "performDrop",
    value: function performDrop(dropTarget, dropOperation, items) {
      if (this.dataSource && typeof this.dataSource.performDrop === 'function') {
        var target = this.getItem(dropTarget.indexPath.section, dropTarget.indexPath.index);

        if (dropTarget.dropPosition === 'DROP_ON') {
          this.dataSource.performDrop(target.item, 0, dropOperation, items);
        } else {
          this.dataSource.performDrop(target.parent.item, target.index, dropOperation, items);
        }
      }
    }
  }, {
    key: "performReorder",
    value: function performReorder(dragTarget, dropTarget, dropOperation, indexPaths) {
      var _this5 = this;

      if (this.dataSource && typeof this.dataSource.performMove === 'function') {
        var target = this.getItem(dropTarget.indexPath.section, dropTarget.indexPath.index);
        var items = Array.from(indexPaths).map(function (indexPath) {
          return _this5.getItem(indexPath.section, indexPath.index).item;
        }).filter(function (item) {
          return item !== target.item;
        });

        if (items.length === 0) {
          return;
        }

        if (dropTarget.dropPosition === 'DROP_ON') {
          this.dataSource.performMove(target.item, 0, dropOperation, items);
        } else {
          this.dataSource.performMove(target.parent.item, target.index, dropOperation, items);
        }
      }
    }
  }]);

  return TreeViewDataSource;
}(_collectionView.ArrayDataSource);

exports["default"] = TreeViewDataSource;