"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2019 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
**************************************************************************/
var DELEGATE_KEYS = ['shouldSelectItem', 'shouldDrag', 'getAllowedDropOperations', 'getDropOperation', 'itemsForDrop', 'shouldDeleteItems'];
/*
 * This class wraps the delegate methods available to collection-view
 * so that they accept item objects instead of IndexPaths, which don't
 * make sense in a tree data structure.
 */

var TreeViewDelegate =
/*#__PURE__*/
function () {
  function TreeViewDelegate(dataSource) {
    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TreeViewDelegate);

    this.dataSource = dataSource;
    this.delegate = delegate; // Remove keys that the delegate doesn't have on it

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = DELEGATE_KEYS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        if (typeof delegate[key] !== 'function') {
          this[key] = null;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  _createClass(TreeViewDelegate, [{
    key: "_getTarget",
    value: function _getTarget(target) {
      return this.dataSource.getItem(target.indexPath.section, target.indexPath.index).item;
    }
  }, {
    key: "_getItems",
    value: function _getItems(indexPaths) {
      var _this = this;

      return Array.from(indexPaths).map(function (indexPath) {
        return _this.dataSource.getItem(indexPath.section, indexPath.index).item;
      });
    }
  }, {
    key: "shouldSelectItem",
    value: function shouldSelectItem(indexPath) {
      var item = this.dataSource.getItem(indexPath.section, indexPath.index).item;
      return this.delegate.shouldSelectItem(item);
    }
  }, {
    key: "shouldDrag",
    value: function shouldDrag(dragTarget, selectedIndexPaths) {
      var target = this._getTarget(dragTarget);

      var selectedItems = this._getItems(selectedIndexPaths);

      return this.delegate.shouldDrag(target, selectedItems);
    }
  }, {
    key: "getAllowedDropOperations",
    value: function getAllowedDropOperations(dragTarget, selectedIndexPaths) {
      var target = this._getTarget(dragTarget);

      var selectedItems = this._getItems(selectedIndexPaths);

      return this.delegate.getAllowedDropOperations(target, selectedItems);
    }
  }, {
    key: "prepareDragData",
    value: function prepareDragData(dragTarget, dataTransfer, selectedIndexPaths) {
      var target = this._getTarget(dragTarget);

      var selectedItems = this._getItems(selectedIndexPaths);

      if (typeof this.delegate.prepareDragData === 'function') {
        return this.delegate.prepareDragData(target, dataTransfer, selectedItems);
      }

      dataTransfer.setData('CollectionViewData', JSON.stringify(selectedItems));
    }
  }, {
    key: "getDropTarget",
    value: function getDropTarget(target) {
      var item = this._getTarget(target);

      if (typeof this.delegate.shouldAcceptDrop === 'function' && !this.delegate.shouldAcceptDrop(item)) {
        return null;
      }

      return target;
    }
  }, {
    key: "getDropOperation",
    value: function getDropOperation(dropTarget, allowedOperations) {
      var target = this._getTarget(dropTarget);

      return this.delegate.getDropOperation(target, allowedOperations);
    }
  }, {
    key: "itemsForDrop",
    value: function itemsForDrop(dropTarget, dataTransfer) {
      var target = this._getTarget(dropTarget);

      return this.delegate.itemsForDrop(target, dataTransfer);
    }
  }, {
    key: "shouldDeleteItems",
    value: function shouldDeleteItems(indexPaths) {
      var items = this._getItems(indexPaths);

      return this.delegate.shouldDeleteItems(items);
    }
  }]);

  return TreeViewDelegate;
}();

exports["default"] = TreeViewDelegate;