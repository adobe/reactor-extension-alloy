"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _BaseLayout2 = _interopRequireDefault(require("./BaseLayout"));

var _collectionView = require("@react/collection-view");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DEFAULT_OPTIONS = {
  S: {
    itemPadding: 20,
    minItemSize: new _collectionView.Size(96, 96),
    maxItemSize: new _collectionView.Size(Infinity, Infinity),
    margin: 8,
    minSpace: new _collectionView.Size(8, 16),
    maxColumns: Infinity,
    dropSpacing: 50
  },
  L: {
    itemPadding: 52,
    minItemSize: new _collectionView.Size(208, 208),
    maxItemSize: new _collectionView.Size(Infinity, Infinity),
    margin: 24,
    minSpace: new _collectionView.Size(24, 48),
    maxColumns: Infinity,
    dropSpacing: 100
  }
};
/**
 * A GridLayout displays equal-sized items in a grid.
 * It works with data in a single section.
 */

var GridLayout =
/*#__PURE__*/
function (_BaseLayout) {
  _inherits(GridLayout, _BaseLayout);

  function GridLayout() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GridLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GridLayout).call(this));
    var cardSize = options.cardSize || 'L';
    /**
     * The minimum item size
     * @type {Size}
     * @default 208 x 208
     */

    _this.minItemSize = options.minItemSize || DEFAULT_OPTIONS[cardSize].minItemSize;
    /**
     * The maximum item size.
     * @type {Size}
     * @default Infinity
     */

    _this.maxItemSize = options.maxItemSize || DEFAULT_OPTIONS[cardSize].maxItemSize;
    /**
     * The margin around the grid view between the edges and the items
     * @type {Size}
     * @default 24
     */

    _this.margin = options.margin != null ? options.margin : DEFAULT_OPTIONS[cardSize].margin;
    /**
     * The minimum space required between items
     * @type {Size}
     * @default 24 x 48
     */

    _this.minSpace = options.minSpace || DEFAULT_OPTIONS[cardSize].minSpace;
    /**
     * The maximum number of columns. Default is infinity.
     * @type {number}
     * @default Infinity
     */

    _this.maxColumns = options.maxColumns || DEFAULT_OPTIONS[cardSize].maxColumns;
    /**
     * The vertical padding for an item
     * @type {number}
     * @default 52
     */

    _this.itemPadding = options.itemPadding != null ? options.itemPadding : DEFAULT_OPTIONS[cardSize].itemPadding;
    /**
     * The space between items created when dragging between them
     * @type {number}
     * @default 100
     */

    _this.dropSpacing = options.dropSpacing != null ? options.dropSpacing : DEFAULT_OPTIONS[cardSize].dropSpacing;
    _this.itemSize = null;
    _this.numColumns = 0;
    _this.numRows = 0;
    _this.horizontalSpacing = 0;
    _this.cardType = 'quiet'; // Better name?

    return _this;
  }

  _createClass(GridLayout, [{
    key: "getLayoutInfo",
    value: function getLayoutInfo(type, section, index) {
      var row = Math.floor(index / this.numColumns);
      var column = index % this.numColumns;
      var x = this.margin + column * (this.itemSize.width + this.horizontalSpacing);
      var y = this.margin + row * (this.itemSize.height + this.minSpace.height);

      if (this.shouldShowDropSpacing()) {
        var dropTarget = this.collectionView._dropTarget;
        var dropRow = Math.floor(dropTarget.indexPath.index / this.numColumns);

        if (dropRow === row) {
          x -= this.dropSpacing / 2;

          if (index >= dropTarget.indexPath.index) {
            x += this.dropSpacing;
          }
        }
      }

      var layoutInfo = new _collectionView.LayoutInfo(type, section, index);
      layoutInfo.rect = new _collectionView.Rect(x, y, this.itemSize.width, this.itemSize.height);
      layoutInfo.estimatedSize = false;
      return layoutInfo;
    }
  }, {
    key: "getIndexAtPoint",
    value: function getIndexAtPoint(x, y) {
      var allowInsertingAtEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var itemHeight = this.itemSize.height + this.minSpace.height;
      var itemWidth = this.itemSize.width + this.horizontalSpacing;
      return Math.max(0, Math.min(this.collectionView.getSectionLength(0) - (allowInsertingAtEnd ? 0 : 1), Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)));
    }
  }, {
    key: "getVisibleLayoutInfos",
    value: function getVisibleLayoutInfos(rect) {
      var res = [];
      var numItems = this.collectionView.getSectionLength(0) - 1;

      if (numItems < 0 || !this.itemSize) {
        return res;
      }

      var firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);
      var lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);

      for (var index = firstVisibleItem; index <= lastVisibleItem; index++) {
        var layoutInfo = this.getLayoutInfo('item', 0, index);

        if (rect.intersects(layoutInfo.rect)) {
          res.push(layoutInfo);
        }
      }

      return res;
    }
  }, {
    key: "validate",
    value: function validate() {
      // Compute the number of rows and columns needed to display the content
      var availableWidth = this.collectionView.size.width - this.margin * 2;
      var columns = Math.floor(availableWidth / (this.minItemSize.width + this.minSpace.width));
      this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));
      this.numRows = Math.ceil(this.collectionView.getSectionLength(0) / this.numColumns); // Compute the available width (minus the space between items)

      var width = availableWidth - this.minSpace.width * Math.max(0, this.numColumns - 1); // Compute the item width based on the space available

      var itemWidth = Math.floor(width / this.numColumns);
      itemWidth = Math.max(this.minItemSize.width, Math.min(this.maxItemSize.width, itemWidth)); // Compute the item height, which is proportional to the item width

      var t = (itemWidth - this.minItemSize.width) / this.minItemSize.width;
      var itemHeight = this.minItemSize.height + this.minItemSize.height * t;
      itemHeight = Math.max(this.minItemSize.height, Math.min(this.maxItemSize.height, itemHeight)) + this.itemPadding;
      this.itemSize = new _collectionView.Size(itemWidth, itemHeight); // Compute the horizontal spacing and content height

      this.horizontalSpacing = Math.floor((this.collectionView.size.width - this.numColumns * this.itemSize.width) / (this.numColumns + 1));
      this.contentHeight = this.margin * 2 + this.numRows * this.itemSize.height + (this.numRows - 1) * this.minSpace.height;
    }
  }, {
    key: "getDropTarget",
    value: function getDropTarget(point) {
      var dropPosition = this.component.props.dropPosition === 'on' && !this.collectionView._dragTarget ? _collectionView.DragTarget.DROP_ON : _collectionView.DragTarget.DROP_BETWEEN; // If we are dropping between rows, the target should move to the
      // next item halfway through a row.

      if (dropPosition === _collectionView.DragTarget.DROP_BETWEEN) {
        point = point.copy();
        point.x += (this.itemSize.width + this.horizontalSpacing) / 2;
      }

      var indexPath;

      if (dropPosition === _collectionView.DragTarget.DROP_ON) {
        indexPath = this.collectionView.indexPathAtPoint(point);
      } else {
        var _index = this.getIndexAtPoint(point.x, point.y, true);

        indexPath = new _collectionView.IndexPath(0, _index);
      }

      if (indexPath) {
        return new _collectionView.DragTarget('item', indexPath, dropPosition);
      }

      var index = dropPosition === _collectionView.DragTarget.DROP_ON ? 0 : this.collectionView.getSectionLength(0);
      return new _collectionView.DragTarget('item', new _collectionView.IndexPath(0, index), _collectionView.DragTarget.DROP_BETWEEN);
    }
  }, {
    key: "getContentSize",
    value: function getContentSize() {
      return new _collectionView.Size(this.collectionView.size.width, this.contentHeight);
    }
  }, {
    key: "indexPathAbove",
    value: function indexPathAbove(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, -this.numColumns);
    }
  }, {
    key: "indexPathBelow",
    value: function indexPathBelow(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, this.numColumns);
    }
  }, {
    key: "indexPathLeftOf",
    value: function indexPathLeftOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, -1);
    }
  }, {
    key: "indexPathRightOf",
    value: function indexPathRightOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, 1);
    }
  }]);

  return GridLayout;
}(_BaseLayout2["default"]);

exports["default"] = GridLayout;