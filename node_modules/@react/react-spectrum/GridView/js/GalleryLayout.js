"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _BaseLayout2 = _interopRequireDefault(require("./BaseLayout"));

var _collectionView = require("@react/collection-view");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DEFAULT_OPTIONS = {
  S: {
    idealRowHeight: 112,
    minItemSize: new _collectionView.Size(96, 96),
    itemSpacing: new _collectionView.Size(8, 16),
    itemPadding: 24,
    dropSpacing: 50
  },
  L: {
    idealRowHeight: 208,
    minItemSize: new _collectionView.Size(136, 136),
    itemSpacing: new _collectionView.Size(24, 32),
    itemPadding: 32,
    dropSpacing: 100
  }
};
/**
 * A GalleryLayout is designed to display photos in a grid, filling all available space by
 * scaling the photos to fill each row.
 */

var GalleryLayout =
/*#__PURE__*/
function (_BaseLayout) {
  _inherits(GalleryLayout, _BaseLayout);

  function GalleryLayout() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GalleryLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GalleryLayout).call(this));
    var cardSize = options.cardSize || 'L';
    /**
     * The the default row height
     * @type {number}
     * @default 208
     */

    _this.idealRowHeight = options.idealRowHeight || DEFAULT_OPTIONS[cardSize].idealRowHeight; // TODO
    // this.minItemSize = options.minItemSize || DEFAULT_OPTIONS[cardSize].minItemSize;

    /**
     * The spacing between items
     * @type {Size}
     * @default 24 x 24
     */

    _this.itemSpacing = options.itemSpacing || DEFAULT_OPTIONS[cardSize].itemSpacing;
    /**
     * The vertical padding for an item
     * @type {number}
     * @default 32
     */

    _this.itemPadding = options.itemPadding != null ? options.itemPadding : DEFAULT_OPTIONS[cardSize].itemPadding;
    /**
     * The space between items created when dragging between them
     * @type {number}
     * @default 100
     */

    _this.dropSpacing = options.dropSpacing != null ? options.dropSpacing : DEFAULT_OPTIONS[cardSize].dropSpacing;
    _this.layoutInfos = [];
    _this.cardType = 'gallery';
    return _this;
  }

  _createClass(GalleryLayout, [{
    key: "validate",
    value: function validate() {
      this.layoutInfos = [];
      var y = this.itemSpacing.height;
      var availableWidth = this.collectionView.size.width - this.itemSpacing.width * 2;
      var dropTarget = this.collectionView._dropTarget;

      if (!this.shouldShowDropSpacing()) {
        dropTarget = null;
      }

      var numSections = this.collectionView.getNumberOfSections();

      for (var section = 0; section < numSections; section++) {
        this.layoutInfos[section] = [];
        var numItems = this.collectionView.getSectionLength(section); // Compute aspect ratios for all of the items, and the total width if all items were on in a single row.

        var ratios = [];
        var totalWidth = 0;

        for (var _index = 0; _index < numItems; _index++) {
          var size = this.collectionView.delegate.getItemSize(this.collectionView.getItem(section, _index));
          var ratio = size.width / size.height;
          ratios.push(ratio);
          totalWidth += ratio * this.idealRowHeight;
        } // Determine how many rows we'll need, and partition the items into rows
        // using the aspect ratios as weights.


        var rows = Math.max(1, Math.round(totalWidth / availableWidth));
        var partition = linearPartition(ratios, rows);
        var index = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = partition[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var row = _step.value;
            // Compute the total weight for this row
            var totalWeight = 0;

            for (var j = index; j < index + row.length; j++) {
              totalWeight += ratios[j];
            } // Deternine the row height based on the total available width and weight of this row.


            var _ratio = (availableWidth - (row.length - 1) * this.itemSpacing.width) / totalWeight;

            if (row === partition[partition.length - 1] && _ratio > this.idealRowHeight * 2) {
              _ratio = this.idealRowHeight;
            }

            var height = Math.round(_ratio) + this.itemPadding;
            var x = this.itemSpacing.width; // If the drop target is on this row, shift the whole row to the left to create space for the dropped item

            if (dropTarget && y === this.dropTargetY) {
              x -= this.dropSpacing / 2;
            } // Create items for this row.


            for (var _j = index; _j < index + row.length; _j++) {
              var layoutInfo = new _collectionView.LayoutInfo('item', section, _j);
              var width = Math.round(_ratio * ratios[_j]); // Shift items in this row after the drop target to the right

              if (dropTarget && dropTarget.indexPath.index === _j && y === this.dropTargetY) {
                x += this.dropSpacing;
              }

              layoutInfo.rect = new _collectionView.Rect(x, y, width, height);
              layoutInfo.isLastInRow = _j === index + row.length - 1;
              this.layoutInfos[section][_j] = layoutInfo;
              x += width + this.itemSpacing.width;
            }

            y += height + this.itemSpacing.height;
            index += row.length;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      this.contentHeight = y;
    }
  }, {
    key: "getVisibleLayoutInfos",
    value: function getVisibleLayoutInfos(rect) {
      var res = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layoutInfos[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var section = _step2.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = section[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var layoutInfo = _step3.value;

              if (layoutInfo.rect.intersects(rect)) {
                res.push(layoutInfo);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return res;
    }
  }, {
    key: "getLayoutInfo",
    value: function getLayoutInfo(type, section, index) {
      return this.layoutInfos[section][index];
    }
  }, {
    key: "itemInserted",
    value: function itemInserted(indexPath) {
      this.layoutInfos[indexPath.section].splice(indexPath.index, 0, null);
    }
  }, {
    key: "itemRemoved",
    value: function itemRemoved(indexPath) {
      this.layoutInfos[indexPath.section].splice(indexPath.index, 1);
    }
  }, {
    key: "itemMoved",
    value: function itemMoved(from, to) {
      var layoutInfo = this.layoutInfos[from.section].splice(from.index, 1)[0];
      this.layoutInfos[to.section].splice(to.index, 0, layoutInfo);
    }
  }, {
    key: "itemReplaced",
    value: function itemReplaced(indexPath) {
      this.layoutInfos[indexPath.section][indexPath.index] = null;
    }
  }, {
    key: "sectionInserted",
    value: function sectionInserted(section) {
      this.layoutInfos.splice(section, 0, []);
    }
  }, {
    key: "sectionRemoved",
    value: function sectionRemoved(section) {
      this.layoutInfos.splice(section, 1);
    }
  }, {
    key: "sectionMoved",
    value: function sectionMoved(fromSection, toSection) {
      var section = this.layoutInfos.splice(fromSection, 1)[0];
      this.layoutInfos.splice(toSection, 0, section);
    }
  }, {
    key: "sectionReplaced",
    value: function sectionReplaced(section) {
      this.layoutInfos[section] = [];
    }
  }, {
    key: "indexPathAbove",
    value: function indexPathAbove(indexPath) {
      var layoutInfo = this.getLayoutInfo('item', indexPath.section, indexPath.index);
      var rect = new _collectionView.Rect(layoutInfo.rect.x, 0, 1, layoutInfo.rect.y - 1);
      return this._findClosest(layoutInfo.rect, rect);
    }
  }, {
    key: "indexPathBelow",
    value: function indexPathBelow(indexPath) {
      var layoutInfo = this.getLayoutInfo('item', indexPath.section, indexPath.index);
      var rect = new _collectionView.Rect(layoutInfo.rect.x, layoutInfo.rect.maxY + 1, 1, this.collectionView.contentSize.height);
      return this._findClosest(layoutInfo.rect, rect);
    }
  }, {
    key: "indexPathLeftOf",
    value: function indexPathLeftOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, -1);
    }
  }, {
    key: "indexPathRightOf",
    value: function indexPathRightOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, 1);
    }
  }, {
    key: "getDropTarget",
    value: function getDropTarget(point) {
      var dropPosition = this.component.props.dropPosition === 'on' && !this.collectionView._dragTarget ? _collectionView.DragTarget.DROP_ON : _collectionView.DragTarget.DROP_BETWEEN;
      var indexPath;

      if (dropPosition === _collectionView.DragTarget.DROP_ON) {
        indexPath = this.collectionView.indexPathAtPoint(point);
      } else {
        // Find the closest item in this row
        var layoutInfo = this._findClosestLayoutInfo(point, new _collectionView.Rect(0, point.y, this.collectionView.size.width, this.itemSpacing.height));

        if (layoutInfo) {
          indexPath = new _collectionView.IndexPath(layoutInfo.section, layoutInfo.index); // If the item is the last in a row, and the point is at least half way across, insert the new items after.

          if (layoutInfo.isLastInRow && point.x - layoutInfo.rect.x > layoutInfo.rect.width / 2) {
            indexPath.index++;
          } // Store the row Y position so we can compare in `validate`.


          this.dropTargetY = layoutInfo.rect.y;
        }
      }

      if (indexPath) {
        return new _collectionView.DragTarget('item', indexPath, dropPosition);
      }

      var index = dropPosition === _collectionView.DragTarget.DROP_ON ? 0 : this.collectionView.getSectionLength(0);
      return new _collectionView.DragTarget('item', new _collectionView.IndexPath(0, index), _collectionView.DragTarget.DROP_BETWEEN);
    }
  }]);

  return GalleryLayout;
}(_BaseLayout2["default"]); // https://www8.cs.umu.se/kurser/TDBA77/VT06/algorithms/BOOK/BOOK2/NODE45.HTM


exports["default"] = GalleryLayout;

function linearPartition(seq, k) {
  var n = seq.length;

  if (k <= 0) {
    return [];
  }

  if (k >= n) {
    return seq.map(function (x) {
      return [x];
    });
  }

  if (n === 1) {
    return [seq];
  }

  var table = Array(n).fill().map(function () {
    return Array(k).fill(0);
  });
  var solution = Array(n - 1).fill().map(function () {
    return Array(k - 1).fill(0);
  });

  for (var i = 0; i < n; i++) {
    table[i][0] = seq[i] + (i > 0 ? table[i - 1][0] : 0);
  }

  for (var _i = 0; _i < k; _i++) {
    table[0][_i] = seq[0];
  }

  for (var _i2 = 1; _i2 < n; _i2++) {
    for (var j = 1; j < k; j++) {
      var currentMin = 0;
      var minX = Infinity;

      for (var x = 0; x < _i2; x++) {
        var c1 = table[x][j - 1];
        var c2 = table[_i2][0] - table[x][0];
        var cost = Math.max(c1, c2);

        if (!x || cost < currentMin) {
          currentMin = cost;
          minX = x;
        }
      }

      table[_i2][j] = currentMin;
      solution[_i2 - 1][j - 1] = minX;
    }
  }

  n = n - 1;
  k = k - 2;
  var result = [];

  while (k >= 0) {
    if (n >= 1) {
      var _row = [];

      for (var _i3 = solution[n - 1][k] + 1; _i3 < n + 1; _i3++) {
        _row.push(seq[_i3]);
      }

      result.unshift(_row);
      n = solution[n - 1][k];
    }

    k--;
  }

  var row = [];

  for (var _i4 = 0; _i4 < n + 1; _i4++) {
    row.push(seq[_i4]);
  }

  result.unshift(row);
  return result;
}