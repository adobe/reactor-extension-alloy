"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trapFocus = trapFocus;
exports.TABBABLE_ELEMENT_SELECTOR = exports.FOCUSABLE_ELEMENT_SELECTOR = exports["default"] = void 0;

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _events = require("./events");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _string = require("./string");

var _scrollToDOMNode = _interopRequireDefault(require("./scrollToDOMNode"));

var _class, _class2, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var WHITESPACE_REGEXP = /[\n\r]+|[\s]{1,}/g;
var DELAY_BEFORE_AUTOFOCUS = 20;

var FocusManager = (0, _autobindDecorator["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inherits(FocusManager, _React$Component);

  function FocusManager() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, FocusManager);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FocusManager)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "keysSoFar", '');

    _defineProperty(_assertThisInitialized(_this), "keyClearTimeout", null);

    return _this;
  }

  _createClass(FocusManager, [{
    key: "getItems",
    value: function getItems() {
      var selected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _this$props = this.props,
          itemSelector = _this$props.itemSelector,
          selectedItemSelector = _this$props.selectedItemSelector,
          includeSelf = _this$props.includeSelf;
      var selector = selected && selectedItemSelector ? selectedItemSelector : itemSelector;

      var node = _reactDom["default"].findDOMNode(this);

      var array = [];

      if (includeSelf && node.matches(selector)) {
        array.push(node);
      }

      return array.concat(Array.from(node.querySelectorAll(selector)));
    }
  }, {
    key: "onFocusFirst",
    value: function onFocusFirst(e) {
      var items = this.getItems();

      if (items.length && (!e || items.indexOf(e.target) !== -1)) {
        if (e) {
          e.preventDefault();
        }

        items[0].focus();
      }
    }
  }, {
    key: "onFocusLast",
    value: function onFocusLast(e) {
      var items = this.getItems();

      if (items.length && (!e || items.indexOf(e.target) !== -1)) {
        if (e) {
          e.preventDefault();
        }

        items[items.length - 1].focus();
      }
    }
  }, {
    key: "onFocusPrevious",
    value: function onFocusPrevious(e) {
      var items = this.getItems();

      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();
        var index = items.indexOf(e.target) - 1;

        if (index < 0) {
          index = items.length - 1;
        }

        items[index].focus();
      }
    }
  }, {
    key: "onFocusNext",
    value: function onFocusNext(e) {
      var items = this.getItems();

      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();
        var index = items.indexOf(e.target) + 1;

        if (index >= items.length) {
          index = 0;
        }

        items[index].focus();
      }
    }
  }, {
    key: "onPageUp",
    value: function onPageUp(e) {
      if (this.props.ignorePageUpPageDown) {
        return;
      }

      var items = this.getItems();

      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var listNode = _reactDom["default"].findDOMNode(this);

        var nextPage = Math.max(e.target.offsetTop + e.target.offsetHeight - listNode.clientHeight, 0);
        var index = items.indexOf(e.target);
        var item = items.slice(0, index).reverse().find(function (item) {
          return item.offsetTop < nextPage;
        });

        if (item) {
          item.focus();
          (0, _scrollToDOMNode["default"])(item, listNode, true);
        } else {
          this.onFocusFirst(e);
        }
      }
    }
  }, {
    key: "onPageDown",
    value: function onPageDown(e) {
      if (this.props.ignorePageUpPageDown) {
        return;
      }

      var items = this.getItems();

      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var listNode = _reactDom["default"].findDOMNode(this);

        var nextPage = Math.min(e.target.offsetTop + listNode.clientHeight, listNode.scrollHeight + listNode.clientHeight);
        var index = items.indexOf(e.target) + 1;
        var item = items.slice(index).find(function (item) {
          return item.offsetTop + item.offsetHeight > nextPage;
        });

        if (item) {
          item.focus();
          (0, _scrollToDOMNode["default"])(item, listNode, true);
        } else {
          this.onFocusLast(e);
        }
      }
    }
  }, {
    key: "findItemToFocus",
    value: function findItemToFocus(e) {
      var target = e.target,
          shiftKey = e.shiftKey,
          charCode = e.charCode;
      var character = (0, _string.removeDiacritics)(String.fromCharCode(charCode)).toUpperCase();
      var items = this.getItems();

      if (this.keysSoFar === '' || character === this.keysSoFar || shiftKey) {
        // reverse order if shiftKey is pressed
        if (shiftKey) {
          items = items.reverse();
        }

        this.searchIndex = items.indexOf(target);
      }

      if (character !== this.keysSoFar) {
        this.keysSoFar += character;
      }

      this.clearKeysSoFarAfterDelay();
      var item = this.findMatchInRange(items, this.searchIndex + 1, items.length);

      if (!item) {
        item = this.findMatchInRange(items, 0, this.searchIndex);
      }

      if (item) {
        item.focus();
      }
    }
  }, {
    key: "clearKeysSoFarAfterDelay",
    value: function clearKeysSoFarAfterDelay() {
      var _this2 = this;

      if (this.keyClearTimeout) {
        clearTimeout(this.keyClearTimeout);
      }

      this.keyClearTimeout = setTimeout(function () {
        return _this2.keysSoFar = '';
      }, 500);
    }
  }, {
    key: "findMatchInRange",
    value: function findMatchInRange(items, startIndex, endIndex) {
      // Find the first item starting with the keysSoFar substring, searching in the specified range of items
      for (var i = startIndex; i < endIndex; i++) {
        var label = items[i].innerText || items[i].textContent;

        if (label && (0, _string.removeDiacritics)(label).replace(WHITESPACE_REGEXP, '').toUpperCase().indexOf(this.keysSoFar) === 0) {
          return items[i];
        }
      }

      return null;
    }
    /**
     * Handle keydown event
     * @param {Event} e Event object
     */

  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      _events.interpretKeyboardEvent.call(this, e, this.props.orientation);
    }
    /**
     * Handle keypress event
     * @param {Event} e Event object
     */

  }, {
    key: "onKeyPress",
    value: function onKeyPress(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      this.findItemToFocus(e);
    }
    /**
     * When an item receives focus, it should have tabIndex === 0 and all other items should have tabIndex === -1
     * @param {Event} e Event object
     */

  }, {
    key: "onFocus",
    value: function onFocus(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      this.getItems().forEach(function (item) {
        return item.tabIndex = item === e.target ? 0 : -1;
      });
    }
    /**
     * When an item loses focus, set the appropriate tabIndex on each item based on its selected state.
     * If the item losing focus is selected,
     * it should be the only item to receive focus on shift+tab or tab back to the control,
     * However, if the item losing focus is not selected,
     * any of the selected items should receive focus on shift+tab or tab.
     * @param {Event} e Event object
     */

  }, {
    key: "onBlur",
    value: function onBlur(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      var selectedItems = this.getItems(true); // If there are selected items,

      if (selectedItems.length) {
        // store whether item losing focus is selected.
        var targetSelected = selectedItems.indexOf(e.target) !== -1;
        this.getItems().forEach(function (item) {
          // store whether the current item is selected.
          var selected = selectedItems.indexOf(item) !== -1; // If the current item is the item losing focus and it is selected,
          // or the current item is selected and the item losing focus is not selected,
          // set tabIndex === 0, otherwise set tabIndex === -1.

          item.tabIndex = item === e.target && targetSelected || !targetSelected && selected ? 0 : -1;
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      var _this$props2 = this.props,
          autoFocus = _this$props2.autoFocus,
          selectedItemSelector = _this$props2.selectedItemSelector;

      if (autoFocus) {
        var selectedItem = selectedItemSelector ? _reactDom["default"].findDOMNode(this).querySelector(selectedItemSelector) : null; // wait a frame before trying to shift focus

        this.focusTimer = setTimeout(function () {
          if (selectedItem) {
            selectedItem.focus();
          } else {
            _this3.onFocusFirst();
          }
        }, DELAY_BEFORE_AUTOFOCUS);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.focusTimer);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          children = _this$props3.children,
          disabled = _this$props3.disabled,
          manageTabIndex = _this$props3.manageTabIndex,
          typeToSelect = _this$props3.typeToSelect;

      var child = _react["default"].Children.only(children);

      var _child$props = child.props,
          onKeyDown = _child$props.onKeyDown,
          onKeyPress = _child$props.onKeyPress,
          onFocus = _child$props.onFocus,
          onBlur = _child$props.onBlur;
      return _react["default"].cloneElement(child, {
        onKeyDown: !disabled ? (0, _events.chain)(onKeyDown, this.onKeyDown) : onKeyDown,
        onKeyPress: typeToSelect && !disabled ? (0, _events.chain)(onKeyPress, this.onKeyPress) : onKeyPress,
        onFocus: manageTabIndex && !disabled ? (0, _events.chain)(onFocus, this.onFocus) : onFocus,
        onBlur: manageTabIndex && !disabled ? (0, _events.chain)(onBlur, this.onBlur) : onBlur
      });
    }
  }]);

  return FocusManager;
}(_react["default"].Component), _defineProperty(_class2, "propTypes", {
  /**
   * A selector of focusable elements to manage focus between
   */
  itemSelector: _propTypes["default"].string.isRequired,

  /**
   * Whether to use roving tabIndex so that only one element within the group can receive focus with tab key at a time.
   */
  manageTabIndex: _propTypes["default"].bool,

  /**
   * Orientation of items; "horizontal" orientation ignores up/down arrow keys, "vertical" orientation ignores left/right arrow keys, "both" handles up/left and down/right.
   */
  orientation: _propTypes["default"].oneOf(['horizontal', 'vertical', 'both']),

  /**
   * A selector of selected elements
   */
  selectedItemSelector: _propTypes["default"].string,

  /**
   * Whether to disable focus management
   */
  disabled: _propTypes["default"].bool,

  /**
   * Whether to include alphanumeric typing as a way to move focus to items in a list.
   */
  typeToSelect: _propTypes["default"].bool,

  /**
   * Whether to include the child wrapper element in the group of elements that can receive focus.
   */
  includeSelf: _propTypes["default"].bool,

  /**
   * Whether to ignore PageUp and PageDown events to move focus between items.
   */
  ignorePageUpPageDown: _propTypes["default"].bool,

  /**
   * Whether to autoFocus first selected item or first item.
   */
  autoFocus: _propTypes["default"].bool
}), _defineProperty(_class2, "defaultProps", {
  manageTabIndex: true,
  orientation: 'vertical',
  typeToSelect: false,
  includeSelf: false,
  ignorePageUpPageDown: false
}), _temp)) || _class;

exports["default"] = FocusManager;
var focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];
var FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(',') + ',[tabindex]';
exports.FOCUSABLE_ELEMENT_SELECTOR = FOCUSABLE_ELEMENT_SELECTOR;
focusableElements.push('[tabindex]:not([tabindex="-1"])');
var TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([tabindex="-1"]),');
exports.TABBABLE_ELEMENT_SELECTOR = TABBABLE_ELEMENT_SELECTOR;

function trapFocus(componentOrElement, event) {
  var type = event.type,
      key = event.key,
      shiftKey = event.shiftKey,
      target = event.target;
  var node;
  var tabbables;
  var tabbable;
  var first;
  var last;

  if (type === 'keydown' || type === 'focus') {
    node = _reactDom["default"].findDOMNode(componentOrElement);

    if (node) {
      // find tabbable elements within container element
      tabbables = Array.from(node.querySelectorAll(TABBABLE_ELEMENT_SELECTOR)).filter(function (el) {
        return el !== node;
      });
      first = tabbables[0] || node;
      last = tabbables[tabbables.length - 1] || node;
    }
  } // If navigating using the tab key,


  if (type === 'keydown' && key === 'Tab') {
    if (node) {
      if (shiftKey) {
        // with focus on first tabbable element, navigating backwards,
        if (target === first || target === node) {
          // focus the last tabbable element
          tabbable = last;
        } // otherwise, with focus on last tabbable element, navigating forwards,

      } else if (target === last || target === node) {
        // focus the first tabbable element.
        tabbable = first;
      }
    }
  } else if (type === 'focus' && target === node) {
    tabbable = first;
  }

  if (tabbable) {
    event.preventDefault();
    event.stopPropagation();

    if (tabbable !== document.activeElement) {
      tabbable.focus();
    }
  }
}